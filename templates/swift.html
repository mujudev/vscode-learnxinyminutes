<h1>Swift</h1>
<p>Swift is a programming language for iOS and macOS development created by Apple. Designed to coexist with Objective-C and to be more resilient against erroneous code, Swift was introduced in 2014 at Apple's developer conference WWDC. It is built with the LLVM compiler included in Xcode 6+.</p>
<p>The official <em><a href="https://itunes.apple.com/us/book/swift-programming-language/id881256329" rel="nofollow">Swift Programming Language</a></em> book from Apple is now available via iBooks. It goes into much more detail than this guide, and if you have the time and patience to read it, it's recommended. Some of these examples are from that book.</p>
<p>Another great reference is <em>About Swift</em> on Swift's <a href="https://docs.swift.org/swift-book/" rel="nofollow">website</a>.</p>
<div class="highlight highlight-source-swift"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span> import a module</span>
<span class="pl-c"></span><span class="pl-k">import</span> <span class="pl-en">Foundation</span>

<span class="pl-c"><span class="pl-c">//</span> Single-line comments are prefixed with //</span>
<span class="pl-c"><span class="pl-c">//</span> Multi-line comments start with /* and end with */</span>
<span class="pl-c"></span><span class="pl-c"><span class="pl-c">/*</span> Nested multiline comments</span>
<span class="pl-c"> /* ARE */</span>
<span class="pl-c"> allowed</span>
<span class="pl-c"> <span class="pl-c">*/</span></span>

<span class="pl-c"><span class="pl-c">//</span> Xcode supports landmarks to annotate your code and lists them in the jump bar</span>
<span class="pl-c"><span class="pl-c">//</span> MARK: Section mark</span>
<span class="pl-c"><span class="pl-c">//</span> MARK: - Section mark with a separator line</span>
<span class="pl-c"><span class="pl-c">//</span> TODO: Do something soon</span>
<span class="pl-c"><span class="pl-c">//</span> FIXME: Fix this code</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span>MARK: Hello, World</span>
<span class="pl-c"><span class="pl-c">//</span> From Swift 3 on, to print, just use the `print` method.</span>
<span class="pl-c"><span class="pl-c">//</span> It automatically appends a new line.</span>
<span class="pl-c"></span><span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Hello, world<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span> MARK: - Variables</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"></span>

<span class="pl-c"><span class="pl-c">//</span>Use `let` to declare a constant and `var` to declare a variable.</span>
<span class="pl-c"></span><span class="pl-k">let</span> theAnswer <span class="pl-k">=</span> <span class="pl-c1">42</span>
<span class="pl-k">var</span> theQuestion <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>What is the Answer?<span class="pl-pds">"</span></span>
theQuestion <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>How many roads must a man walk down?<span class="pl-pds">"</span></span>
theQuestion <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>What is six by nine?<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">//</span> Atttempting to reassign a constant throws a compile-time error</span>
<span class="pl-c"><span class="pl-c">//</span>theAnswer = 54</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Both variables and constants can be declared before they are given a value,</span>
<span class="pl-c"><span class="pl-c">//</span>   but must be given a value before they are used</span>
<span class="pl-c"></span><span class="pl-k">let</span> someConstant: <span class="pl-c1">Int</span>
<span class="pl-k">var</span> someVariable: <span class="pl-c1">String</span>
<span class="pl-c"><span class="pl-c">//</span> These lines will throw errors:</span>
<span class="pl-c"><span class="pl-c">//</span>print(someConstant)</span>
<span class="pl-c"><span class="pl-c">//</span>print(someVariable)</span>
<span class="pl-c"></span>someConstant <span class="pl-k">=</span> <span class="pl-c1">0</span>
someVariable <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">//</span> These lines are now valid:</span>
<span class="pl-c"></span><span class="pl-c1">print</span>(someConstant)
<span class="pl-c1">print</span>(someVariable)

<span class="pl-c"><span class="pl-c">//</span> As you can see above, variable types are automatically inferred.</span>
<span class="pl-c"><span class="pl-c">//</span>   To explicitly declare the type, write it after the variable name,</span>
<span class="pl-c"><span class="pl-c">//</span>   separated by a colon.</span>
<span class="pl-c"></span><span class="pl-k">let</span> aString: <span class="pl-c1">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>A string<span class="pl-pds">"</span></span>
<span class="pl-k">let</span> aDouble: <span class="pl-c1">Double</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>

<span class="pl-c"><span class="pl-c">//</span> Values are never implicitly converted to another type.</span>
<span class="pl-c"><span class="pl-c">//</span> Explicitly make instances of the desired type.</span>
<span class="pl-c"></span><span class="pl-k">let</span> stringWithDouble <span class="pl-k">=</span> aString <span class="pl-k">+</span> <span class="pl-c1">String</span>(aDouble)
<span class="pl-k">let</span> intFromDouble <span class="pl-k">=</span> <span class="pl-c1">Int</span>(aDouble)

<span class="pl-c"><span class="pl-c">//</span> For strings, use string interpolation</span>
<span class="pl-c"></span><span class="pl-k">let</span> descriptionString <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>The value of aDouble is <span class="pl-pse">\(</span><span class="pl-s1">aDouble</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">//</span> You can put any expression inside string interpolation.</span>
<span class="pl-c"></span><span class="pl-k">let</span> equation <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Six by nine is <span class="pl-pse">\(</span><span class="pl-s1"><span class="pl-c1">6</span> <span class="pl-k">*</span> <span class="pl-c1">9</span></span><span class="pl-pse"><span class="pl-s1">)</span></span>, not 42!<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">//</span> To avoid escaping double quotes and backslashes, change the string delimiter</span>
<span class="pl-c"></span><span class="pl-k">let</span> explanationString <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">#"</span>The string I used was "The value of aDouble is \(aDouble)" and the result was <span class="pl-pse">\#(</span><span class="pl-s1">descriptionString</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"#</span></span>
<span class="pl-c"><span class="pl-c">//</span> You can put as many number signs as you want before the opening quote,</span>
<span class="pl-c"><span class="pl-c">//</span>   just match them at the ending quote. They also change the escape character</span>
<span class="pl-c"><span class="pl-c">//</span>   to a backslash followed by the same number of number signs.</span>
<span class="pl-c"></span>
<span class="pl-k">let</span> multiLineString <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    This is a multi-line string.</span>
<span class="pl-s">    It's called that because it takes up multiple lines (wow!)</span>
<span class="pl-s">        Any indentation beyond the closing quotation marks is kept, the rest is discarded.</span>
<span class="pl-s">    You can include " or "" in multi-line strings because the delimiter is three "s.</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>

<span class="pl-c"><span class="pl-c">//</span> Arrays</span>
<span class="pl-c"></span><span class="pl-k">let</span> shoppingList <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>catfish<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>water<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>tulips<span class="pl-pds">"</span></span>,] <span class="pl-c"><span class="pl-c">//</span>commas are allowed after the last element</span>
<span class="pl-c"></span><span class="pl-k">let</span> secondElement <span class="pl-k">=</span> shoppingList[<span class="pl-c1">1</span>] <span class="pl-c"><span class="pl-c">//</span> Arrays are 0-indexed</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Arrays declared with let are immutable; the following line throws a compile-time error</span>
<span class="pl-c"><span class="pl-c">//</span>shoppingList[2] = "mango"</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Arrays are structs (more on that later), so this creates a copy instead of referencing the same object</span>
<span class="pl-c"></span><span class="pl-k">var</span> mutableShoppingList <span class="pl-k">=</span> shoppingList
mutableShoppingList[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>mango<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">//</span> == is equality</span>
<span class="pl-c"></span>shoppingList <span class="pl-k">==</span> mutableShoppingList <span class="pl-c"><span class="pl-c">//</span> false</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Dictionaries declared with let are also immutable</span>
<span class="pl-c"></span><span class="pl-k">var</span> occupations <span class="pl-k">=</span> [
    <span class="pl-s"><span class="pl-pds">"</span>Malcolm<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Captain<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>Kaylee<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Mechanic<span class="pl-pds">"</span></span>
]
occupations[<span class="pl-s"><span class="pl-pds">"</span>Jayne<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Public Relations<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">//</span> Dictionaries are also structs, so this also creates a copy</span>
<span class="pl-c"></span><span class="pl-k">let</span> immutableOccupations <span class="pl-k">=</span> occupations

immutableOccupations <span class="pl-k">==</span> occupations <span class="pl-c"><span class="pl-c">//</span> true</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Arrays and dictionaries both automatically grow as you add elements</span>
<span class="pl-c"></span>mutableShoppingList.<span class="pl-c1">append</span>(<span class="pl-s"><span class="pl-pds">"</span>blue paint<span class="pl-pds">"</span></span>)
occupations[<span class="pl-s"><span class="pl-pds">"</span>Tim<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>CEO<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">//</span> They can both be set to empty</span>
<span class="pl-c"></span>mutableShoppingList <span class="pl-k">=</span> []
occupations <span class="pl-k">=</span> [<span class="pl-k">:</span>]

<span class="pl-k">let</span> emptyArray <span class="pl-k">=</span> [<span class="pl-c1">String</span>]()
<span class="pl-k">let</span> emptyArray2 <span class="pl-k">=</span> <span class="pl-c1">Array</span><span class="pl-k">&lt;</span><span class="pl-c1">String</span><span class="pl-k">&gt;</span>() <span class="pl-c"><span class="pl-c">//</span> same as above</span>
<span class="pl-c"><span class="pl-c">//</span> [T] is shorthand for Array&lt;T&gt;</span>
<span class="pl-c"></span><span class="pl-k">let</span> emptyArray3: [<span class="pl-c1">String</span>] <span class="pl-k">=</span> [] <span class="pl-c"><span class="pl-c">//</span> Declaring the type explicitly allows you to set it to an empty array</span>
<span class="pl-c"></span><span class="pl-k">let</span> emptyArray4: <span class="pl-c1">Array</span>&lt;<span class="pl-c1">String</span>&gt; <span class="pl-k">=</span> [] <span class="pl-c"><span class="pl-c">//</span> same as above</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> [Key: Value] is shorthand for Dictionary&lt;Key, Value&gt;</span>
<span class="pl-c"></span><span class="pl-k">let</span> emptyDictionary <span class="pl-k">=</span> [<span class="pl-c1">String</span><span class="pl-k">:</span> <span class="pl-c1">Double</span>]()
<span class="pl-k">let</span> emptyDictionary2 <span class="pl-k">=</span> <span class="pl-c1">Dictionary</span><span class="pl-k">&lt;</span><span class="pl-c1">String</span>, <span class="pl-c1">Double</span><span class="pl-k">&gt;</span>() <span class="pl-c"><span class="pl-c">//</span> same as above</span>
<span class="pl-c"></span><span class="pl-k">var</span> emptyMutableDictionary: [<span class="pl-c1">String</span>: <span class="pl-c1">Double</span>] <span class="pl-k">=</span> [<span class="pl-k">:</span>]
<span class="pl-k">var</span> explicitEmptyMutableDictionary: <span class="pl-c1">Dictionary</span>&lt;<span class="pl-c1">String</span>, <span class="pl-c1">Double</span>&gt; <span class="pl-k">=</span> [<span class="pl-k">:</span>] <span class="pl-c"><span class="pl-c">//</span> same as above</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> MARK: Other variables</span>
<span class="pl-c"></span><span class="pl-k">let</span> øπΩ <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>value<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> unicode variable names</span>
<span class="pl-c"></span><span class="pl-k">let</span> 🤯 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>wow<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> emoji variable names</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Keywords can be used as variable names</span>
<span class="pl-c"><span class="pl-c">//</span> These are contextual keywords that wouldn't be used now, so are allowed</span>
<span class="pl-c"></span><span class="pl-k">let</span> <span class="pl-k">convenience</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>keyword<span class="pl-pds">"</span></span>
<span class="pl-k">let</span> <span class="pl-k">weak</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>another keyword<span class="pl-pds">"</span></span>
<span class="pl-k">let</span> <span class="pl-k">override</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>another keyword<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">//</span> Using backticks allows keywords to be used as variable names even if they wouldn't be allowed normally</span>
<span class="pl-c"></span><span class="pl-k">let</span> `<span class="pl-k">class</span>` <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>keyword<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">//</span> MARK: - Optionals</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"> Optionals are a Swift language feature that either contains a value,</span>
<span class="pl-c"> or contains nil (no value) to indicate that a value is missing.</span>
<span class="pl-c"> Nil is roughly equivalent to `null` in other languages.</span>
<span class="pl-c"> A question mark (?) after the type marks the value as optional of that type.</span>
<span class="pl-c"></span>
<span class="pl-c"> If a type is not optional, it is guaranteed to have a value.</span>
<span class="pl-c"></span>
<span class="pl-c"> Because Swift requires every property to have a type, even nil must be</span>
<span class="pl-c"> explicitly stored as an Optional value.</span>
<span class="pl-c"></span>
<span class="pl-c"> Optional&lt;T&gt; is an enum, with the cases .none (nil) and .some(T) (the value)</span>
<span class="pl-c"> <span class="pl-c">*/</span></span>

<span class="pl-k">var</span> someOptionalString: <span class="pl-c1">String</span><span class="pl-k">?</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>optional<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> Can be nil</span>
<span class="pl-c"><span class="pl-c">//</span> T? is shorthand for Optional&lt;T&gt; — ? is a postfix operator (syntax candy)</span>
<span class="pl-c"></span><span class="pl-k">let</span> someOptionalString2: <span class="pl-c1">Optional</span>&lt;<span class="pl-c1">String</span>&gt; <span class="pl-k">=</span> <span class="pl-c1">nil</span>
<span class="pl-k">let</span> someOptionalString3 <span class="pl-k">=</span> <span class="pl-c1">String</span><span class="pl-k">?</span>.<span class="pl-c1">some</span>(<span class="pl-s"><span class="pl-pds">"</span>optional<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> same as the first one</span>
<span class="pl-c"></span><span class="pl-k">let</span> someOptionalString4 <span class="pl-k">=</span> <span class="pl-c1">String</span><span class="pl-k">?</span>.<span class="pl-c1">none</span> <span class="pl-c"><span class="pl-c">//</span>nil</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"> To access the value of an optional that has a value, use the postfix</span>
<span class="pl-c"> operator !, which force-unwraps it. Force-unwrapping is like saying, "I</span>
<span class="pl-c"> know that this optional definitely has a value, please give it to me."</span>
<span class="pl-c"></span>
<span class="pl-c"> Trying to use ! to access a non-existent optional value triggers a</span>
<span class="pl-c"> runtime error. Always make sure that an optional contains a non-nil</span>
<span class="pl-c"> value before using ! to force-unwrap its value.</span>
<span class="pl-c"> <span class="pl-c">*/</span></span>

<span class="pl-k">if</span> someOptionalString <span class="pl-k">!=</span> <span class="pl-c1">nil</span> {
    <span class="pl-c"><span class="pl-c">//</span> I am not nil</span>
<span class="pl-c"></span>    <span class="pl-k">if</span> someOptionalString<span class="pl-k">!</span>.<span class="pl-c1">hasPrefix</span>(<span class="pl-s"><span class="pl-pds">"</span>opt<span class="pl-pds">"</span></span>) {
        <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>has the prefix<span class="pl-pds">"</span></span>)
    }
}

<span class="pl-c"><span class="pl-c">//</span> Swift supports "optional chaining," which means that you can call functions</span>
<span class="pl-c"><span class="pl-c">//</span>   or get properties of optional values and they are optionals of the appropriate type.</span>
<span class="pl-c"><span class="pl-c">//</span> You can even do this multiple times, hence the name "chaining."</span>
<span class="pl-c"></span>
<span class="pl-k">let</span> empty <span class="pl-k">=</span> someOptionalString<span class="pl-k">?</span>.<span class="pl-c1">isEmpty</span> <span class="pl-c"><span class="pl-c">//</span> Bool?</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> if-let structure -</span>
<span class="pl-c"><span class="pl-c">//</span> if-let is a special structure in Swift that allows you to check</span>
<span class="pl-c"><span class="pl-c">//</span>   if an Optional rhs holds a value, and if it does unwrap</span>
<span class="pl-c"><span class="pl-c">//</span>   and assign it to the lhs.</span>
<span class="pl-c"></span><span class="pl-k">if</span> <span class="pl-k">let</span> someNonOptionalStringConstant <span class="pl-k">=</span> someOptionalString {
    <span class="pl-c"><span class="pl-c">//</span> has `Some` value, non-nil</span>
<span class="pl-c"></span>    <span class="pl-c"><span class="pl-c">//</span> someOptionalStringConstant is of type String, not type String?</span>
<span class="pl-c"></span>    <span class="pl-k">if</span> <span class="pl-k">!</span>someNonOptionalStringConstant.<span class="pl-c1">hasPrefix</span>(<span class="pl-s"><span class="pl-pds">"</span>ok<span class="pl-pds">"</span></span>) {
        <span class="pl-c"><span class="pl-c">//</span> does not have the prefix</span>
<span class="pl-c"></span>    }
}

<span class="pl-c"><span class="pl-c">//</span>if-var is allowed too!</span>
<span class="pl-c"></span><span class="pl-k">if</span> <span class="pl-k">var</span> someNonOptionalString <span class="pl-k">=</span> someOptionalString {
    someNonOptionalString <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Non optional AND mutable<span class="pl-pds">"</span></span>
    <span class="pl-c1">print</span>(someNonOptionalString)
}

<span class="pl-c"><span class="pl-c">//</span> You can bind multiple optional values in one if-let statement.</span>
<span class="pl-c"><span class="pl-c">//</span>   If any of the bound values are nil, the if statement does not execute.</span>
<span class="pl-c"></span><span class="pl-k">if</span> <span class="pl-k">let</span> first <span class="pl-k">=</span> someOptionalString, <span class="pl-k">let</span> second <span class="pl-k">=</span> someOptionalString2,
    <span class="pl-k">let</span> third <span class="pl-k">=</span> someOptionalString3, <span class="pl-k">let</span> fourth <span class="pl-k">=</span> someOptionalString4 {
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">first</span><span class="pl-pse"><span class="pl-s1">)</span></span>, <span class="pl-pse">\(</span><span class="pl-s1">second</span><span class="pl-pse"><span class="pl-s1">)</span></span>, <span class="pl-pse">\(</span><span class="pl-s1">third</span><span class="pl-pse"><span class="pl-s1">)</span></span>, and <span class="pl-pse">\(</span><span class="pl-s1">fourth</span><span class="pl-pse"><span class="pl-s1">)</span></span> are all not nil<span class="pl-pds">"</span></span>)
}

<span class="pl-c"><span class="pl-c">//</span>if-let supports "," (comma) clauses, which can be used to</span>
<span class="pl-c"><span class="pl-c">//</span>   enforce conditions on newly-bound optional values.</span>
<span class="pl-c"><span class="pl-c">//</span> Both the assignment and the "," clause must pass.</span>
<span class="pl-c"></span><span class="pl-k">let</span> someNumber: <span class="pl-c1">Int</span><span class="pl-k">?</span> <span class="pl-k">=</span> <span class="pl-c1">7</span>
<span class="pl-k">if</span> <span class="pl-k">let</span> num <span class="pl-k">=</span> someNumber, num <span class="pl-k">&gt;</span> <span class="pl-c1">3</span> {
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>num is not nil and is greater than 3<span class="pl-pds">"</span></span>)
}

<span class="pl-c"><span class="pl-c">//</span> Implicitly unwrapped optional — An optional value that doesn't need to be unwrapped</span>
<span class="pl-c"></span><span class="pl-k">let</span> unwrappedString: <span class="pl-c1">String</span><span class="pl-k">!</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Value is expected.<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">//</span> Here's the difference:</span>
<span class="pl-c"></span><span class="pl-k">let</span> forcedString <span class="pl-k">=</span> someOptionalString<span class="pl-k">!</span> <span class="pl-c"><span class="pl-c">//</span> requires an exclamation mark</span>
<span class="pl-c"></span><span class="pl-k">let</span> implicitString <span class="pl-k">=</span> unwrappedString <span class="pl-c"><span class="pl-c">//</span> doesn't require an exclamation mark</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"> You can think of an implicitly unwrapped optional as giving permission</span>
<span class="pl-c"> for the optional to be unwrapped automatically whenever it's used.</span>
<span class="pl-c"> Rather than placing an exclamation mark after the optional's name each time you use it,</span>
<span class="pl-c"> you place an exclamation mark after the optional's type when you declare it.</span>
<span class="pl-c"> <span class="pl-c">*/</span></span>

<span class="pl-c"><span class="pl-c">//</span> Otherwise, you can treat an implicitly unwrapped optional the same way the you treat a normal optional</span>
<span class="pl-c"><span class="pl-c">//</span>   (i.e., if-let, != nil, etc.)</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Pre-Swift 5, T! was shorthand for ImplicitlyUnwrappedOptional&lt;T&gt;</span>
<span class="pl-c"><span class="pl-c">//</span> Swift 5 and later, using ImplicitlyUnwrappedOptional throws a compile-time error.</span>
<span class="pl-c"><span class="pl-c">//</span>var unwrappedString2: ImplicitlyUnwrappedOptional&lt;String&gt; = "Value is expected." //error</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> The nil-coalescing operator ?? unwraps an optional if it contains a non-nil value, or returns a default value.</span>
<span class="pl-c"></span>someOptionalString <span class="pl-k">=</span> <span class="pl-c1">nil</span>
<span class="pl-k">let</span> someString <span class="pl-k">=</span> someOptionalString <span class="pl-k">??</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>
<span class="pl-c1">print</span>(someString) <span class="pl-c"><span class="pl-c">//</span> abc</span>
<span class="pl-c"><span class="pl-c">//</span> a ?? b is shorthand for a != nil ? a! : b</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> MARK: - Control Flow</span>
<span class="pl-c"></span>
<span class="pl-k">let</span> condition <span class="pl-k">=</span> <span class="pl-c1">true</span>
<span class="pl-k">if</span> condition { <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>condition is true<span class="pl-pds">"</span></span>) } <span class="pl-c"><span class="pl-c">//</span> can't omit the braces</span>
<span class="pl-c"></span>
<span class="pl-k">if</span> theAnswer <span class="pl-k">&gt;</span> <span class="pl-c1">50</span> {
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>theAnswer &gt; 50<span class="pl-pds">"</span></span>)
} <span class="pl-k">else</span> <span class="pl-k">if</span> condition {
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>condition is true<span class="pl-pds">"</span></span>)
} <span class="pl-k">else</span> {
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Neither are true<span class="pl-pds">"</span></span>)
}

<span class="pl-c"><span class="pl-c">//</span> The condition in an `if` statement must be a `Bool`, so the following code is an error, not an implicit comparison to zero</span>
<span class="pl-c"><span class="pl-c">//</span>if 5 {</span>
<span class="pl-c"><span class="pl-c">//</span>    print("5 is not zero")</span>
<span class="pl-c"><span class="pl-c">//</span>}</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Switch</span>
<span class="pl-c"><span class="pl-c">//</span> Must be exhaustive</span>
<span class="pl-c"><span class="pl-c">//</span> Does not implicitly fall through, use the fallthrough keyword</span>
<span class="pl-c"><span class="pl-c">//</span> Very powerful, think `if` statements with syntax candy</span>
<span class="pl-c"><span class="pl-c">//</span> They support String, object instances, and primitives (Int, Double, etc)</span>
<span class="pl-c"></span><span class="pl-k">let</span> vegetable <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>red pepper<span class="pl-pds">"</span></span>
<span class="pl-k">let</span> vegetableComment: <span class="pl-c1">String</span>
<span class="pl-k">switch</span> vegetable {
<span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">"</span>celery<span class="pl-pds">"</span></span><span class="pl-k">:</span>
    vegetableComment <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Add some raisins and make ants on a log.<span class="pl-pds">"</span></span>
<span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">"</span>cucumber<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>watercress<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c"><span class="pl-c">//</span> match multiple values</span>
<span class="pl-c"></span>    vegetableComment <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>That would make a good tea sandwich.<span class="pl-pds">"</span></span>
<span class="pl-k">case</span> <span class="pl-k">let</span> localScopeValue <span class="pl-k">where</span> localScopeValue.<span class="pl-c1">hasSuffix</span>(<span class="pl-s"><span class="pl-pds">"</span>pepper<span class="pl-pds">"</span></span>)<span class="pl-k">:</span>
    vegetableComment <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Is it a spicy <span class="pl-pse">\(</span><span class="pl-s1">localScopeValue</span><span class="pl-pse"><span class="pl-s1">)</span></span>?<span class="pl-pds">"</span></span>
<span class="pl-k">default</span><span class="pl-k">:</span> <span class="pl-c"><span class="pl-c">//</span> required (in order to cover all possible input)</span>
<span class="pl-c"></span>    vegetableComment <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Everything tastes good in soup.<span class="pl-pds">"</span></span>
}
<span class="pl-c1">print</span>(vegetableComment)

<span class="pl-c"><span class="pl-c">//</span> You use the `for-in` loop to iterate over a sequence, such as an array, dictionary, range, etc.</span>
<span class="pl-c"></span><span class="pl-k">for</span> element <span class="pl-k">in</span> shoppingList {
    <span class="pl-c1">print</span>(element) <span class="pl-c"><span class="pl-c">//</span> shoppingList is of type `[String]`, so element is of type `String`</span>
<span class="pl-c"></span>}
<span class="pl-c"><span class="pl-c">//</span>Iterating through a dictionary does not guarantee any specific order</span>
<span class="pl-c"></span><span class="pl-k">for</span> (person, job) <span class="pl-k">in</span> immutableOccupations {
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">person</span><span class="pl-pse"><span class="pl-s1">)</span></span>'s job is <span class="pl-pse">\(</span><span class="pl-s1">job</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>)
}
<span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">...</span><span class="pl-c1">5</span> {
    <span class="pl-c1">print</span>(i, <span class="pl-c1">terminator</span>: <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> Prints "1 2 3 4 5"</span>
<span class="pl-c"></span>}
<span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">..&lt;</span><span class="pl-c1">5</span> {
    <span class="pl-c1">print</span>(i, <span class="pl-c1">terminator</span>: <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> Prints "0 1 2 3 4"</span>
<span class="pl-c"></span>}
<span class="pl-c"><span class="pl-c">//</span>for index in range can replace a C-style for loop:</span>
<span class="pl-c"><span class="pl-c">//</span>    for (int i = 0; i &lt; 10; i++) {</span>
<span class="pl-c"><span class="pl-c">//</span>        //code</span>
<span class="pl-c"><span class="pl-c">//</span>    }</span>
<span class="pl-c"><span class="pl-c">//</span>becomes:</span>
<span class="pl-c"><span class="pl-c">//</span>    for i in 0..&lt;10 {</span>
<span class="pl-c"><span class="pl-c">//</span>        //code</span>
<span class="pl-c"><span class="pl-c">//</span>    }</span>
<span class="pl-c"><span class="pl-c">//</span>To step by more than one, use the stride(from:to:by:) or stride(from:through:by) functions</span>
<span class="pl-c"><span class="pl-c">//</span>`for i in stride(from: 0, to: 10, by: 2)` is the same as `for (int i = 0; i &lt; 10; i += 2)`</span>
<span class="pl-c"><span class="pl-c">//</span>`for i in stride(from: 0, through: 10, by: 2)` is the same as `for (int i = 0; i &lt;= 10; i += 2)</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> while loops are just like most languages</span>
<span class="pl-c"></span><span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>
<span class="pl-k">while</span> i <span class="pl-k">&lt;</span> <span class="pl-c1">5</span> {
    i <span class="pl-k">+=</span> <span class="pl-c1">Bool</span>.<span class="pl-c1">random</span>() <span class="pl-k">?</span> <span class="pl-c1">1</span> <span class="pl-k">:</span> <span class="pl-c1">0</span>
    <span class="pl-c1">print</span>(i)
}

<span class="pl-c"><span class="pl-c">//</span> This is like a do-while loop in other languages — the body of the loop executes a minimum of once</span>
<span class="pl-c"></span><span class="pl-k">repeat</span> {
    i <span class="pl-k">-=</span> <span class="pl-c1">1</span>
    i <span class="pl-k">+=</span> <span class="pl-c1">Int</span>.<span class="pl-c1">random</span>(<span class="pl-c1">in</span>: <span class="pl-c1">0</span><span class="pl-k">...</span><span class="pl-c1">3</span>)
} <span class="pl-k">while</span> i <span class="pl-k">&lt;</span> <span class="pl-c1">5</span>

<span class="pl-c"><span class="pl-c">//</span> The continue statement continues executing a loop at the next iteration</span>
<span class="pl-c"><span class="pl-c">//</span> The break statement ends a loop immediately</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> MARK: - Functions</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Functions are a first-class type, meaning they can be nested in functions and can be passed around.</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Function with Swift header docs (format as Swift-modified Markdown syntax)</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">///</span> A greet operation.</span>
<span class="pl-c"><span class="pl-c">///</span></span>
<span class="pl-c"><span class="pl-c">///</span> - Parameters:</span>
<span class="pl-c"><span class="pl-c">///</span>   - name: A name.</span>
<span class="pl-c"><span class="pl-c">///</span>   - day: A day.</span>
<span class="pl-c"><span class="pl-c">///</span> - Returns: A string containing the name and day value.</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">greet</span>(<span class="pl-smi"><span class="pl-en">name</span></span>: <span class="pl-c1">String</span>, <span class="pl-smi"><span class="pl-en">day</span></span>: <span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span> {
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Hello <span class="pl-pse">\(</span><span class="pl-s1">name</span><span class="pl-pse"><span class="pl-s1">)</span></span>, today is <span class="pl-pse">\(</span><span class="pl-s1">day</span><span class="pl-pse"><span class="pl-s1">)</span></span>.<span class="pl-pds">"</span></span>
}
<span class="pl-c1">greet</span>(<span class="pl-c1">name</span>: <span class="pl-s"><span class="pl-pds">"</span>Bob<span class="pl-pds">"</span></span>, <span class="pl-c1">day</span>: <span class="pl-s"><span class="pl-pds">"</span>Tuesday<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> Ideally, function names and parameter labels combine to make function calls similar to sentences.</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">sayHello</span>(<span class="pl-en">to</span> <span class="pl-smi">name</span>: <span class="pl-c1">String</span>, <span class="pl-en">onDay</span> <span class="pl-smi">day</span>: <span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span> {
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Hello <span class="pl-pse">\(</span><span class="pl-s1">name</span><span class="pl-pse"><span class="pl-s1">)</span></span>, the day is <span class="pl-pse">\(</span><span class="pl-s1">day</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>
}
<span class="pl-c1">sayHello</span>(<span class="pl-c1">to</span>: <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>, <span class="pl-c1">onDay</span>: <span class="pl-s"><span class="pl-pds">"</span>Sunday<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span>Functions that don't return anything can omit the return arrow; they don't need to say that they return Void (although they can).</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">helloWorld</span>() {
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Hello, World!<span class="pl-pds">"</span></span>)
}

<span class="pl-c"><span class="pl-c">//</span> Argument labels can be blank</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">say</span>(<span class="pl-en">_</span> <span class="pl-smi">message</span>: <span class="pl-c1">String</span>) {
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">#"</span>I say "<span class="pl-pse">\#(</span><span class="pl-s1">message</span><span class="pl-pse"><span class="pl-s1">)</span></span>"<span class="pl-pds">"#</span></span>)
}
<span class="pl-c1">say</span>(<span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> Default parameters can be omitted when calling the function.</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">printParameters</span>(<span class="pl-en">requiredParameter</span> <span class="pl-smi">r</span>: <span class="pl-c1">Int</span>, <span class="pl-en">optionalParameter</span> <span class="pl-smi">o</span>: <span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">10</span>) {
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>The required parameter was <span class="pl-pse">\(</span><span class="pl-s1">r</span><span class="pl-pse"><span class="pl-s1">)</span></span> and the optional parameter was <span class="pl-pse">\(</span><span class="pl-s1">o</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>)
}
<span class="pl-c1">printParameters</span>(<span class="pl-c1">requiredParameter</span>: <span class="pl-c1">3</span>)
<span class="pl-c1">printParameters</span>(<span class="pl-c1">requiredParameter</span>: <span class="pl-c1">3</span>, <span class="pl-c1">optionalParameter</span>: <span class="pl-c1">6</span>)

<span class="pl-c"><span class="pl-c">//</span> Variadic args — only one set per function.</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">setup</span>(<span class="pl-smi"><span class="pl-en">numbers</span></span>: <span class="pl-c1">Int</span><span class="pl-k">...</span>) {
    <span class="pl-c"><span class="pl-c">//</span> it's an array</span>
<span class="pl-c"></span>    <span class="pl-k">let</span> <span class="pl-c1">_</span> <span class="pl-k">=</span> numbers[<span class="pl-c1">0</span>]
    <span class="pl-k">let</span> <span class="pl-c1">_</span> <span class="pl-k">=</span> numbers.<span class="pl-c1">count</span>
}

<span class="pl-c"><span class="pl-c">//</span> pass by ref</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">swapTwoInts</span>(<span class="pl-smi"><span class="pl-en">a</span></span>: <span class="pl-k">inout</span> <span class="pl-c1">Int</span>, <span class="pl-smi"><span class="pl-en">b</span></span>: <span class="pl-k">inout</span> <span class="pl-c1">Int</span>) {
    <span class="pl-k">let</span> tempA <span class="pl-k">=</span> a
    a <span class="pl-k">=</span> b
    b <span class="pl-k">=</span> tempA
}
<span class="pl-k">var</span> someIntA <span class="pl-k">=</span> <span class="pl-c1">7</span>
<span class="pl-k">var</span> someIntB <span class="pl-k">=</span> <span class="pl-c1">3</span>
<span class="pl-c1">swapTwoInts</span>(<span class="pl-c1">a</span>: <span class="pl-k">&amp;</span>someIntA, <span class="pl-c1">b</span>: <span class="pl-k">&amp;</span>someIntB) <span class="pl-c"><span class="pl-c">//</span>must be called with an &amp; before the variable name.</span>
<span class="pl-c"></span><span class="pl-c1">print</span>(someIntB) <span class="pl-c"><span class="pl-c">//</span> 7</span>
<span class="pl-c"></span>
<span class="pl-c1">type</span>(<span class="pl-c1">of</span>: greet) <span class="pl-c"><span class="pl-c">//</span> (String, String) -&gt; String</span>
<span class="pl-c"></span><span class="pl-c1">type</span>(<span class="pl-c1">of</span>: helloWorld) <span class="pl-c"><span class="pl-c">//</span> () -&gt; Void</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Passing and returning functions</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">makeIncrementer</span>() <span class="pl-k">-&gt;</span> ((<span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span>) {
    <span class="pl-k">func</span> <span class="pl-en">addOne</span>(<span class="pl-smi"><span class="pl-en">number</span></span>: <span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span> {
        <span class="pl-k">return</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> number
    }
    <span class="pl-k">return</span> addOne
}
<span class="pl-k">var</span> increment <span class="pl-k">=</span> <span class="pl-c1">makeIncrementer</span>()
<span class="pl-c1">increment</span>(<span class="pl-c1">7</span>)

<span class="pl-k">func</span> <span class="pl-en">performFunction</span>(<span class="pl-en">_</span> <span class="pl-smi">function</span>: (<span class="pl-c1">String</span>, <span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span>, <span class="pl-en">on</span> <span class="pl-smi">string1</span>: <span class="pl-c1">String</span>, <span class="pl-en">and</span> <span class="pl-smi">string2</span>: <span class="pl-c1">String</span>) {
    <span class="pl-k">let</span> result <span class="pl-k">=</span> <span class="pl-c1">function</span>(string1, string2)
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>The result of calling the function on <span class="pl-pse">\(</span><span class="pl-s1">string1</span><span class="pl-pse"><span class="pl-s1">)</span></span> and <span class="pl-pse">\(</span><span class="pl-s1">string2</span><span class="pl-pse"><span class="pl-s1">)</span></span> was <span class="pl-pse">\(</span><span class="pl-s1">result</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>)
}

<span class="pl-c"><span class="pl-c">//</span> Function that returns multiple items in a tuple</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">getGasPrices</span>() <span class="pl-k">-&gt;</span> (<span class="pl-c1">Double</span>, <span class="pl-c1">Double</span>, <span class="pl-c1">Double</span>) {
    <span class="pl-k">return</span> (<span class="pl-c1">3.59</span>, <span class="pl-c1">3.69</span>, <span class="pl-c1">3.79</span>)
}
<span class="pl-k">let</span> pricesTuple <span class="pl-k">=</span> <span class="pl-c1">getGasPrices</span>()
<span class="pl-k">let</span> price <span class="pl-k">=</span> pricesTuple.2 <span class="pl-c"><span class="pl-c">//</span> 3.79</span>
<span class="pl-c"><span class="pl-c">//</span> Ignore Tuple (or other) values by using _ (underscore)</span>
<span class="pl-c"></span><span class="pl-k">let</span> (<span class="pl-c1">_</span>, price1, <span class="pl-c1">_</span>) <span class="pl-k">=</span> pricesTuple <span class="pl-c"><span class="pl-c">//</span> price1 == 3.69</span>
<span class="pl-c"></span><span class="pl-c1">print</span>(price1 <span class="pl-k">==</span> pricesTuple.1) <span class="pl-c"><span class="pl-c">//</span> true</span>
<span class="pl-c"></span><span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Gas price: <span class="pl-pse">\(</span><span class="pl-s1">price</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> Labeled/named tuple params</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">getGasPrices2</span>() <span class="pl-k">-&gt;</span> (lowestPrice: <span class="pl-c1">Double</span>, highestPrice: <span class="pl-c1">Double</span>, midPrice: <span class="pl-c1">Double</span>) {
    <span class="pl-k">return</span> (<span class="pl-c1">1.77</span>, <span class="pl-c1">37.70</span>, <span class="pl-c1">7.37</span>)
}
<span class="pl-k">let</span> pricesTuple2 <span class="pl-k">=</span> <span class="pl-c1">getGasPrices2</span>()
<span class="pl-k">let</span> price2 <span class="pl-k">=</span> pricesTuple2.<span class="pl-smi">lowestPrice</span>
<span class="pl-k">let</span> (<span class="pl-c1">_</span>, price3, <span class="pl-c1">_</span>) <span class="pl-k">=</span> pricesTuple2
<span class="pl-c1">print</span>(pricesTuple2.<span class="pl-smi">highestPrice</span> <span class="pl-k">==</span> pricesTuple2.1) <span class="pl-c"><span class="pl-c">//</span> true</span>
<span class="pl-c"></span><span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Highest gas price: <span class="pl-pse">\(</span><span class="pl-s1">pricesTuple2.<span class="pl-smi">highestPrice</span></span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> guard statements</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">testGuard</span>() {
    <span class="pl-c"><span class="pl-c">//</span> guards provide early exits or breaks, placing the error handler code near the conditions.</span>
<span class="pl-c"></span>    <span class="pl-c"><span class="pl-c">//</span> it places variables it declares in the same scope as the guard statement.</span>
<span class="pl-c"></span>    <span class="pl-c"><span class="pl-c">//</span> They make it easier to avoid the "pyramid of doom"</span>
<span class="pl-c"></span>    <span class="pl-k">guard</span> <span class="pl-k">let</span> aNumber <span class="pl-k">=</span> <span class="pl-c1">Optional</span><span class="pl-k">&lt;</span><span class="pl-c1">Int</span><span class="pl-k">&gt;</span>(<span class="pl-c1">7</span>) <span class="pl-k">else</span> {
        <span class="pl-k">return</span> <span class="pl-c"><span class="pl-c">//</span> guard statements MUST exit the scope that they are in.</span>
<span class="pl-c"></span>        <span class="pl-c"><span class="pl-c">//</span> They generally use `return` or `throw`.</span>
<span class="pl-c"></span>    }

    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>number is <span class="pl-pse">\(</span><span class="pl-s1">aNumber</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>)
}
<span class="pl-c1">testGuard</span>()

<span class="pl-c"><span class="pl-c">//</span> Note that the print function is declared like so:</span>
<span class="pl-c"><span class="pl-c">//</span>     func print(_ input: Any..., separator: String = " ", terminator: String = "\n")</span>
<span class="pl-c"><span class="pl-c">//</span> To print without a newline:</span>
<span class="pl-c"></span><span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>No newline<span class="pl-pds">"</span></span>, <span class="pl-c1">terminator</span>: <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)
<span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>!<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> MARK: - Closures</span>
<span class="pl-c"></span>
<span class="pl-k">var</span> numbers <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">6</span>]

<span class="pl-c"><span class="pl-c">//</span> Functions are special case closures ({})</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Closure example.</span>
<span class="pl-c"><span class="pl-c">//</span> `-&gt;` separates the arguments and return type</span>
<span class="pl-c"><span class="pl-c">//</span> `in` separates the closure header from the closure body</span>
<span class="pl-c"></span>numbers.<span class="pl-c1">map</span>({
    (<span class="pl-c1">number</span>: <span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span> <span class="pl-k">in</span>
    <span class="pl-k">let</span> result <span class="pl-k">=</span> <span class="pl-c1">3</span> <span class="pl-k">*</span> number
    <span class="pl-k">return</span> result
})

<span class="pl-c"><span class="pl-c">//</span> When the type is known, like above, we can do this</span>
<span class="pl-c"></span>numbers <span class="pl-k">=</span> numbers.<span class="pl-c1">map</span>({ number <span class="pl-k">in</span> <span class="pl-c1">3</span> <span class="pl-k">*</span> number })
<span class="pl-c"><span class="pl-c">//</span> Or even this</span>
<span class="pl-c"><span class="pl-c">//</span>numbers = numbers.map({ $0 * 3 })</span>
<span class="pl-c"></span>
<span class="pl-c1">print</span>(numbers) <span class="pl-c"><span class="pl-c">//</span> [3, 6, 18]</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Trailing closure</span>
<span class="pl-c"></span>numbers <span class="pl-k">=</span> numbers.<span class="pl-c1">sorted</span> { <span class="pl-c1">$0</span> <span class="pl-k">&gt;</span> <span class="pl-c1">$1</span> }

<span class="pl-c1">print</span>(numbers) <span class="pl-c"><span class="pl-c">//</span> [18, 6, 3]</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> MARK: - Enums</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Enums can optionally be of a specific type or on their own.</span>
<span class="pl-c"><span class="pl-c">//</span> They can contain methods like classes.</span>
<span class="pl-c"></span>
<span class="pl-k">enum</span> <span class="pl-en">Suit</span> {
    <span class="pl-k">case</span> <span class="pl-c1">spades</span>, <span class="pl-c1">hearts</span>, <span class="pl-c1">diamonds</span>, <span class="pl-c1">clubs</span>
    <span class="pl-k">var</span> icon: <span class="pl-c1">Character</span> {
        <span class="pl-k">switch</span> <span class="pl-c1">self</span> {
        <span class="pl-k">case</span> .<span class="pl-smi">spades</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>♤<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">hearts</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>♡<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">diamonds</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>♢<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">clubs</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>♧<span class="pl-pds">"</span></span>
        }
    }
}

<span class="pl-c"><span class="pl-c">//</span> Enum values allow short hand syntax, no need to type the enum type</span>
<span class="pl-c"><span class="pl-c">//</span> when the variable is explicitly declared</span>
<span class="pl-c"></span><span class="pl-k">var</span> suitValue: Suit <span class="pl-k">=</span> .<span class="pl-smi">hearts</span>

<span class="pl-c"><span class="pl-c">//</span> Conforming to the CaseIterable protocol automatically synthesizes the allCases property,</span>
<span class="pl-c"><span class="pl-c">//</span>   which contains all the values. It works on enums without associated values or @available attributes.</span>
<span class="pl-c"></span><span class="pl-k">enum</span> <span class="pl-en">Rank</span>: <span class="pl-e">CaseIterable </span>{
    <span class="pl-k">case</span> <span class="pl-c1">ace</span>
    <span class="pl-k">case</span> <span class="pl-c1">two</span>, <span class="pl-c1">three</span>, <span class="pl-c1">four</span>, <span class="pl-c1">five</span>, <span class="pl-c1">six</span>, <span class="pl-c1">seven</span>, <span class="pl-c1">eight</span>, <span class="pl-c1">nine</span>, <span class="pl-c1">ten</span>
    <span class="pl-k">case</span> <span class="pl-c1">jack</span>, <span class="pl-c1">queen</span>, <span class="pl-c1">king</span>
    <span class="pl-k">var</span> icon: <span class="pl-c1">String</span> {
        <span class="pl-k">switch</span> <span class="pl-c1">self</span> {
        <span class="pl-k">case</span> .<span class="pl-smi">ace</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">two</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">three</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">four</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>4<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">five</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>5<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">six</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>6<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">seven</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>7<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">eight</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>8<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">nine</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>9<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">ten</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>10<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">jack</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>J<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">queen</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Q<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> .<span class="pl-smi">king</span><span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>K<span class="pl-pds">"</span></span>
        }
    }
}

<span class="pl-k">for</span> suit <span class="pl-k">in</span> [Suit.<span class="pl-smi">clubs</span>, .<span class="pl-smi">diamonds</span>, .<span class="pl-smi">hearts</span>, .<span class="pl-smi">spades</span>] {
    <span class="pl-k">for</span> rank <span class="pl-k">in</span> Rank.<span class="pl-smi">allCases</span> {
        <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">rank.<span class="pl-smi">icon</span></span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pse">\(</span><span class="pl-s1">suit.<span class="pl-smi">icon</span></span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>)
    }
}

<span class="pl-c"><span class="pl-c">//</span> String enums can have direct raw value assignments</span>
<span class="pl-c"><span class="pl-c">//</span> or their raw values will be derived from the Enum field</span>
<span class="pl-c"></span><span class="pl-k">enum</span> <span class="pl-en">BookName</span>: <span class="pl-e"><span class="pl-c1">String</span> </span>{
    <span class="pl-k">case</span> <span class="pl-c1">john</span>
    <span class="pl-k">case</span> <span class="pl-c1">luke</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Luke<span class="pl-pds">"</span></span>
}
<span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Name: <span class="pl-pse">\(</span><span class="pl-s1">BookName.<span class="pl-smi">john</span>.<span class="pl-c1">rawValue</span></span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> Enum with associated Values</span>
<span class="pl-c"></span><span class="pl-k">enum</span> <span class="pl-en">Furniture</span> {
    <span class="pl-c"><span class="pl-c">//</span> Associate with Int</span>
<span class="pl-c"></span>    <span class="pl-k">case</span> <span class="pl-c1">desk</span>(<span class="pl-en"><span class="pl-smi">height</span></span>: <span class="pl-c1">Int</span>)
    <span class="pl-c"><span class="pl-c">//</span> Associate with String and Int</span>
<span class="pl-c"></span>    <span class="pl-k">case</span> <span class="pl-c1">chair</span>(<span class="pl-c1">String</span>, <span class="pl-c1">Int</span>)

    <span class="pl-k">func</span> <span class="pl-en">description</span>() <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span> {
        <span class="pl-c"><span class="pl-c">//</span>either placement of let is acceptable</span>
<span class="pl-c"></span>        <span class="pl-k">switch</span> <span class="pl-c1">self</span> {
        <span class="pl-k">case</span> .<span class="pl-c1">desk</span>(<span class="pl-k">let</span> height)<span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Desk with <span class="pl-pse">\(</span><span class="pl-s1">height</span><span class="pl-pse"><span class="pl-s1">)</span></span> cm<span class="pl-pds">"</span></span>
        <span class="pl-k">case</span> <span class="pl-k">let</span> .<span class="pl-c1">chair</span>(brand, height)<span class="pl-k">:</span>
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Chair of <span class="pl-pse">\(</span><span class="pl-s1">brand</span><span class="pl-pse"><span class="pl-s1">)</span></span> with <span class="pl-pse">\(</span><span class="pl-s1">height</span><span class="pl-pse"><span class="pl-s1">)</span></span> cm<span class="pl-pds">"</span></span>
        }
    }
}

<span class="pl-k">var</span> desk: Furniture <span class="pl-k">=</span> .<span class="pl-c1">desk</span>(<span class="pl-c1">height</span>: <span class="pl-c1">80</span>)
<span class="pl-c1">print</span>(desk.<span class="pl-c1">description</span>())     <span class="pl-c"><span class="pl-c">//</span> "Desk with 80 cm"</span>
<span class="pl-c"></span><span class="pl-k">var</span> chair <span class="pl-k">=</span> Furniture.<span class="pl-c1">chair</span>(<span class="pl-s"><span class="pl-pds">"</span>Foo<span class="pl-pds">"</span></span>, <span class="pl-c1">40</span>)
<span class="pl-c1">print</span>(chair.<span class="pl-c1">description</span>())    <span class="pl-c"><span class="pl-c">//</span> "Chair of Foo with 40 cm"</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> MARK: - Structures &amp; Classes</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"> Structures and classes in Swift have many things in common. Both can:</span>
<span class="pl-c"> - Define properties to store values</span>
<span class="pl-c"> - Define methods to provide functionality</span>
<span class="pl-c"> - Define subscripts to provide access to their values using subscript syntax</span>
<span class="pl-c"> - Define initializers to set up their initial state</span>
<span class="pl-c"> - Be extended to expand their functionality beyond a default implementation</span>
<span class="pl-c"> - Conform to protocols to provide standard functionality of a certain kind</span>
<span class="pl-c"></span>
<span class="pl-c"> Classes have additional capabilities that structures don't have:</span>
<span class="pl-c"> - Inheritance enables one class to inherit the characteristics of another.</span>
<span class="pl-c"> - Type casting enables you to check and interpret the type of a class instance at runtime.</span>
<span class="pl-c"> - Deinitializers enable an instance of a class to free up any resources it has assigned.</span>
<span class="pl-c"> - Reference counting allows more than one reference to a class instance.</span>
<span class="pl-c"></span>
<span class="pl-c"> Unless you need to use a class for one of these reasons, use a struct.</span>
<span class="pl-c"></span>
<span class="pl-c"> Structures are value types, while classes are reference types.</span>
<span class="pl-c"> <span class="pl-c">*/</span></span>

<span class="pl-c"><span class="pl-c">//</span> MARK: Structures</span>
<span class="pl-c"></span>
<span class="pl-k">struct</span> <span class="pl-en">NamesTable</span> {
    <span class="pl-k">let</span> names: [<span class="pl-c1">String</span>]

    <span class="pl-c"><span class="pl-c">//</span> Custom subscript</span>
<span class="pl-c"></span>    <span class="pl-k">subscript</span>(<span class="pl-c1">index</span>: <span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span> {
        <span class="pl-k">return</span> names[index]
    }
}

<span class="pl-c"><span class="pl-c">//</span> Structures have an auto-generated (implicit) designated "memberwise" initializer</span>
<span class="pl-c"></span><span class="pl-k">let</span> namesTable <span class="pl-k">=</span> <span class="pl-c1">NamesTable</span>(<span class="pl-c1">names</span>: [<span class="pl-s"><span class="pl-pds">"</span>Me<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Them<span class="pl-pds">"</span></span>])
<span class="pl-k">let</span> name <span class="pl-k">=</span> namesTable[<span class="pl-c1">1</span>]
<span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Name is <span class="pl-pse">\(</span><span class="pl-s1">name</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> Name is Them</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> MARK: Classes</span>
<span class="pl-c"></span>
<span class="pl-k">class</span> <span class="pl-en">Shape</span> {
    <span class="pl-k">func</span> <span class="pl-en">getArea</span>() <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span> {
        <span class="pl-k">return</span> <span class="pl-c1">0</span>
    }
}

<span class="pl-k">class</span> <span class="pl-en">Rect</span>: <span class="pl-e">Shape </span>{
    <span class="pl-k">var</span> sideLength: <span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>

    <span class="pl-c"><span class="pl-c">//</span> Custom getter and setter property</span>
<span class="pl-c"></span>    <span class="pl-k">var</span> perimeter: <span class="pl-c1">Int</span> {
        <span class="pl-k">get</span> {
            <span class="pl-k">return</span> <span class="pl-c1">4</span> <span class="pl-k">*</span> sideLength
        }
        <span class="pl-k">set</span> {
            <span class="pl-c"><span class="pl-c">//</span> `newValue` is an implicit variable available to setters</span>
<span class="pl-c"></span>            sideLength <span class="pl-k">=</span> newValue <span class="pl-k">/</span> <span class="pl-c1">4</span>
        }
    }

    <span class="pl-c"><span class="pl-c">//</span> Computed properties must be declared as `var`, you know, cause' they can change</span>
<span class="pl-c"></span>    <span class="pl-k">var</span> smallestSideLength: <span class="pl-c1">Int</span> {
        <span class="pl-k">return</span> <span class="pl-c1">self</span>.<span class="pl-smi">sideLength</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>
    }

    <span class="pl-c"><span class="pl-c">//</span> Lazily load a property</span>
<span class="pl-c"></span>    <span class="pl-c"><span class="pl-c">//</span> subShape remains nil (uninitialized) until getter called</span>
<span class="pl-c"></span>    <span class="pl-k">lazy</span> <span class="pl-k">var</span> subShape <span class="pl-k">=</span> <span class="pl-c1">Rect</span>(<span class="pl-c1">sideLength</span>: <span class="pl-c1">4</span>)

    <span class="pl-c"><span class="pl-c">//</span> If you don't need a custom getter and setter,</span>
<span class="pl-c"></span>    <span class="pl-c"><span class="pl-c">//</span> but still want to run code before and after getting or setting</span>
<span class="pl-c"></span>    <span class="pl-c"><span class="pl-c">//</span> a property, you can use `willSet` and `didSet`</span>
<span class="pl-c"></span>    <span class="pl-k">var</span> identifier: <span class="pl-c1">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>defaultID<span class="pl-pds">"</span></span> {
        <span class="pl-c"><span class="pl-c">//</span> the `someIdentifier` arg will be the variable name for the new value</span>
<span class="pl-c"></span>        <span class="pl-k">willSet</span>(someIdentifier) {
            <span class="pl-c1">print</span>(someIdentifier)
        }
    }

    <span class="pl-k">init</span>(<span class="pl-smi"><span class="pl-en">sideLength</span></span>: <span class="pl-c1">Int</span>) {
        <span class="pl-c1">self</span>.<span class="pl-smi">sideLength</span> <span class="pl-k">=</span> sideLength
        <span class="pl-c"><span class="pl-c">//</span> always super.init last when init custom properties</span>
<span class="pl-c"></span>        <span class="pl-c1">super</span>.<span class="pl-k">init</span>()
    }

    <span class="pl-k">func</span> <span class="pl-en">shrink</span>() {
        <span class="pl-k">if</span> sideLength <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> {
            sideLength <span class="pl-k">-=</span> <span class="pl-c1">1</span>
        }
    }

    <span class="pl-k">override</span> <span class="pl-k">func</span> <span class="pl-en">getArea</span>() <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span> {
        <span class="pl-k">return</span> sideLength <span class="pl-k">*</span> sideLength
    }
}

<span class="pl-c"><span class="pl-c">//</span> A simple class `Square` extends `Rect`</span>
<span class="pl-c"></span><span class="pl-k">class</span> <span class="pl-en">Square</span>: <span class="pl-e">Rect </span>{
    <span class="pl-k">convenience</span> <span class="pl-k">init</span>() {
        <span class="pl-c1">self</span>.<span class="pl-k">init</span>(<span class="pl-c1">sideLength</span>: <span class="pl-c1">5</span>)
    }
}

<span class="pl-k">var</span> mySquare <span class="pl-k">=</span> <span class="pl-c1">Square</span>()
<span class="pl-c1">print</span>(mySquare.<span class="pl-c1">getArea</span>()) <span class="pl-c"><span class="pl-c">//</span> 25</span>
<span class="pl-c"></span>mySquare.<span class="pl-c1">shrink</span>()
<span class="pl-c1">print</span>(mySquare.<span class="pl-smi">sideLength</span>) <span class="pl-c"><span class="pl-c">//</span> 4</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> cast instance</span>
<span class="pl-c"></span><span class="pl-k">let</span> aShape <span class="pl-k">=</span> mySquare <span class="pl-k">as</span> Shape

<span class="pl-c"><span class="pl-c">//</span> downcast instance: </span>
<span class="pl-c"><span class="pl-c">//</span> Because downcasting can fail, the result can be an optional (as?) or an implicitly unwrpped optional (as!).  </span>
<span class="pl-c"></span><span class="pl-k">let</span> anOptionalSquare <span class="pl-k">=</span> aShape <span class="pl-k">as?</span> Square <span class="pl-c"><span class="pl-c">//</span> This will return nil if aShape is not a Square</span>
<span class="pl-c"></span><span class="pl-k">let</span> aSquare <span class="pl-k">=</span> aShape <span class="pl-k">as!</span> Square <span class="pl-c"><span class="pl-c">//</span> This will throw a runtime error if aShape is not a Square</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> compare instances, not the same as == which compares objects (equal to)</span>
<span class="pl-c"></span><span class="pl-k">if</span> mySquare <span class="pl-k">===</span> mySquare {
    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Yep, it's mySquare<span class="pl-pds">"</span></span>)
}

<span class="pl-c"><span class="pl-c">//</span> Optional init</span>
<span class="pl-c"></span><span class="pl-k">class</span> <span class="pl-en">Circle</span>: <span class="pl-e">Shape </span>{
    <span class="pl-k">var</span> radius: <span class="pl-c1">Int</span>
    <span class="pl-k">override</span> <span class="pl-k">func</span> <span class="pl-en">getArea</span>() <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span> {
        <span class="pl-k">return</span> <span class="pl-c1">3</span> <span class="pl-k">*</span> radius <span class="pl-k">*</span> radius
    }

    <span class="pl-c"><span class="pl-c">//</span> Place a question mark postfix after `init` is an optional init</span>
<span class="pl-c"></span>    <span class="pl-c"><span class="pl-c">//</span> which can return nil</span>
<span class="pl-c"></span>    <span class="pl-k">init?</span>(<span class="pl-smi"><span class="pl-en">radius</span></span>: <span class="pl-c1">Int</span>) {
        <span class="pl-c1">self</span>.<span class="pl-smi">radius</span> <span class="pl-k">=</span> radius
        <span class="pl-c1">super</span>.<span class="pl-k">init</span>()

        <span class="pl-k">if</span> radius <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span> {
            <span class="pl-k">return</span> <span class="pl-c1">nil</span>
        }
    }
}

<span class="pl-k">var</span> myCircle <span class="pl-k">=</span> <span class="pl-c1">Circle</span>(<span class="pl-c1">radius</span>: <span class="pl-c1">1</span>)
<span class="pl-c1">print</span>(myCircle<span class="pl-k">?</span>.<span class="pl-c1">getArea</span>())    <span class="pl-c"><span class="pl-c">//</span> Optional(3)</span>
<span class="pl-c"></span><span class="pl-c1">print</span>(myCircle<span class="pl-k">!</span>.<span class="pl-c1">getArea</span>())    <span class="pl-c"><span class="pl-c">//</span> 3</span>
<span class="pl-c"></span><span class="pl-k">var</span> myEmptyCircle <span class="pl-k">=</span> <span class="pl-c1">Circle</span>(<span class="pl-c1">radius</span>: <span class="pl-c1">-1</span>)
<span class="pl-c1">print</span>(myEmptyCircle<span class="pl-k">?</span>.<span class="pl-c1">getArea</span>())    <span class="pl-c"><span class="pl-c">//</span> "nil"</span>
<span class="pl-c"></span><span class="pl-k">if</span> <span class="pl-k">let</span> circle <span class="pl-k">=</span> myEmptyCircle {
    <span class="pl-c"><span class="pl-c">//</span> will not execute since myEmptyCircle is nil</span>
<span class="pl-c"></span>    <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>circle is not nil<span class="pl-pds">"</span></span>)
}

<span class="pl-c"><span class="pl-c">//</span> MARK: - Protocols</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> protocols are also known as interfaces in some other languages</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> `protocol`s can require that conforming types have specific</span>
<span class="pl-c"><span class="pl-c">//</span> instance properties, instance methods, type methods,</span>
<span class="pl-c"><span class="pl-c">//</span> operators, and subscripts.</span>
<span class="pl-c"></span>
<span class="pl-k">protocol</span> <span class="pl-en">ShapeGenerator</span> {
    <span class="pl-k">var</span> enabled: <span class="pl-c1">Bool</span> { <span class="pl-k">get</span> <span class="pl-k">set</span> }
    <span class="pl-k">func</span> <span class="pl-en">buildShape</span>() <span class="pl-k">-&gt;</span> Shape
}

<span class="pl-c"><span class="pl-c">//</span> MARK: - Other</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> MARK: Typealiases</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Typealiases allow one type (or composition of types) to be referred to by another name</span>
<span class="pl-c"></span><span class="pl-k">typealias</span> <span class="pl-en">Integer</span> <span class="pl-k">=</span> <span class="pl-c1">Int</span>
<span class="pl-k">let</span> myInteger: <span class="pl-c1">Integer</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>

<span class="pl-c"><span class="pl-c">//</span> MARK: = Operator</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Assignment does not return a value. This means it can't be used in conditional statements,</span>
<span class="pl-c"><span class="pl-c">//</span>   and the following statement is also illegal</span>
<span class="pl-c"><span class="pl-c">//</span>    let multipleAssignment = theQuestion = "No questions asked"</span>
<span class="pl-c"><span class="pl-c">//</span>But you can do this:</span>
<span class="pl-c"></span><span class="pl-k">let</span> multipleAssignment <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>No questions asked<span class="pl-pds">"</span></span>, secondConstant <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>No answers given<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">//</span> MARK: Ranges</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> The ..&lt; and ... operators create ranges.</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> ... is inclusive on both ends (a "closed range") — mathematically, [0, 10]</span>
<span class="pl-c"></span><span class="pl-k">let</span> _0to10 <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">...</span><span class="pl-c1">10</span>
<span class="pl-c"><span class="pl-c">//</span> ..&lt; is inclusive on the left, exclusive on the right (a "range") — mathematically, [0, 10)</span>
<span class="pl-c"></span><span class="pl-k">let</span> singleDigitNumbers <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">..&lt;</span><span class="pl-c1">10</span>
<span class="pl-c"><span class="pl-c">//</span> You can omit one end (a "PartialRangeFrom") — mathematically, [0, ∞)</span>
<span class="pl-c"></span><span class="pl-k">let</span> toInfinityAndBeyond <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">...</span>
<span class="pl-c"><span class="pl-c">//</span> Or the other end (a "PartialRangeTo") — mathematically, (-∞, 0)</span>
<span class="pl-c"></span><span class="pl-k">let</span> negativeInfinityToZero <span class="pl-k">=</span> <span class="pl-k">..&lt;</span><span class="pl-c1">0</span>
<span class="pl-c"><span class="pl-c">//</span> (a "PartialRangeThrough") — mathematically, (-∞, 0]</span>
<span class="pl-c"></span><span class="pl-k">let</span> negativeInfinityThroughZero <span class="pl-k">=</span> <span class="pl-k">...</span><span class="pl-c1">0</span>

<span class="pl-c"><span class="pl-c">//</span> MARK: Wildcard operator</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> In Swift, _ (underscore) is the wildcard operator, which allows values to be ignored</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> It allows functions to be declared without argument labels:</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">function</span>(<span class="pl-en">_</span> <span class="pl-smi">labelLessParameter</span>: <span class="pl-c1">Int</span>, <span class="pl-en">label</span> <span class="pl-smi">labeledParameter</span>: <span class="pl-c1">Int</span>, <span class="pl-smi"><span class="pl-en">labelAndParameterName</span></span>: <span class="pl-c1">Int</span>) {
    <span class="pl-c1">print</span>(labelLessParameter, labeledParameter, labelAndParameterName)
}
<span class="pl-c1">function</span>(<span class="pl-c1">0</span>, <span class="pl-c1">label</span>: <span class="pl-c1">0</span>, <span class="pl-c1">labelAndParameterName</span>: <span class="pl-c1">0</span>)

<span class="pl-c"><span class="pl-c">//</span> You can ignore the return values of functions</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">printAndReturn</span>(<span class="pl-en">_</span> <span class="pl-smi">str</span>: <span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span> {
    <span class="pl-c1">print</span>(str)
    <span class="pl-k">return</span> str
}
<span class="pl-k">let</span> <span class="pl-c1">_</span> <span class="pl-k">=</span> <span class="pl-c1">printAndReturn</span>(<span class="pl-s"><span class="pl-pds">"</span>Some String<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> You can ignore part of a tuple and keep part of it</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">returnsTuple</span>() <span class="pl-k">-&gt;</span> (<span class="pl-c1">Int</span>, <span class="pl-c1">Int</span>) {
    <span class="pl-k">return</span> (<span class="pl-c1">1</span>, <span class="pl-c1">2</span>)
}
<span class="pl-k">let</span> (<span class="pl-c1">_</span>, two) <span class="pl-k">=</span> <span class="pl-c1">returnsTuple</span>()

<span class="pl-c"><span class="pl-c">//</span> You can ignore closure parameters</span>
<span class="pl-c"></span><span class="pl-k">let</span> closure: (<span class="pl-c1">Int</span>, <span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span> <span class="pl-k">=</span> { someInt, <span class="pl-c1">_</span> <span class="pl-k">in</span>
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">someInt</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>
}
<span class="pl-c1">closure</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">//</span> returns 1</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> You can ignore the value in a for loop</span>
<span class="pl-c"></span><span class="pl-k">for</span> <span class="pl-c1">_</span> <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">..&lt;</span><span class="pl-c1">10</span> {
    <span class="pl-c"><span class="pl-c">//</span> Code to execute 10 times</span>
<span class="pl-c"></span>}

<span class="pl-c"><span class="pl-c">//</span> MARK: Access Control</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"> Swift has five levels of access control:</span>
<span class="pl-c"> - Open: Accessible *and subclassible* in any module that imports it.</span>
<span class="pl-c"> - Public: Accessible in any module that imports it, subclassible in the module it is declared in.</span>
<span class="pl-c"> - Internal: Accessible and subclassible in the module it is declared in.</span>
<span class="pl-c"> - Fileprivate: Accessible and subclassible in the file it is declared in.</span>
<span class="pl-c"> - Private: Accessible and subclassible in the enclosing declaration (think inner classes/structs/enums)</span>
<span class="pl-c"></span>
<span class="pl-c"> See more here: https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html</span>
<span class="pl-c"> <span class="pl-c">*/</span></span>

<span class="pl-c"><span class="pl-c">//</span> MARK: Preventing Overrides</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> You can add keyword `final` before a class or instance method, or a property to prevent it from being overridden</span>
<span class="pl-c"></span><span class="pl-k">class</span> <span class="pl-en">Shape</span> {
    <span class="pl-k">final</span> <span class="pl-k">var</span> finalInteger <span class="pl-k">=</span> <span class="pl-c1">10</span>
}

<span class="pl-c"><span class="pl-c">//</span> Prevent a class from being subclassed</span>
<span class="pl-c"></span><span class="pl-k">final</span> <span class="pl-k">class</span> <span class="pl-en">ViewManager</span> {
}

<span class="pl-c"><span class="pl-c">//</span> MARK: Conditional Compilation, Compile-Time Diagnostics, &amp; Availability Conditions</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Conditional Compilation</span>
<span class="pl-c"></span>#<span class="pl-k">if</span> <span class="pl-c1">false</span><span class="pl-c"></span>
<span class="pl-c">print("This code will not be compiled")</span>
<span class="pl-c"></span>#<span class="pl-k">else</span>
<span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>This code will be compiled<span class="pl-pds">"</span></span>)
#<span class="pl-k">endif</span>
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"> Options are:</span>
<span class="pl-c"> os()                   macOS, iOS, watchOS, tvOS, Linux</span>
<span class="pl-c"> arch()                 i386, x86_64, arm, arm64</span>
<span class="pl-c"> swift()                &gt;= or &lt; followed by a version number</span>
<span class="pl-c"> compiler()             &gt;= or &lt; followed by a version number</span>
<span class="pl-c"> canImport()            A module name</span>
<span class="pl-c"> targetEnvironment()    simulator</span>
<span class="pl-c"> <span class="pl-c">*/</span></span>
#<span class="pl-k">if</span> <span class="pl-k">swift</span>(<span class="pl-k">&lt;</span><span class="pl-c1">3</span>)
<span class="pl-c1">println</span>()
#<span class="pl-k">endif</span>

<span class="pl-c"><span class="pl-c">//</span> Compile-Time Diagnostics</span>
<span class="pl-c"><span class="pl-c">//</span> You can use #warning(message) and #error(message) to have the compiler emit warnings and/or errors</span>
<span class="pl-c"></span>#<span class="pl-c1">warning</span>(<span class="pl-s"><span class="pl-pds">"</span>This will be a compile-time warning<span class="pl-pds">"</span></span>)
<span class="pl-c"><span class="pl-c">//</span>  #error("This would be a compile-time error")</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span>Availability Conditions</span>
<span class="pl-c"></span><span class="pl-k">if</span> <span class="pl-c1">#available</span>(<span class="pl-ii">iOSMac</span> <span class="pl-ii">10.15</span>, <span class="pl-k">*</span>) {
    <span class="pl-c"><span class="pl-c">//</span> macOS 10.15 is available, you can use it here</span>
<span class="pl-c"></span>} <span class="pl-k">else</span> {
    <span class="pl-c"><span class="pl-c">//</span> macOS 10.15 is not available, use alternate APIs</span>
<span class="pl-c"></span>}

<span class="pl-c"><span class="pl-c">//</span> MARK: Any and AnyObject</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Swift has support for storing a value of any type.</span>
<span class="pl-c"><span class="pl-c">//</span> For that purpose there are two keywords: `Any` and `AnyObject`</span>
<span class="pl-c"><span class="pl-c">//</span> `AnyObject` == `id` from Objective-C</span>
<span class="pl-c"><span class="pl-c">//</span> `Any` works with any values (class, Int, struct, etc.)</span>
<span class="pl-c"></span><span class="pl-k">var</span> anyVar: <span class="pl-c1">Any</span> <span class="pl-k">=</span> <span class="pl-c1">7</span>
anyVar <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Changed value to a string, not good practice, but possible.<span class="pl-pds">"</span></span>
<span class="pl-k">let</span> anyObjectVar: <span class="pl-c1">AnyObject</span> <span class="pl-k">=</span> <span class="pl-c1">Int</span>(<span class="pl-c1">1</span>) <span class="pl-k">as</span> NSNumber

<span class="pl-c"><span class="pl-c">//</span> MARK: Extensions</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Extensions allow you to add extra functionality to an already-declared type, even one that you don't have the source code for.</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Square now "conforms" to the `CustomStringConvertible` protocol</span>
<span class="pl-c"></span><span class="pl-k">extension</span> <span class="pl-en">Square</span>: <span class="pl-e"><span class="pl-c1">CustomStringConvertible</span> </span>{
    <span class="pl-k">var</span> description: <span class="pl-c1">String</span> {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Area: <span class="pl-pse">\(</span><span class="pl-s1"><span class="pl-c1">self</span>.<span class="pl-c1">getArea</span>()</span><span class="pl-pse"><span class="pl-s1">)</span></span> - ID: <span class="pl-pse">\(</span><span class="pl-s1"><span class="pl-c1">self</span>.<span class="pl-smi">identifier</span></span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>
    }
}

<span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Square: <span class="pl-pse">\(</span><span class="pl-s1">mySquare</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> You can also extend built-in types</span>
<span class="pl-c"></span><span class="pl-k">extension</span> <span class="pl-en"><span class="pl-c1">Int</span></span> {
    <span class="pl-k">var</span> doubled: <span class="pl-c1">Int</span> {
        <span class="pl-k">return</span> <span class="pl-c1">self</span> <span class="pl-k">*</span> <span class="pl-c1">2</span>
    }

    <span class="pl-k">func</span> <span class="pl-en">multipliedBy</span>(<span class="pl-smi"><span class="pl-en">num</span></span>: <span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span> {
        <span class="pl-k">return</span> num <span class="pl-k">*</span> <span class="pl-c1">self</span>
    }

    <span class="pl-k">mutating</span> <span class="pl-k">func</span> <span class="pl-en">multiplyBy</span>(<span class="pl-smi"><span class="pl-en">num</span></span>: <span class="pl-c1">Int</span>) {
        <span class="pl-c1">self</span> <span class="pl-k">*=</span> num
    }
}

<span class="pl-c1">print</span>(<span class="pl-c1">7</span>.<span class="pl-smi">doubled</span>) <span class="pl-c"><span class="pl-c">//</span> 14</span>
<span class="pl-c"></span><span class="pl-c1">print</span>(<span class="pl-c1">7</span>.<span class="pl-smi">doubled</span>.<span class="pl-c1">multipliedBy</span>(<span class="pl-c1">num</span>: <span class="pl-c1">3</span>)) <span class="pl-c"><span class="pl-c">//</span> 42</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> MARK: Generics</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Generics: Similar to Java and C#. Use the `where` keyword to specify the</span>
<span class="pl-c"><span class="pl-c">//</span>   requirements of the generics.</span>
<span class="pl-c"></span>
<span class="pl-k">func</span> <span class="pl-en">findIndex</span>&lt;<span class="pl-c1">T</span>: <span class="pl-e"><span class="pl-c1">Equatable</span></span>&gt;(<span class="pl-smi"><span class="pl-en">array</span></span>: [T], <span class="pl-smi"><span class="pl-en">valueToFind</span></span>: T) <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span><span class="pl-k">?</span> {
    <span class="pl-k">for</span> (index, value) <span class="pl-k">in</span> array.<span class="pl-c1">enumerated</span>() {
        <span class="pl-k">if</span> value <span class="pl-k">==</span> valueToFind {
            <span class="pl-k">return</span> index
        }
    }
    <span class="pl-k">return</span> <span class="pl-c1">nil</span>
}
<span class="pl-c1">findIndex</span>(<span class="pl-c1">array</span>: [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>], <span class="pl-c1">valueToFind</span>: <span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">//</span> Optional(2)</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> You can extend types with generics as well</span>
<span class="pl-c"></span><span class="pl-k">extension</span> <span class="pl-en"><span class="pl-c1">Array</span></span> <span class="pl-k">where</span> <span class="pl-c1">Array</span>.<span class="pl-c1">Element</span> <span class="pl-k">==</span> <span class="pl-c1">Int</span> {
    <span class="pl-k">var</span> sum: <span class="pl-c1">Int</span> {
        <span class="pl-k">var</span> total <span class="pl-k">=</span> <span class="pl-c1">0</span>
        <span class="pl-k">for</span> el <span class="pl-k">in</span> <span class="pl-c1">self</span> {
            total <span class="pl-k">+=</span> el
        }
        <span class="pl-k">return</span> total
    }
}

<span class="pl-c"><span class="pl-c">//</span> MARK: Operators</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Custom operators can start with the characters:</span>
<span class="pl-c"><span class="pl-c">//</span>      / = - + * % &lt; &gt; ! &amp; | ^ . ~</span>
<span class="pl-c"><span class="pl-c">//</span> or</span>
<span class="pl-c"><span class="pl-c">//</span> Unicode math, symbol, arrow, dingbat, and line/box drawing characters.</span>
<span class="pl-c"></span><span class="pl-k">prefix</span> <span class="pl-k">operator</span> <span class="pl-en">!!!</span>

<span class="pl-c"><span class="pl-c">//</span> A prefix operator that triples the side length when used</span>
<span class="pl-c"></span><span class="pl-k">prefix</span> <span class="pl-k">func</span> <span class="pl-en">!!!</span> (<span class="pl-smi"><span class="pl-en">shape</span></span>: <span class="pl-k">inout</span> Square) <span class="pl-k">-&gt;</span> Square {
    shape.<span class="pl-smi">sideLength</span> <span class="pl-k">*=</span> <span class="pl-c1">3</span>
    <span class="pl-k">return</span> shape
}

<span class="pl-c"><span class="pl-c">//</span> current value</span>
<span class="pl-c"></span><span class="pl-c1">print</span>(mySquare.<span class="pl-smi">sideLength</span>) <span class="pl-c"><span class="pl-c">//</span> 4</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> change side length using custom !!! operator, increases size by 3</span>
<span class="pl-c"></span><span class="pl-k">!!!</span>mySquare
<span class="pl-c1">print</span>(mySquare.<span class="pl-smi">sideLength</span>) <span class="pl-c"><span class="pl-c">//</span> 12</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> Operators can also be generics</span>
<span class="pl-c"></span><span class="pl-k">infix</span> <span class="pl-k">operator</span> <span class="pl-en">&lt;-&gt;</span>
<span class="pl-k">func</span> <span class="pl-en">&lt;-&gt;</span>&lt;<span class="pl-c1">T</span>: <span class="pl-e"><span class="pl-c1">Equatable</span></span>&gt; (<span class="pl-smi"><span class="pl-en">a</span></span>: <span class="pl-k">inout</span> T, <span class="pl-smi"><span class="pl-en">b</span></span>: <span class="pl-k">inout</span> T) {
    <span class="pl-k">let</span> c <span class="pl-k">=</span> a
    a <span class="pl-k">=</span> b
    b <span class="pl-k">=</span> c
}

<span class="pl-k">var</span> foo: <span class="pl-c1">Float</span> <span class="pl-k">=</span> <span class="pl-c1">10</span>
<span class="pl-k">var</span> bar: <span class="pl-c1">Float</span> <span class="pl-k">=</span> <span class="pl-c1">20</span>

foo <span class="pl-k">&lt;-&gt;</span> bar
<span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>foo is <span class="pl-pse">\(</span><span class="pl-s1">foo</span><span class="pl-pse"><span class="pl-s1">)</span></span>, bar is <span class="pl-pse">\(</span><span class="pl-s1">bar</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> "foo is 20.0, bar is 10.0"</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> MARK: - Error Handling</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">//</span> The `Error` protocol is used when throwing errors to catch</span>
<span class="pl-c"></span><span class="pl-k">enum</span> <span class="pl-en">MyError</span>: <span class="pl-e"><span class="pl-c1">Error</span> </span>{
    <span class="pl-k">case</span> <span class="pl-c1">badValue</span>(<span class="pl-en"><span class="pl-smi">msg</span></span>: <span class="pl-c1">String</span>)
    <span class="pl-k">case</span> <span class="pl-c1">reallyBadValue</span>(<span class="pl-en"><span class="pl-smi">msg</span></span>: <span class="pl-c1">String</span>)
}

<span class="pl-c"><span class="pl-c">//</span> functions marked with `throws` must be called using `try`</span>
<span class="pl-c"></span><span class="pl-k">func</span> <span class="pl-en">fakeFetch</span>(<span class="pl-smi"><span class="pl-en">value</span></span>: <span class="pl-c1">Int</span>) <span class="pl-k">throws</span> <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span> {
    <span class="pl-k">guard</span> <span class="pl-c1">7</span> <span class="pl-k">==</span> value <span class="pl-k">else</span> {
        <span class="pl-k">throw</span> MyError.<span class="pl-c1">reallyBadValue</span>(<span class="pl-c1">msg</span>: <span class="pl-s"><span class="pl-pds">"</span>Some really bad value<span class="pl-pds">"</span></span>)
    }

    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span>
}

<span class="pl-k">func</span> <span class="pl-en">testTryStuff</span>() {
    <span class="pl-c"><span class="pl-c">//</span> assumes there will be no error thrown, otherwise a runtime exception is raised</span>
<span class="pl-c"></span>    <span class="pl-k">let</span> <span class="pl-c1">_</span> <span class="pl-k">=</span> <span class="pl-k">try</span><span class="pl-k">!</span> <span class="pl-c1">fakeFetch</span>(<span class="pl-c1">value</span>: <span class="pl-c1">7</span>)

    <span class="pl-c"><span class="pl-c">//</span> if an error is thrown, then it proceeds, but if the value is nil</span>
<span class="pl-c"></span>    <span class="pl-c"><span class="pl-c">//</span> it also wraps every return value in an optional, even if its already optional</span>
<span class="pl-c"></span>    <span class="pl-k">let</span> <span class="pl-c1">_</span> <span class="pl-k">=</span> <span class="pl-k">try</span><span class="pl-k">?</span> <span class="pl-c1">fakeFetch</span>(<span class="pl-c1">value</span>: <span class="pl-c1">7</span>)

    <span class="pl-k">do</span> {
        <span class="pl-c"><span class="pl-c">//</span> normal try operation that provides error handling via `catch` block</span>
<span class="pl-c"></span>        <span class="pl-k">try</span> <span class="pl-c1">fakeFetch</span>(<span class="pl-c1">value</span>: <span class="pl-c1">1</span>)
    } <span class="pl-k">catch</span> MyError.<span class="pl-c1">badValue</span>(<span class="pl-k">let</span> msg) {
        <span class="pl-c1">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Error message: <span class="pl-pse">\(</span><span class="pl-s1">msg</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>)
    } <span class="pl-k">catch</span> {
        <span class="pl-c"><span class="pl-c">//</span> must be exhaustive</span>
<span class="pl-c"></span>    }
}
<span class="pl-c1">testTryStuff</span>()</pre></div>
<hr>
<h2>Contributors</h2>
<ul>
<li>["Grant Timmerman", "http://github.com/grant"]</li>
<li>["Christopher Bess", "http://github.com/cbess"]</li>
<li>["Joey Huang", "http://github.com/kamidox"]</li>
<li>["Anthony Nguyen", "http://github.com/anthonyn60"]</li>
<li>["Clayton Walker", "https://github.com/cwalk"]</li>
<li>["Fernando Valverde", "http://visualcosita.xyz"]</li>
<li>["Alexey Nazaroff", "https://github.com/rogaven"]</li>
<li>["<a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/Samasaur1/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/Samasaur1">@Samasaur1</a>", "https://github.com/Samasaur1"]</li>
</ul>