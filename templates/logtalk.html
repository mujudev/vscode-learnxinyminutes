<h1>Logtalk</h1>
<p>Logtalk is an object-oriented logic programming language that extends and leverages Prolog with modern code encapsulation and code reuse mechanisms without compromising its declarative programming features. Logtalk is implemented in highly portable code and can use most modern and standards compliant Prolog implementations as a back-end compiler.</p>
<p>To keep its size reasonable, this tutorial necessarily assumes that the reader have a working knowledge of Prolog and is biased towards describing Logtalk object-oriented features.</p>
<h1>Syntax</h1>
<p>Logtalk uses standard Prolog syntax with the addition of a few operators and directives for a smooth learning curve and wide portability. One important consequence is that Prolog code can be easily encapsulated in objects with little or no changes. Moreover, Logtalk can transparently interpret most Prolog modules as Logtalk objects.</p>
<p>The main operators are:</p>
<ul>
<li><code class="notranslate">::/2</code> - sending a message to an object</li>
<li><code class="notranslate">::/1</code> - sending a message to <em>self</em> (i.e. to the object that received the message being processed)</li>
<li><code class="notranslate">^^/1</code> - <em>super</em> call (of an inherited or imported predicate)</li>
</ul>
<p>Some of the most important entity and predicate directives will be introduced in the next sections.</p>
<h1>Entities and roles</h1>
<p>Logtalk provides <em>objects</em>, <em>protocols</em>, and <em>categories</em> as first-class entities. Relations between entities define <em>patterns of code reuse</em> and the <em>roles</em> played by the entities. For example, when an object <em>instantiates</em> another object, the first object plays the role of an instance and the second object plays the role of a class. An <em>extends</em> relation between two objects implies that both objects play the role of prototypes, with one of them extending the other, its parent prototype.</p>
<h1>Defining an object</h1>
<p>An object encapsulates predicate declarations and definitions. Objects can be created dynamically but are usually static and defined in source files. A single source file can contain any number of entity definitions. A simple object, defining a list member public predicate:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">:- object</span>(<span class="pl-en">list</span>)<span class="pl-k">.</span>

	<span class="pl-k">:- public</span>(member<span class="pl-k">/</span><span class="pl-c1">2</span>)<span class="pl-k">.</span>
	member(<span class="pl-smi">Head</span><span class="pl-k">,</span> [<span class="pl-smi">Head</span>| <span class="pl-smi">_</span>])<span class="pl-k">.</span>
	member(<span class="pl-smi">Head</span><span class="pl-k">,</span> [<span class="pl-smi">_</span>| <span class="pl-smi">Tail</span>]) <span class="pl-k">:</span><span class="pl-k">-</span>
		member(<span class="pl-smi">Head</span><span class="pl-k">,</span> <span class="pl-smi">Tail</span>)<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span></pre></div>
<h1>Compiling and loading source files</h1>
<p>Assuming that the code above for the <code class="notranslate">list</code> object is saved in a <code class="notranslate">list.lgt</code> file, it can be compiled and loaded using the <code class="notranslate">logtalk_load/1</code> built-in predicate or its abbreviation, <code class="notranslate">{}/1</code>, with the file path as argument (the extension can be omitted):</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> <span class="pl-k">{</span>list<span class="pl-k">}</span><span class="pl-k">.</span>
yes</pre></div>
<p>In general, entities may have dependencies on entities defined in other source files (e.g. library entities). To load a file and all its dependencies, the advised solution is to define a<br>
<em>loader</em> file that loads all the necessary files for an application. A loader file is simply a source file, typically named <code class="notranslate">loader.lgt</code>, that makes calls to the <code class="notranslate">logtalk_load/1-2</code><br>
built-in predicates, usually from an <code class="notranslate">initialization/1</code> directive for portability and<br>
standards compliance. Loader files are provided for all libraries, tools, and examples.</p>
<h1>Sending a message to an object</h1>
<p>The <code class="notranslate">::/2</code> infix operator is used to send a message to an object. As in Prolog, we can backtrack for alternative solutions:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> list<span class="pl-k">::</span>member(<span class="pl-smi">X</span><span class="pl-k">,</span> [<span class="pl-c1">1</span><span class="pl-k">,</span><span class="pl-c1">2</span><span class="pl-k">,</span><span class="pl-c1">3</span>])<span class="pl-k">.</span>
<span class="pl-smi">X</span> <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">;</span>
<span class="pl-smi">X</span> <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-k">;</span>
<span class="pl-smi">X</span> <span class="pl-k">=</span> <span class="pl-c1">3</span>
yes</pre></div>
<p>Encapsulation is enforced. A predicate can be declared <em>public</em>, <em>protected</em>, or <em>private</em>. It can also be <em>local</em> when there is no scope directive for it. For example:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">:- object</span>(<span class="pl-en">scopes</span>)<span class="pl-k">.</span>

	<span class="pl-k">:- private</span>(bar<span class="pl-k">/</span><span class="pl-c1">0</span>)<span class="pl-k">.</span>
	bar<span class="pl-k">.</span>

	local<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span></pre></div>
<p>Assuming the object is saved in a <code class="notranslate">scopes.lgt</code> file:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> <span class="pl-k">{</span>scopes<span class="pl-k">}</span><span class="pl-k">.</span>
yes

<span class="pl-k">?</span><span class="pl-k">-</span> <span class="pl-c1">catch</span>(scopes<span class="pl-k">::</span>bar<span class="pl-k">,</span> <span class="pl-smi">Error</span><span class="pl-k">,</span> <span class="pl-c1">true</span>)<span class="pl-k">.</span>
<span class="pl-smi">Error</span> <span class="pl-k">=</span> error(
	permission_error(access<span class="pl-k">,</span> private_predicate<span class="pl-k">,</span> bar<span class="pl-k">/</span><span class="pl-c1">0</span>)<span class="pl-k">,</span>
	logtalk(scopes<span class="pl-k">::</span>bar<span class="pl-k">,</span> user)
)
yes

<span class="pl-k">?</span><span class="pl-k">-</span> <span class="pl-c1">catch</span>(scopes<span class="pl-k">::</span>local<span class="pl-k">,</span> <span class="pl-smi">Error</span><span class="pl-k">,</span> <span class="pl-c1">true</span>)<span class="pl-k">.</span>
<span class="pl-smi">Error</span> <span class="pl-k">=</span> error(
	existence_error(predicate_declaration<span class="pl-k">,</span> local<span class="pl-k">/</span><span class="pl-c1">0</span>)<span class="pl-k">,</span>
	logtalk(scopes<span class="pl-k">::</span>local<span class="pl-k">,</span> user)
)
yes</pre></div>
<p>When the predicate in a message is unknown for the object (the role it plays determines the lookup procedures), we also get an error. For example:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> <span class="pl-c1">catch</span>(scopes<span class="pl-k">::</span>unknown<span class="pl-k">,</span> <span class="pl-smi">Error</span><span class="pl-k">,</span> <span class="pl-c1">true</span>)<span class="pl-k">.</span>
<span class="pl-smi">Error</span> <span class="pl-k">=</span> error(
	existence_error(predicate_declaration<span class="pl-k">,</span> unknown<span class="pl-k">/</span><span class="pl-c1">0</span>)<span class="pl-k">,</span>
	logtalk(scopes<span class="pl-k">::</span>unknown<span class="pl-k">,</span> user)
)
yes</pre></div>
<p>A subtle point is that predicate scope directives specify predicate <em>calling</em> semantics, not <em>definition</em> semantics. For example, if an object playing the role of a class declares a predicate private, the predicate can be defined in subclasses and instances <em>but</em> can only be called in its instances <em>from</em> the class.</p>
<h1>Defining and implementing a protocol</h1>
<p>Protocols contain predicate declarations that can be implemented by any number of objects and categories:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">:- protocol</span>(<span class="pl-en">listp</span>)<span class="pl-k">.</span>

	<span class="pl-k">:- public</span>(member<span class="pl-k">/</span><span class="pl-c1">2</span>)<span class="pl-k">.</span>

<span class="pl-k">:- end_protocol</span><span class="pl-k">.</span>

<span class="pl-k">:- object</span>(<span class="pl-en">list</span><span class="pl-k">,</span>
	<span class="pl-k">implements</span>(listp))<span class="pl-k">.</span>

	member(<span class="pl-smi">Head</span><span class="pl-k">,</span> [<span class="pl-smi">Head</span>| <span class="pl-smi">_</span>])<span class="pl-k">.</span>
	member(<span class="pl-smi">Head</span><span class="pl-k">,</span> [<span class="pl-smi">_</span>| <span class="pl-smi">Tail</span>]) <span class="pl-k">:</span><span class="pl-k">-</span>
		member(<span class="pl-smi">Head</span><span class="pl-k">,</span> <span class="pl-smi">Tail</span>)<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span></pre></div>
<p>The scope of the protocol predicates can be restricted using protected or private implementation. For example:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">:- object</span>(<span class="pl-en">stack</span><span class="pl-k">,</span>
	<span class="pl-k">implements</span>(private<span class="pl-k">::</span>listp))<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span></pre></div>
<p>In fact, all entity relations (in an entity opening directive) can be qualified as public (the default), protected, or private.</p>
<h1>Prototypes</h1>
<p>An object without an <em>instantiation</em> or <em>specialization</em> relation with another object plays the role of a prototype. A prototype can <em>extend</em> another object, its parent prototype.</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-c"><span class="pl-c">%</span> clyde, our prototypical elephant</span>
<span class="pl-k">:- object</span>(<span class="pl-en">clyde</span>)<span class="pl-k">.</span>

	<span class="pl-k">:- public</span>(color<span class="pl-k">/</span><span class="pl-c1">1</span>)<span class="pl-k">.</span>
	color(grey)<span class="pl-k">.</span>

	<span class="pl-k">:- public</span>(number_of_legs<span class="pl-k">/</span><span class="pl-c1">1</span>)<span class="pl-k">.</span>
	number_of_legs(<span class="pl-c1">4</span>)<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span>

<span class="pl-c"><span class="pl-c">%</span> fred, another elephant, is like clyde, except that he's white</span>
<span class="pl-k">:- object</span>(<span class="pl-en">fred</span><span class="pl-k">,</span>
	<span class="pl-k">extends</span>(clyde))<span class="pl-k">.</span>

	color(white)<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span></pre></div>
<p>When answering a message sent to an object playing the role of a prototype, we validate the message and look for an answer first in the prototype itself and, if not found, we delegate to the prototype parents if any:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> fred<span class="pl-k">::</span>number_of_legs(<span class="pl-smi">N</span>)<span class="pl-k">.</span>
<span class="pl-smi">N</span> <span class="pl-k">=</span> <span class="pl-c1">4</span>
yes

<span class="pl-k">?</span><span class="pl-k">-</span> fred<span class="pl-k">::</span>color(<span class="pl-smi">C</span>)<span class="pl-k">.</span>
<span class="pl-smi">C</span> <span class="pl-k">=</span> white
yes</pre></div>
<p>A message is valid if the corresponding predicate is declared (and the sender is within scope) but it will fail, rather then throwing an error, if the predicate is not defined. This is called the <em>closed-world assumption</em>. For example, consider the following object, saved in a <code class="notranslate">foo.lgt</code> file:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">:- object</span>(<span class="pl-en">foo</span>)<span class="pl-k">.</span>

	<span class="pl-k">:- public</span>(bar<span class="pl-k">/</span><span class="pl-c1">0</span>)<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span></pre></div>
<p>Loading the file and trying to call the <code class="notranslate">bar/0</code> predicate fails as expected. Note that this is different from calling an <em>unknown</em> predicate, which results in an error:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> <span class="pl-k">{</span>foo<span class="pl-k">}</span><span class="pl-k">.</span>
yes

<span class="pl-k">?</span><span class="pl-k">-</span> foo<span class="pl-k">::</span>bar<span class="pl-k">.</span>
no

<span class="pl-k">?</span><span class="pl-k">-</span> <span class="pl-c1">catch</span>(foo<span class="pl-k">::</span>baz<span class="pl-k">,</span> <span class="pl-smi">Error</span><span class="pl-k">,</span> <span class="pl-c1">true</span>)<span class="pl-k">.</span>
<span class="pl-smi">Error</span> <span class="pl-k">=</span> error(
	existence_error(predicate_declaration<span class="pl-k">,</span> baz<span class="pl-k">/</span><span class="pl-c1">0</span>)<span class="pl-k">,</span>
	logtalk(foo<span class="pl-k">::</span>baz<span class="pl-k">,</span> user)
)
yes</pre></div>
<h1>Classes and instances</h1>
<p>In order to define objects playing the role of classes and/or instances, an object must have at least an instantiation or a specialization relation with another object. Objects playing the role of meta-classes can be used when we need to see a class also as an instance. We use the following example to also illustrate how to dynamically create new objects at runtime:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-c"><span class="pl-c">%</span> a simple, generic, metaclass defining a new/2 predicate for its instances</span>
<span class="pl-k">:- object</span>(<span class="pl-en">metaclass</span><span class="pl-k">,</span>
	<span class="pl-k">instantiates</span>(metaclass))<span class="pl-k">.</span>

	<span class="pl-k">:- public</span>(new<span class="pl-k">/</span><span class="pl-c1">2</span>)<span class="pl-k">.</span>
	new(<span class="pl-smi">Instance</span><span class="pl-k">,</span> <span class="pl-smi">Clauses</span>) <span class="pl-k">:</span><span class="pl-k">-</span>
		<span class="pl-c1">self</span>(<span class="pl-smi">Class</span>)<span class="pl-k">,</span>
		<span class="pl-c1">create_object</span>(<span class="pl-smi">Instance</span><span class="pl-k">,</span> [<span class="pl-k">instantiates</span>(<span class="pl-smi">Class</span>)]<span class="pl-k">,</span> []<span class="pl-k">,</span> <span class="pl-smi">Clauses</span>)<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span>

<span class="pl-c"><span class="pl-c">%</span> a simple class defining age/1 and name/1 predicate for its instances</span>
<span class="pl-k">:- object</span>(<span class="pl-en">person</span><span class="pl-k">,</span>
	<span class="pl-k">instantiates</span>(metaclass))<span class="pl-k">.</span>

	<span class="pl-k">:- public</span>([
		age<span class="pl-k">/</span><span class="pl-c1">1</span><span class="pl-k">,</span> name<span class="pl-k">/</span><span class="pl-c1">1</span>
	])<span class="pl-k">.</span>

	<span class="pl-c"><span class="pl-c">%</span> a default value for age/1</span>
	age(<span class="pl-c1">42</span>)<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span>

<span class="pl-c"><span class="pl-c">%</span> a static instance of the class person</span>
<span class="pl-k">:- object</span>(<span class="pl-en">john</span><span class="pl-k">,</span>
	<span class="pl-k">instantiates</span>(person))<span class="pl-k">.</span>

	name(john)<span class="pl-k">.</span>
	age(<span class="pl-c1">12</span>)<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span></pre></div>
<p>When answering a message sent to an object playing the role of an instance, we validate the message by starting in its class and going up to its class superclasses if necessary. Assuming that the message is valid, then we look for an answer starting in the instance itself:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> person<span class="pl-k">::</span>new(<span class="pl-smi">Instance</span><span class="pl-k">,</span> [name(paulo)])<span class="pl-k">.</span>
<span class="pl-smi">Instance</span> <span class="pl-k">=</span> o1
yes

<span class="pl-k">?</span><span class="pl-k">-</span> o1<span class="pl-k">::</span>name(<span class="pl-smi">Name</span>)<span class="pl-k">.</span>
<span class="pl-smi">Name</span> <span class="pl-k">=</span> paulo
yes

<span class="pl-k">?</span><span class="pl-k">-</span> o1<span class="pl-k">::</span>age(<span class="pl-smi">Age</span>)<span class="pl-k">.</span>
<span class="pl-smi">Age</span> <span class="pl-k">=</span> <span class="pl-c1">42</span>
yes

<span class="pl-k">?</span><span class="pl-k">-</span> john<span class="pl-k">::</span>age(<span class="pl-smi">Age</span>)<span class="pl-k">.</span>
<span class="pl-smi">Age</span> <span class="pl-k">=</span> <span class="pl-c1">12</span>
yes</pre></div>
<h1>Categories</h1>
<p>A category is a fine grained unit of code reuse, used to encapsulate a <em>cohesive</em> set of predicate declarations and definitions, implementing a <em>single</em> functionality, that can be imported into any object. A category can thus be seen as the dual concept of a protocol. In the following example, we define categories representing car engines and then import them into car objects:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-c"><span class="pl-c">%</span> a protocol describing engine characteristics</span>
<span class="pl-k">:- protocol</span>(<span class="pl-en">carenginep</span>)<span class="pl-k">.</span>

	<span class="pl-k">:- public</span>([
		reference<span class="pl-k">/</span><span class="pl-c1">1</span><span class="pl-k">,</span>
		capacity<span class="pl-k">/</span><span class="pl-c1">1</span><span class="pl-k">,</span>
		cylinders<span class="pl-k">/</span><span class="pl-c1">1</span><span class="pl-k">,</span>
		horsepower_rpm<span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">,</span>
		bore_stroke<span class="pl-k">/</span><span class="pl-c1">2</span><span class="pl-k">,</span>
		fuel<span class="pl-k">/</span><span class="pl-c1">1</span>
	])<span class="pl-k">.</span>

<span class="pl-k">:- end_protocol</span><span class="pl-k">.</span>

<span class="pl-c"><span class="pl-c">%</span> a typical engine defined as a category</span>
<span class="pl-k">:- category</span>(<span class="pl-en">classic</span><span class="pl-k">,</span>
	<span class="pl-k">implements</span>(carenginep))<span class="pl-k">.</span>

	reference(<span class="pl-s"><span class="pl-pds">'</span>M180.940<span class="pl-pds">'</span></span>)<span class="pl-k">.</span>
	capacity(<span class="pl-c1">2195</span>)<span class="pl-k">.</span>
	cylinders(<span class="pl-c1">6</span>)<span class="pl-k">.</span>
	horsepower_rpm(<span class="pl-c1">94</span><span class="pl-k">,</span> <span class="pl-c1">4800</span>)<span class="pl-k">.</span>
	bore_stroke(<span class="pl-c1">80</span><span class="pl-k">,</span> <span class="pl-c1">72.8</span>)<span class="pl-k">.</span>
	fuel(gasoline)<span class="pl-k">.</span>

<span class="pl-k">:- end_category</span><span class="pl-k">.</span>

<span class="pl-c"><span class="pl-c">%</span> a souped up version of the previous engine</span>
<span class="pl-k">:- category</span>(<span class="pl-en">sport</span><span class="pl-k">,</span>
	<span class="pl-k">extends</span>(classic))<span class="pl-k">.</span>

	reference(<span class="pl-s"><span class="pl-pds">'</span>M180.941<span class="pl-pds">'</span></span>)<span class="pl-k">.</span>
	horsepower_rpm(<span class="pl-smi">HP</span><span class="pl-k">,</span> <span class="pl-smi">RPM</span>) <span class="pl-k">:</span><span class="pl-k">-</span>
		<span class="pl-k">^^</span>horsepower_rpm(<span class="pl-smi">ClassicHP</span><span class="pl-k">,</span> <span class="pl-smi">ClassicRPM</span>)<span class="pl-k">,</span>	<span class="pl-c"><span class="pl-c">%</span> "super" call</span>
		<span class="pl-smi">HP</span> <span class="pl-k">is</span> <span class="pl-c1">truncate</span>(<span class="pl-smi">ClassicHP</span><span class="pl-k">*</span><span class="pl-c1">1.23</span>)<span class="pl-k">,</span>
		<span class="pl-smi">RPM</span> <span class="pl-k">is</span> <span class="pl-c1">truncate</span>(<span class="pl-smi">ClassicRPM</span><span class="pl-k">*</span><span class="pl-c1">0.762</span>)<span class="pl-k">.</span>

<span class="pl-k">:- end_category</span><span class="pl-k">.</span>

<span class="pl-c"><span class="pl-c">%</span> with engines (and other components), we may start "assembling" some cars</span>
<span class="pl-k">:- object</span>(<span class="pl-en">sedan</span><span class="pl-k">,</span>
	<span class="pl-k">imports</span>(classic))<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span>

<span class="pl-k">:- object</span>(<span class="pl-en">coupe</span><span class="pl-k">,</span>
	<span class="pl-k">imports</span>(sport))<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span></pre></div>
<p>Categories are independently compiled and thus allow importing objects to be updated by simple updating the imported categories without requiring object recompilation. Categories also provide <em>runtime transparency</em>. I.e. the category protocol adds to the protocol of the objects importing the category:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> sedan<span class="pl-k">::</span><span class="pl-c1">current_predicate</span>(<span class="pl-smi">Predicate</span>)<span class="pl-k">.</span>
<span class="pl-smi">Predicate</span> <span class="pl-k">=</span> reference<span class="pl-k">/</span><span class="pl-c1">1</span> <span class="pl-k">;</span>
<span class="pl-smi">Predicate</span> <span class="pl-k">=</span> capacity<span class="pl-k">/</span><span class="pl-c1">1</span> <span class="pl-k">;</span>
<span class="pl-smi">Predicate</span> <span class="pl-k">=</span> cylinders<span class="pl-k">/</span><span class="pl-c1">1</span> <span class="pl-k">;</span>
<span class="pl-smi">Predicate</span> <span class="pl-k">=</span> horsepower_rpm<span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">;</span>
<span class="pl-smi">Predicate</span> <span class="pl-k">=</span> bore_stroke<span class="pl-k">/</span><span class="pl-c1">2</span> <span class="pl-k">;</span>
<span class="pl-smi">Predicate</span> <span class="pl-k">=</span> fuel<span class="pl-k">/</span><span class="pl-c1">1</span>
yes</pre></div>
<h1>Hot patching</h1>
<p>Categories can be also be used for hot-patching objects. A category can add new predicates to an object and/or replace object predicate definitions. For example, consider the following object:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">:- object</span>(<span class="pl-en">buggy</span>)<span class="pl-k">.</span>

	<span class="pl-k">:- public</span>(p<span class="pl-k">/</span><span class="pl-c1">0</span>)<span class="pl-k">.</span>
	p <span class="pl-k">:</span><span class="pl-k">-</span> <span class="pl-c1">write</span>(foo)<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span></pre></div>
<p>Assume that the object prints the wrong string when sent the message <code class="notranslate">p/0</code>:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> <span class="pl-k">{</span>buggy<span class="pl-k">}</span><span class="pl-k">.</span>
yes

<span class="pl-k">?</span><span class="pl-k">-</span> buggy<span class="pl-k">::</span>p<span class="pl-k">.</span>
foo
yes</pre></div>
<p>If the object source code is not available and we need to fix an application running the object code, we can simply define a category that fixes the buggy predicate:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">:- category</span>(<span class="pl-en">patch</span><span class="pl-k">,</span>
	<span class="pl-k">complements</span>(buggy))<span class="pl-k">.</span>

	<span class="pl-c"><span class="pl-c">%</span> fixed p/0 def</span>
	p <span class="pl-k">:</span><span class="pl-k">-</span> <span class="pl-c1">write</span>(bar)<span class="pl-k">.</span>

<span class="pl-k">:- end_category</span><span class="pl-k">.</span></pre></div>
<p>After compiling and loading the category into the running application we will now get:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> <span class="pl-k">{</span>patch<span class="pl-k">}</span><span class="pl-k">.</span>
yes

<span class="pl-k">?</span><span class="pl-k">-</span> buggy<span class="pl-k">::</span>p<span class="pl-k">.</span>
bar
yes</pre></div>
<p>As hot-patching forcefully breaks encapsulation, there is a <code class="notranslate">complements</code> compiler flag that can be set (globally or on a per-object basis) to allow, restrict, or prevent it.</p>
<h1>Parametric objects and categories</h1>
<p>Objects and categories can be parameterized by using as identifier a compound term instead of an atom. Object and category parameters are <em>logical variables</em> shared with all encapsulated predicates. An example with geometric circles:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">:- object</span>(<span class="pl-en">circle</span>(<span class="pl-smi">_Radius</span><span class="pl-k">,</span> <span class="pl-smi">_Color</span>))<span class="pl-k">.</span>

	<span class="pl-k">:- public</span>([
		area<span class="pl-k">/</span><span class="pl-c1">1</span><span class="pl-k">,</span> perimeter<span class="pl-k">/</span><span class="pl-c1">1</span>
	])<span class="pl-k">.</span>

	area(<span class="pl-smi">Area</span>) <span class="pl-k">:</span><span class="pl-k">-</span>
		<span class="pl-c1">parameter</span>(<span class="pl-c1">1</span><span class="pl-k">,</span> <span class="pl-smi">Radius</span>)<span class="pl-k">,</span>
		<span class="pl-smi">Area</span> <span class="pl-k">is</span> <span class="pl-k">pi*</span><span class="pl-smi">Radius</span><span class="pl-k">*</span><span class="pl-smi">Radius</span><span class="pl-k">.</span>

	perimeter(<span class="pl-smi">Perimeter</span>) <span class="pl-k">:</span><span class="pl-k">-</span>
		<span class="pl-c1">parameter</span>(<span class="pl-c1">1</span><span class="pl-k">,</span> <span class="pl-smi">Radius</span>)<span class="pl-k">,</span>
		<span class="pl-smi">Perimeter</span> <span class="pl-k">is</span> <span class="pl-c1">2</span><span class="pl-k">*pi*</span><span class="pl-smi">Radius</span><span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span></pre></div>
<p>Parametric objects are used just as any other object, usually providing values for the parameters when sending a message:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> circle(<span class="pl-c1">1.23</span><span class="pl-k">,</span> blue)<span class="pl-k">::</span>area(<span class="pl-smi">Area</span>)<span class="pl-k">.</span>
<span class="pl-smi">Area</span> <span class="pl-k">=</span> <span class="pl-c1">4.75291</span>
yes</pre></div>
<p>Parametric objects also provide a simple way of associating a set of predicates with a plain Prolog predicate. Prolog facts can be interpreted as <em>parametric object proxies</em> when they have the same functor and arity as the identifiers of parametric objects. Handy syntax is provided to for working with proxies. For example, assuming the following clauses for a <code class="notranslate">circle/2</code> predicate:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate">circle(<span class="pl-c1">1.23</span><span class="pl-k">,</span> blue)<span class="pl-k">.</span>
circle(<span class="pl-c1">3.71</span><span class="pl-k">,</span> yellow)<span class="pl-k">.</span>
circle(<span class="pl-c1">0.39</span><span class="pl-k">,</span> green)<span class="pl-k">.</span>
circle(<span class="pl-c1">5.74</span><span class="pl-k">,</span> black)<span class="pl-k">.</span>
circle(<span class="pl-c1">8.32</span><span class="pl-k">,</span> cyan)<span class="pl-k">.</span></pre></div>
<p>With these clauses loaded, we can easily compute for example a list with the areas of all the circles:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> <span class="pl-c1">findall</span>(<span class="pl-smi">Area</span><span class="pl-k">,</span> <span class="pl-k">{</span>circle(<span class="pl-smi">_</span><span class="pl-k">,</span> <span class="pl-smi">_</span>)<span class="pl-k">}</span><span class="pl-k">::</span>area(<span class="pl-smi">Area</span>)<span class="pl-k">,</span> <span class="pl-smi">Areas</span>)<span class="pl-k">.</span>
<span class="pl-smi">Areas</span> <span class="pl-k">=</span> [<span class="pl-c1">4.75291</span><span class="pl-k">,</span> <span class="pl-c1">43.2412</span><span class="pl-k">,</span> <span class="pl-c1">0.477836</span><span class="pl-k">,</span> <span class="pl-c1">103.508</span><span class="pl-k">,</span> <span class="pl-c1">217.468</span>]
yes</pre></div>
<p>The <code class="notranslate">{Goal}::Message</code> construct proves <code class="notranslate">Goal</code>, possibly instantiating any variables in it, and sends <code class="notranslate">Message</code> to the resulting term.</p>
<h1>Events and monitors</h1>
<p>Logtalk supports <em>event-driven programming</em> by allowing defining events and monitors for those events. An event is simply the sending of a message to an object. Interpreting message sending as an atomic activity, a <em>before</em> event and an <em>after</em> event are recognized. Event monitors define event handler predicates, <code class="notranslate">before/3</code> and <code class="notranslate">after/3</code>, and can query, register, and delete a system-wide event registry that associates events with monitors. For example, a simple tracer for any message being sent using the <code class="notranslate">::/2</code> control construct can be defined as:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">:- object</span>(<span class="pl-en">tracer</span><span class="pl-k">,</span>
	<span class="pl-k">implements</span>(monitoring))<span class="pl-k">.</span>    <span class="pl-c"><span class="pl-c">%</span> built-in protocol for event handlers</span>

	<span class="pl-k">:- initialization</span>(<span class="pl-c1">define_events</span>(<span class="pl-smi">_</span><span class="pl-k">,</span> <span class="pl-smi">_</span><span class="pl-k">,</span> <span class="pl-smi">_</span><span class="pl-k">,</span> <span class="pl-smi">_</span><span class="pl-k">,</span> tracer))<span class="pl-k">.</span>

	<span class="pl-c1">before</span>(<span class="pl-smi">Object</span><span class="pl-k">,</span> <span class="pl-smi">Message</span><span class="pl-k">,</span> <span class="pl-smi">Sender</span>) <span class="pl-k">:</span><span class="pl-k">-</span>
		<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">'</span>call: <span class="pl-pds">'</span></span>)<span class="pl-k">,</span> <span class="pl-c1">writeq</span>(<span class="pl-smi">Object</span>)<span class="pl-k">,</span> <span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">'</span> &lt;-- <span class="pl-pds">'</span></span>)<span class="pl-k">,</span> <span class="pl-c1">writeq</span>(<span class="pl-smi">Message</span>)<span class="pl-k">,</span>
		<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">'</span> from <span class="pl-pds">'</span></span>)<span class="pl-k">,</span> <span class="pl-c1">writeq</span>(<span class="pl-smi">Sender</span>)<span class="pl-k">,</span> <span class="pl-c1">nl</span><span class="pl-k">.</span>

	<span class="pl-c1">after</span>(<span class="pl-smi">Object</span><span class="pl-k">,</span> <span class="pl-smi">Message</span><span class="pl-k">,</span> <span class="pl-smi">Sender</span>) <span class="pl-k">:</span><span class="pl-k">-</span>
		<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">'</span>exit: <span class="pl-pds">'</span></span>)<span class="pl-k">,</span> <span class="pl-c1">writeq</span>(<span class="pl-smi">Object</span>)<span class="pl-k">,</span> <span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">'</span> &lt;-- <span class="pl-pds">'</span></span>)<span class="pl-k">,</span> <span class="pl-c1">writeq</span>(<span class="pl-smi">Message</span>)<span class="pl-k">,</span>
		<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">'</span> from <span class="pl-pds">'</span></span>)<span class="pl-k">,</span> <span class="pl-c1">writeq</span>(<span class="pl-smi">Sender</span>)<span class="pl-k">,</span> <span class="pl-c1">nl</span><span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span></pre></div>
<p>Assuming that the <code class="notranslate">tracer</code> object and the <code class="notranslate">list</code> object defined earlier are compiled and loaded, we can observe the event handlers in action by sending a message:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> list<span class="pl-k">::</span>member(<span class="pl-smi">X</span><span class="pl-k">,</span> [<span class="pl-c1">1</span><span class="pl-k">,</span><span class="pl-c1">2</span><span class="pl-k">,</span><span class="pl-c1">3</span>])<span class="pl-k">.</span>

call<span class="pl-k">:</span> list <span class="pl-k">&lt;</span><span class="pl-k">--</span> member(<span class="pl-smi">X</span><span class="pl-k">,</span> [<span class="pl-c1">1</span><span class="pl-k">,</span><span class="pl-c1">2</span><span class="pl-k">,</span><span class="pl-c1">3</span>]) from user
exit<span class="pl-k">:</span> list <span class="pl-k">&lt;</span><span class="pl-k">--</span> member(<span class="pl-c1">1</span><span class="pl-k">,</span> [<span class="pl-c1">1</span><span class="pl-k">,</span><span class="pl-c1">2</span><span class="pl-k">,</span><span class="pl-c1">3</span>]) from user
<span class="pl-smi">X</span> <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">;</span>
exit<span class="pl-k">:</span> list <span class="pl-k">&lt;</span><span class="pl-k">--</span> member(<span class="pl-c1">2</span><span class="pl-k">,</span> [<span class="pl-c1">1</span><span class="pl-k">,</span><span class="pl-c1">2</span><span class="pl-k">,</span><span class="pl-c1">3</span>]) from user
<span class="pl-smi">X</span> <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-k">;</span>
exit<span class="pl-k">:</span> list <span class="pl-k">&lt;</span><span class="pl-k">--</span> member(<span class="pl-c1">3</span><span class="pl-k">,</span> [<span class="pl-c1">1</span><span class="pl-k">,</span><span class="pl-c1">2</span><span class="pl-k">,</span><span class="pl-c1">3</span>]) from user
<span class="pl-smi">X</span> <span class="pl-k">=</span> <span class="pl-c1">3</span>
yes</pre></div>
<p>Events can be set and deleted dynamically at runtime by calling the <code class="notranslate">define_events/5</code> and <code class="notranslate">abolish_events/5</code> built-in predicates.</p>
<p>Event-driven programming can be seen as a form of <em>computational reflection</em>. But note that events are only generated when using the <code class="notranslate">::/2</code> message-sending control construct.</p>
<h1>Lambda expressions</h1>
<p>Logtalk supports lambda expressions. Lambda parameters are represented using a list with the <code class="notranslate">(&gt;&gt;)/2</code> infix operator connecting them to the lambda. Some simple examples using library meta-predicates:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> <span class="pl-k">{</span>library(metapredicates_loader)<span class="pl-k">}</span><span class="pl-k">.</span>
yes

<span class="pl-k">?</span><span class="pl-k">-</span> meta<span class="pl-k">::</span>map([<span class="pl-smi">X</span><span class="pl-k">,</span><span class="pl-smi">Y</span>]<span class="pl-k">&gt;&gt;</span>(<span class="pl-smi">Y</span> <span class="pl-k">is</span> <span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-smi">X</span>)<span class="pl-k">,</span> [<span class="pl-c1">1</span><span class="pl-k">,</span><span class="pl-c1">2</span><span class="pl-k">,</span><span class="pl-c1">3</span>]<span class="pl-k">,</span> <span class="pl-smi">Ys</span>)<span class="pl-k">.</span>
<span class="pl-smi">Ys</span> <span class="pl-k">=</span> [<span class="pl-c1">2</span><span class="pl-k">,</span><span class="pl-c1">4</span><span class="pl-k">,</span><span class="pl-c1">6</span>]
yes</pre></div>
<p>Currying is also supported:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> meta<span class="pl-k">::</span>map([<span class="pl-smi">X</span>]<span class="pl-k">&gt;&gt;</span>([<span class="pl-smi">Y</span>]<span class="pl-k">&gt;&gt;</span>(<span class="pl-smi">Y</span> <span class="pl-k">is</span> <span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-smi">X</span>))<span class="pl-k">,</span> [<span class="pl-c1">1</span><span class="pl-k">,</span><span class="pl-c1">2</span><span class="pl-k">,</span><span class="pl-c1">3</span>]<span class="pl-k">,</span> <span class="pl-smi">Ys</span>)<span class="pl-k">.</span>
<span class="pl-smi">Ys</span> <span class="pl-k">=</span> [<span class="pl-c1">2</span><span class="pl-k">,</span><span class="pl-c1">4</span><span class="pl-k">,</span><span class="pl-c1">6</span>]
yes</pre></div>
<p>Lambda free variables can be expressed using the extended syntax <code class="notranslate">{Free1, ...}/[Parameter1, ...]&gt;&gt;Lambda</code>.</p>
<h1>Macros</h1>
<p>Terms and goals in source files can be <em>expanded</em> at compile time by specifying a <em>hook object</em> that defines term-expansion and goal-expansion rules. For example, consider the following simple object, saved in a <code class="notranslate">source.lgt</code> file:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">:- object</span>(<span class="pl-en">source</span>)<span class="pl-k">.</span>

	<span class="pl-k">:- public</span>(bar<span class="pl-k">/</span><span class="pl-c1">1</span>)<span class="pl-k">.</span>
	bar(<span class="pl-smi">X</span>) <span class="pl-k">:</span><span class="pl-k">-</span> foo(<span class="pl-smi">X</span>)<span class="pl-k">.</span>

	foo(a)<span class="pl-k">.</span> foo(b)<span class="pl-k">.</span> foo(c)<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span></pre></div>
<p>Assume the following hook object, saved in a <code class="notranslate">my_macros.lgt</code> file, that expands clauses and calls to the <code class="notranslate">foo/1</code> local predicate:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">:- object</span>(<span class="pl-en">my_macros</span><span class="pl-k">,</span>
	<span class="pl-k">implements</span>(expanding))<span class="pl-k">.</span>    <span class="pl-c"><span class="pl-c">%</span> built-in protocol for expanding predicates</span>

	<span class="pl-c1">term_expansion</span>(foo(<span class="pl-smi">Char</span>)<span class="pl-k">,</span> baz(<span class="pl-smi">Code</span>)) <span class="pl-k">:</span><span class="pl-k">-</span>
		<span class="pl-c1">char_code</span>(<span class="pl-smi">Char</span><span class="pl-k">,</span> <span class="pl-smi">Code</span>)<span class="pl-k">.</span> <span class="pl-c"><span class="pl-c">%</span> standard built-in predicate</span>

	<span class="pl-c1">goal_expansion</span>(foo(<span class="pl-smi">X</span>)<span class="pl-k">,</span> baz(<span class="pl-smi">X</span>))<span class="pl-k">.</span>

<span class="pl-k">:- end_object</span><span class="pl-k">.</span></pre></div>
<p>After loading the macros file, we can then expand our source file with it using the <code class="notranslate">hook</code> compiler flag:</p>
<div class="highlight highlight-source-logtalk"><pre class="notranslate"><span class="pl-k">?</span><span class="pl-k">-</span> <span class="pl-c1">logtalk_load</span>(my_macros)<span class="pl-k">,</span> <span class="pl-c1">logtalk_load</span>(source<span class="pl-k">,</span> [hook(my_macros)])<span class="pl-k">.</span>
yes

<span class="pl-k">?</span><span class="pl-k">-</span> source<span class="pl-k">::</span>bar(<span class="pl-smi">X</span>)<span class="pl-k">.</span>
<span class="pl-smi">X</span> <span class="pl-k">=</span> <span class="pl-c1">97</span> <span class="pl-k">;</span>
<span class="pl-smi">X</span> <span class="pl-k">=</span> <span class="pl-c1">98</span> <span class="pl-k">;</span>
<span class="pl-smi">X</span> <span class="pl-k">=</span> <span class="pl-c1">99</span>
<span class="pl-c1">true</span></pre></div>
<p>The Logtalk library provides support for combining hook objects using different workflows (for example, defining a pipeline of expansions).</p>
<h1>Further information</h1>
<p>Visit the <a href="http://logtalk.org" rel="nofollow">Logtalk website</a> for more information.</p>
<hr>
<h2>Contributors</h2>
<pre class="notranslate"><code class="notranslate">- ["Paulo Moura", "http://github.com/pmoura"]
</code></pre>