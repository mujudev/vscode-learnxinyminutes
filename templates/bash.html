<h1>Bash</h1>
<p>Bash is a name of the unix shell, which was also distributed as the shell<br>
for the GNU operating system and as the default shell on most Linux distros.<br>
Nearly all examples below can be a part of a shell script<br>
or executed directly in the shell.</p>
<p><a href="https://www.gnu.org/software/bash/manual/bashref.html" rel="nofollow">Read more here.</a></p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#!</span>/usr/bin/env bash</span>
<span class="pl-c"><span class="pl-c">#</span> First line of the script is the shebang which tells the system how to execute</span>
<span class="pl-c"><span class="pl-c">#</span> the script: https://en.wikipedia.org/wiki/Shebang_(Unix)</span>
<span class="pl-c"><span class="pl-c">#</span> As you already figured, comments start with #. Shebang is also a comment.</span>

<span class="pl-c"><span class="pl-c">#</span> Simple hello world example:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Hello world!<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; Hello world!</span>

<span class="pl-c"><span class="pl-c">#</span> Each command starts on a new line, or after a semicolon:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>This is the first command<span class="pl-pds">"</span></span><span class="pl-k">;</span> <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>This is the second command<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; This is the first command</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; This is the second command</span>

<span class="pl-c"><span class="pl-c">#</span> Declaring a variable looks like this:</span>
variable=<span class="pl-s"><span class="pl-pds">"</span>Some string<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> But not like this:</span>
variable = <span class="pl-s"><span class="pl-pds">"</span>Some string<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; returns error "variable: command not found"</span>
<span class="pl-c"><span class="pl-c">#</span> Bash will decide that `variable` is a command it must execute and give an error</span>
<span class="pl-c"><span class="pl-c">#</span> because it can't be found.</span>

<span class="pl-c"><span class="pl-c">#</span> Nor like this:</span>
variable= <span class="pl-s"><span class="pl-pds">"</span>Some string<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; returns error: "Some string: command not found"</span>
<span class="pl-c"><span class="pl-c">#</span> Bash will decide that "Some string" is a command it must execute and give an</span>
<span class="pl-c"><span class="pl-c">#</span> error because it can't be found. In this case the "variable=" part is seen</span>
<span class="pl-c"><span class="pl-c">#</span> as a variable assignment valid only for the scope of the "Some string"</span>
<span class="pl-c"><span class="pl-c">#</span> command.</span>

<span class="pl-c"><span class="pl-c">#</span> Using the variable:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$variable</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; Some string</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">'</span>$variable<span class="pl-pds">'</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; $variable</span>
<span class="pl-c"><span class="pl-c">#</span> When you use a variable itself — assign it, export it, or else — you write</span>
<span class="pl-c"><span class="pl-c">#</span> its name without $. If you want to use the variable's value, you should use $.</span>
<span class="pl-c"><span class="pl-c">#</span> Note that ' (single quote) won't expand the variables!</span>
<span class="pl-c"><span class="pl-c">#</span> You can write variable without surrounding quotes but it's not recommended.</span>

<span class="pl-c"><span class="pl-c">#</span> Parameter expansion ${...}:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">${variable}</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; Some string</span>
<span class="pl-c"><span class="pl-c">#</span> This is a simple usage of parameter expansion such as two examples above.</span>
<span class="pl-c"><span class="pl-c">#</span> Parameter expansion gets a value from a variable.</span>
<span class="pl-c"><span class="pl-c">#</span> It "expands" or prints the value.</span>
<span class="pl-c"><span class="pl-c">#</span> During the expansion time the value or parameter can be modified.</span>
<span class="pl-c"><span class="pl-c">#</span> Below are other modifications that add onto this expansion.</span>

<span class="pl-c"><span class="pl-c">#</span> String substitution in variables:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">${variable<span class="pl-k">/</span>Some<span class="pl-k">/</span>A}</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; A string</span>
<span class="pl-c"><span class="pl-c">#</span> This will substitute the first occurrence of "Some" with "A".</span>

<span class="pl-c"><span class="pl-c">#</span> Substring from a variable:</span>
length=7
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">${variable<span class="pl-k">:</span>0<span class="pl-k">:</span>length}</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; Some st</span>
<span class="pl-c"><span class="pl-c">#</span> This will return only the first 7 characters of the value</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">${variable<span class="pl-k">:</span> -5}</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; tring</span>
<span class="pl-c"><span class="pl-c">#</span> This will return the last 5 characters (note the space before -5).</span>
<span class="pl-c"><span class="pl-c">#</span> The space before minus is mandatory here.</span>

<span class="pl-c"><span class="pl-c">#</span> String length:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">${<span class="pl-k">#</span>variable}</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; 11</span>

<span class="pl-c"><span class="pl-c">#</span> Indirect expansion:</span>
other_variable=<span class="pl-s"><span class="pl-pds">"</span>variable<span class="pl-pds">"</span></span>
<span class="pl-c1">echo</span> <span class="pl-smi">${<span class="pl-k">!</span>other_variable}</span> <span class="pl-c"><span class="pl-c">#</span> =&gt; Some string</span>
<span class="pl-c"><span class="pl-c">#</span> This will expand the value of `other_variable`.</span>

<span class="pl-c"><span class="pl-c">#</span> The default value for variable:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">${foo<span class="pl-k">:-</span><span class="pl-s"><span class="pl-pds">"</span>DefaultValueIfFooIsMissingOrEmpty<span class="pl-pds">"</span></span>}</span><span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; DefaultValueIfFooIsMissingOrEmpty</span>
<span class="pl-c"><span class="pl-c">#</span> This works for null (foo=) and empty string (foo=""); zero (foo=0) returns 0.</span>
<span class="pl-c"><span class="pl-c">#</span> Note that it only returns default value and doesn't change variable value.</span>

<span class="pl-c"><span class="pl-c">#</span> Declare an array with 6 elements:</span>
array=(one two three four five six)
<span class="pl-c"><span class="pl-c">#</span> Print the first element:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">${array[0]}</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; "one"</span>
<span class="pl-c"><span class="pl-c">#</span> Print all elements:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">${array[@]}</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; "one two three four five six"</span>
<span class="pl-c"><span class="pl-c">#</span> Print the number of elements:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">${<span class="pl-k">#</span>array[@]}</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; "6"</span>
<span class="pl-c"><span class="pl-c">#</span> Print the number of characters in third element</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">${<span class="pl-k">#</span>array[2]}</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; "5"</span>
<span class="pl-c"><span class="pl-c">#</span> Print 2 elements starting from fourth:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">${array[@]<span class="pl-k">:</span>3<span class="pl-k">:</span>2}</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; "four five"</span>
<span class="pl-c"><span class="pl-c">#</span> Print all elements each of them on new line.</span>
<span class="pl-k">for</span> <span class="pl-smi">item</span> <span class="pl-k">in</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">${array[@]}</span><span class="pl-pds">"</span></span><span class="pl-k">;</span> <span class="pl-k">do</span>
    <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$item</span><span class="pl-pds">"</span></span>
<span class="pl-k">done</span>

<span class="pl-c"><span class="pl-c">#</span> Built-in variables:</span>
<span class="pl-c"><span class="pl-c">#</span> There are some useful built-in variables, like:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Last program's return value: <span class="pl-smi">$?</span><span class="pl-pds">"</span></span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Script's PID: <span class="pl-smi">$$</span><span class="pl-pds">"</span></span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Number of arguments passed to script: <span class="pl-smi">$#</span><span class="pl-pds">"</span></span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>All arguments passed to script: <span class="pl-smi">$@</span><span class="pl-pds">"</span></span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Script's arguments separated into different variables: <span class="pl-smi">$1</span> <span class="pl-smi">$2</span>...<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> Brace Expansion {...}</span>
<span class="pl-c"><span class="pl-c">#</span> used to generate arbitrary strings:</span>
<span class="pl-c1">echo</span> {1..10} <span class="pl-c"><span class="pl-c">#</span> =&gt; 1 2 3 4 5 6 7 8 9 10</span>
<span class="pl-c1">echo</span> {a..z} <span class="pl-c"><span class="pl-c">#</span> =&gt; a b c d e f g h i j k l m n o p q r s t u v w x y z</span>
<span class="pl-c"><span class="pl-c">#</span> This will output the range from the start value to the end value.</span>
<span class="pl-c"><span class="pl-c">#</span> Note that you can't use variables here:</span>
from=1
to=10
<span class="pl-c1">echo</span> {<span class="pl-smi">$from</span>..<span class="pl-smi">$to</span>} <span class="pl-c"><span class="pl-c">#</span> =&gt; {$from..$to}</span>

<span class="pl-c"><span class="pl-c">#</span> Now that we know how to echo and use variables,</span>
<span class="pl-c"><span class="pl-c">#</span> let's learn some of the other basics of Bash!</span>

<span class="pl-c"><span class="pl-c">#</span> Our current directory is available through the command `pwd`.</span>
<span class="pl-c"><span class="pl-c">#</span> `pwd` stands for "print working directory".</span>
<span class="pl-c"><span class="pl-c">#</span> We can also use the built-in variable `$PWD`.</span>
<span class="pl-c"><span class="pl-c">#</span> Observe that the following are equivalent:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>I'm in <span class="pl-s"><span class="pl-pds">$(</span>pwd<span class="pl-pds">)</span></span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> execs `pwd` and interpolates output</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>I'm in <span class="pl-smi">$PWD</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> interpolates the variable</span>

<span class="pl-c"><span class="pl-c">#</span> If you get too much output in your terminal, or from a script, the command</span>
<span class="pl-c"><span class="pl-c">#</span> `clear` clears your screen:</span>
clear
<span class="pl-c"><span class="pl-c">#</span> Ctrl-L also works for clearing output.</span>

<span class="pl-c"><span class="pl-c">#</span> Reading a value from input:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>What's your name?<span class="pl-pds">"</span></span>
<span class="pl-c1">read</span> name
<span class="pl-c"><span class="pl-c">#</span> Note that we didn't need to declare a new variable.</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Hello, <span class="pl-smi">$name</span>!<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> We have the usual if structure.</span>
<span class="pl-c"><span class="pl-c">#</span> Condition is true if the value of $name is not equal to the current user's login username:</span>
<span class="pl-k">if</span> [[ <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$name</span><span class="pl-pds">"</span></span> <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$USER</span><span class="pl-pds">"</span></span> ]]<span class="pl-k">;</span> <span class="pl-k">then</span>
    <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Your name isn't your username<span class="pl-pds">"</span></span>
<span class="pl-k">else</span>
    <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Your name is your username<span class="pl-pds">"</span></span>
<span class="pl-k">fi</span>

<span class="pl-c"><span class="pl-c">#</span> To use &amp;&amp; and || with if statements, you need multiple pairs of square brackets:</span>
<span class="pl-c1">read</span> age
<span class="pl-k">if</span> [[ <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$name</span><span class="pl-pds">"</span></span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>Steve<span class="pl-pds">"</span></span> ]] <span class="pl-k">&amp;&amp;</span> [[ <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$age</span><span class="pl-pds">"</span></span> <span class="pl-k">-eq</span> 15 ]]<span class="pl-k">;</span> <span class="pl-k">then</span>
    <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>This will run if <span class="pl-smi">$name</span> is Steve AND <span class="pl-smi">$age</span> is 15.<span class="pl-pds">"</span></span>
<span class="pl-k">fi</span>

<span class="pl-k">if</span> [[ <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$name</span><span class="pl-pds">"</span></span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>Daniya<span class="pl-pds">"</span></span> ]] <span class="pl-k">||</span> [[ <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$name</span><span class="pl-pds">"</span></span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>Zach<span class="pl-pds">"</span></span> ]]<span class="pl-k">;</span> <span class="pl-k">then</span>
    <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>This will run if <span class="pl-smi">$name</span> is Daniya OR Zach.<span class="pl-pds">"</span></span>
<span class="pl-k">fi</span>
<span class="pl-c"><span class="pl-c">#</span> There are other comparison operators for numbers listed below:</span>
<span class="pl-c"><span class="pl-c">#</span> -ne - not equal</span>
<span class="pl-c"><span class="pl-c">#</span> -lt - less than</span>
<span class="pl-c"><span class="pl-c">#</span> -gt - greater than</span>
<span class="pl-c"><span class="pl-c">#</span> -le - less than or equal to</span>
<span class="pl-c"><span class="pl-c">#</span> -ge - greater than or equal to</span>

<span class="pl-c"><span class="pl-c">#</span> There is also the `=~` operator, which tests a string against the Regex pattern:</span>
email=me@example.com
<span class="pl-k">if</span> [[ <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$email</span><span class="pl-pds">"</span></span> <span class="pl-k">=~</span> [a-z]+@[a-z]{2,}<span class="pl-cce">\.</span>(com<span class="pl-k">|</span>net<span class="pl-k">|</span>org) ]]
<span class="pl-k">then</span>
    <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Valid email!<span class="pl-pds">"</span></span>
<span class="pl-k">fi</span>

<span class="pl-c"><span class="pl-c">#</span> There is also conditional execution</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Always executed<span class="pl-pds">"</span></span> <span class="pl-k">||</span> <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Only executed if first command fails<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; Always executed</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Always executed<span class="pl-pds">"</span></span> <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Only executed if first command does NOT fail<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; Always executed</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; Only executed if first command does NOT fail</span>

<span class="pl-c"><span class="pl-c">#</span> A single ampersand &amp; after a command runs it in the background. A background command's</span>
<span class="pl-c"><span class="pl-c">#</span> output is printed to the terminal, but it cannot read from the input.</span>
sleep 30 <span class="pl-k">&amp;</span>
<span class="pl-c"><span class="pl-c">#</span> List background jobs</span>
<span class="pl-c1">jobs</span> <span class="pl-c"><span class="pl-c">#</span> =&gt; [1]+  Running                 sleep 30 &amp;</span>
<span class="pl-c"><span class="pl-c">#</span> Bring the background job to the foreground</span>
<span class="pl-c1">fg</span>
<span class="pl-c"><span class="pl-c">#</span> Ctrl-C to kill the process, or Ctrl-Z to pause it</span>
<span class="pl-c"><span class="pl-c">#</span> Resume a background process after it has been paused with Ctrl-Z</span>
<span class="pl-c1">bg</span>
<span class="pl-c"><span class="pl-c">#</span> Kill job number 2</span>
<span class="pl-c1">kill</span> %2
<span class="pl-c"><span class="pl-c">#</span> %1, %2, etc. can be used for fg and bg as well</span>

<span class="pl-c"><span class="pl-c">#</span> Redefine command `ping` as alias to send only 5 packets</span>
<span class="pl-c1">alias</span> ping=<span class="pl-s"><span class="pl-pds">'</span>ping -c 5<span class="pl-pds">'</span></span>
<span class="pl-c"><span class="pl-c">#</span> Escape the alias and use command with this name instead</span>
<span class="pl-cce">\p</span>ing 192.168.1.1
<span class="pl-c"><span class="pl-c">#</span> Print all aliases</span>
<span class="pl-c1">alias</span> -p

<span class="pl-c"><span class="pl-c">#</span> Expressions are denoted with the following format:</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">$((</span> <span class="pl-c1">10</span> <span class="pl-k">+</span> <span class="pl-c1">5</span> <span class="pl-pds">))</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; 15</span>

<span class="pl-c"><span class="pl-c">#</span> Unlike other programming languages, bash is a shell so it works in the context</span>
<span class="pl-c"><span class="pl-c">#</span> of a current directory. You can list files and directories in the current</span>
<span class="pl-c"><span class="pl-c">#</span> directory with the ls command:</span>
ls <span class="pl-c"><span class="pl-c">#</span> Lists the files and subdirectories contained in the current directory</span>

<span class="pl-c"><span class="pl-c">#</span> This command has options that control its execution:</span>
ls -l <span class="pl-c"><span class="pl-c">#</span> Lists every file and directory on a separate line</span>
ls -t <span class="pl-c"><span class="pl-c">#</span> Sorts the directory contents by last-modified date (descending)</span>
ls -R <span class="pl-c"><span class="pl-c">#</span> Recursively `ls` this directory and all of its subdirectories</span>

<span class="pl-c"><span class="pl-c">#</span> Results (stdout) of the previous command can be passed as input (stdin) to the next command</span>
<span class="pl-c"><span class="pl-c">#</span> using a pipe |. Commands chained in this way are called a "pipeline", and are run concurrently.</span>
<span class="pl-c"><span class="pl-c">#</span> The `grep` command filters the input with provided patterns.</span>
<span class="pl-c"><span class="pl-c">#</span> That's how we can list .txt files in the current directory:</span>
ls -l <span class="pl-k">|</span> grep <span class="pl-s"><span class="pl-pds">"</span>\.txt<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> Use `cat` to print files to stdout:</span>
cat file.txt

<span class="pl-c"><span class="pl-c">#</span> We can also read the file using `cat`:</span>
Contents=<span class="pl-s"><span class="pl-pds">$(</span>cat file.txt<span class="pl-pds">)</span></span>
<span class="pl-c"><span class="pl-c">#</span> "\n" prints a new line character</span>
<span class="pl-c"><span class="pl-c">#</span> "-e" to interpret the newline escape characters as escape characters</span>
<span class="pl-c1">echo</span> -e <span class="pl-s"><span class="pl-pds">"</span>START OF FILE\n<span class="pl-smi">$Contents</span>\nEND OF FILE<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; START OF FILE</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; [contents of file.txt]</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; END OF FILE</span>

<span class="pl-c"><span class="pl-c">#</span> Use `cp` to copy files or directories from one place to another.</span>
<span class="pl-c"><span class="pl-c">#</span> `cp` creates NEW versions of the sources,</span>
<span class="pl-c"><span class="pl-c">#</span> so editing the copy won't affect the original (and vice versa).</span>
<span class="pl-c"><span class="pl-c">#</span> Note that it will overwrite the destination if it already exists.</span>
cp srcFile.txt clone.txt
cp -r srcDirectory/ dst/ <span class="pl-c"><span class="pl-c">#</span> recursively copy</span>

<span class="pl-c"><span class="pl-c">#</span> Look into `scp` or `sftp` if you plan on exchanging files between computers.</span>
<span class="pl-c"><span class="pl-c">#</span> `scp` behaves very similarly to `cp`.</span>
<span class="pl-c"><span class="pl-c">#</span> `sftp` is more interactive.</span>

<span class="pl-c"><span class="pl-c">#</span> Use `mv` to move files or directories from one place to another.</span>
<span class="pl-c"><span class="pl-c">#</span> `mv` is similar to `cp`, but it deletes the source.</span>
<span class="pl-c"><span class="pl-c">#</span> `mv` is also useful for renaming files!</span>
mv s0urc3.txt dst.txt <span class="pl-c"><span class="pl-c">#</span> sorry, l33t hackers...</span>

<span class="pl-c"><span class="pl-c">#</span> Since bash works in the context of a current directory, you might want to</span>
<span class="pl-c"><span class="pl-c">#</span> run your command in some other directory. We have cd for changing location:</span>
<span class="pl-c1">cd</span> <span class="pl-k">~</span>    <span class="pl-c"><span class="pl-c">#</span> change to home directory</span>
<span class="pl-c1">cd</span>      <span class="pl-c"><span class="pl-c">#</span> also goes to home directory</span>
<span class="pl-c1">cd</span> ..   <span class="pl-c"><span class="pl-c">#</span> go up one directory</span>
        <span class="pl-c"><span class="pl-c">#</span> (^^say, from /home/username/Downloads to /home/username)</span>
<span class="pl-c1">cd</span> /home/username/Documents   <span class="pl-c"><span class="pl-c">#</span> change to specified directory</span>
<span class="pl-c1">cd</span> <span class="pl-k">~</span>/Documents/..    <span class="pl-c"><span class="pl-c">#</span> now in home directory (if ~/Documents exists)</span>
<span class="pl-c1">cd</span> -    <span class="pl-c"><span class="pl-c">#</span> change to last directory</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; /home/username/Documents</span>

<span class="pl-c"><span class="pl-c">#</span> Use subshells to work across directories</span>
(echo <span class="pl-s"><span class="pl-pds">"</span>First, I'm here: <span class="pl-smi">$PWD</span><span class="pl-pds">"</span></span>) <span class="pl-k">&amp;&amp;</span> (cd someDir<span class="pl-k">;</span> <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Then, I'm here: <span class="pl-smi">$PWD</span><span class="pl-pds">"</span></span>)
<span class="pl-c1">pwd</span> <span class="pl-c"><span class="pl-c">#</span> still in first directory</span>

<span class="pl-c"><span class="pl-c">#</span> Use `mkdir` to create new directories.</span>
mkdir myNewDir
<span class="pl-c"><span class="pl-c">#</span> The `-p` flag causes new intermediate directories to be created as necessary.</span>
mkdir -p myNewDir/with/intermediate/directories
<span class="pl-c"><span class="pl-c">#</span> if the intermediate directories didn't already exist, running the above</span>
<span class="pl-c"><span class="pl-c">#</span> command without the `-p` flag would return an error</span>

<span class="pl-c"><span class="pl-c">#</span> You can redirect command input and output (stdin, stdout, and stderr)</span>
<span class="pl-c"><span class="pl-c">#</span> using "redirection operators". Unlike a pipe, which passes output to a command,</span>
<span class="pl-c"><span class="pl-c">#</span> a redirection operator has a command's input come from a file or stream, or</span>
<span class="pl-c"><span class="pl-c">#</span> sends its output to a file or stream.</span>

<span class="pl-c"><span class="pl-c">#</span> Read from stdin until ^EOF$ and overwrite hello.py with the lines</span>
<span class="pl-c"><span class="pl-c">#</span> between "EOF" (which are called a "here document"):</span>
cat <span class="pl-k">&gt;</span> hello.py <span class="pl-s"><span class="pl-k">&lt;&lt;</span> <span class="pl-k">EOF</span></span>
<span class="pl-s">#!/usr/bin/env python</span>
<span class="pl-s">from __future__ import print_function</span>
<span class="pl-s">import sys</span>
<span class="pl-s">print("#stdout", file=sys.stdout)</span>
<span class="pl-s">print("#stderr", file=sys.stderr)</span>
<span class="pl-s">for line in sys.stdin:</span>
<span class="pl-s">    print(line, file=sys.stdout)</span>
<span class="pl-s"><span class="pl-k">EOF</span></span>
<span class="pl-c"><span class="pl-c">#</span> Variables will be expanded if the first "EOF" is not quoted</span>

<span class="pl-c"><span class="pl-c">#</span> Run the hello.py Python script with various stdin, stdout, and</span>
<span class="pl-c"><span class="pl-c">#</span> stderr redirections:</span>
python hello.py <span class="pl-k">&lt;</span> <span class="pl-s"><span class="pl-pds">"</span>input.in<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> pass input.in as input to the script</span>

python hello.py <span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>output.out<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> redirect output from the script to output.out</span>

python hello.py <span class="pl-k">2&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>error.err<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> redirect error output to error.err</span>

python hello.py <span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>output-and-error.log<span class="pl-pds">"</span></span> <span class="pl-k">2&gt;&amp;1</span>
<span class="pl-c"><span class="pl-c">#</span> redirect both output and errors to output-and-error.log</span>
<span class="pl-c"><span class="pl-c">#</span> &amp;1 means file descriptor 1 (stdout), so 2&gt;&amp;1 redirects stderr (2) to the current</span>
<span class="pl-c"><span class="pl-c">#</span> destination of stdout (1), which has been redirected to output-and-error.log.</span>

python hello.py <span class="pl-k">&gt;</span> /dev/null <span class="pl-k">2&gt;&amp;1</span>
<span class="pl-c"><span class="pl-c">#</span> redirect all output and errors to the black hole, /dev/null, i.e., no output</span>

<span class="pl-c"><span class="pl-c">#</span> The output error will overwrite the file if it exists,</span>
<span class="pl-c"><span class="pl-c">#</span> if you want to append instead, use "&gt;&gt;":</span>
python hello.py <span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>output.out<span class="pl-pds">"</span></span> <span class="pl-k">2&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>error.err<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> Overwrite output.out, append to error.err, and count lines:</span>
info bash <span class="pl-s"><span class="pl-pds">'</span>Basic Shell Features<span class="pl-pds">'</span></span> <span class="pl-s"><span class="pl-pds">'</span>Redirections<span class="pl-pds">'</span></span> <span class="pl-k">&gt;</span> output.out <span class="pl-k">2&gt;&gt;</span> error.err
wc -l output.out error.err

<span class="pl-c"><span class="pl-c">#</span> Run a command and print its file descriptor (e.g. /dev/fd/123)</span>
<span class="pl-c"><span class="pl-c">#</span> see: man fd</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">&lt;(</span>echo <span class="pl-s"><span class="pl-pds">"</span>#helloworld<span class="pl-pds">"</span></span><span class="pl-pds">)</span></span>

<span class="pl-c"><span class="pl-c">#</span> Overwrite output.out with "#helloworld":</span>
cat <span class="pl-k">&gt;</span> output.out <span class="pl-s"><span class="pl-pds">&lt;(</span>echo <span class="pl-s"><span class="pl-pds">"</span>#helloworld<span class="pl-pds">"</span></span><span class="pl-pds">)</span></span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>#helloworld<span class="pl-pds">"</span></span> <span class="pl-k">&gt;</span> output.out
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>#helloworld<span class="pl-pds">"</span></span> <span class="pl-k">|</span> cat <span class="pl-k">&gt;</span> output.out
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>#helloworld<span class="pl-pds">"</span></span> <span class="pl-k">|</span> tee output.out <span class="pl-k">&gt;</span>/dev/null

<span class="pl-c"><span class="pl-c">#</span> Cleanup temporary files verbosely (add '-i' for interactive)</span>
<span class="pl-c"><span class="pl-c">#</span> WARNING: `rm` commands cannot be undone</span>
rm -v output.out error.err output-and-error.log
rm -r tempDir/ <span class="pl-c"><span class="pl-c">#</span> recursively delete</span>
<span class="pl-c"><span class="pl-c">#</span> You can install the `trash-cli` Python package to have `trash`</span>
<span class="pl-c"><span class="pl-c">#</span> which puts files in the system trash and doesn't delete them directly</span>
<span class="pl-c"><span class="pl-c">#</span> see https://pypi.org/project/trash-cli/ if you want to be careful</span>

<span class="pl-c"><span class="pl-c">#</span> Commands can be substituted within other commands using $( ):</span>
<span class="pl-c"><span class="pl-c">#</span> The following command displays the number of files and directories in the</span>
<span class="pl-c"><span class="pl-c">#</span> current directory.</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>There are <span class="pl-s"><span class="pl-pds">$(</span>ls <span class="pl-k">|</span> wc -l<span class="pl-pds">)</span></span> items here.<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> The same can be done using backticks `` but they can't be nested -</span>
<span class="pl-c"><span class="pl-c">#</span> the preferred way is to use $( ).</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>There are <span class="pl-s"><span class="pl-pds">`</span>ls <span class="pl-k">|</span> wc -l<span class="pl-pds">`</span></span> items here.<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> Bash uses a `case` statement that works similarly to switch in Java and C++:</span>
<span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$Variable</span><span class="pl-pds">"</span></span> <span class="pl-k">in</span>
    <span class="pl-c"><span class="pl-c">#</span> List patterns for the conditions you want to meet</span>
    0) <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>There is a zero.<span class="pl-pds">"</span></span>;;
    1) <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>There is a one.<span class="pl-pds">"</span></span>;;
    <span class="pl-k">*</span>) <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>It is not null.<span class="pl-pds">"</span></span>;;  <span class="pl-c"><span class="pl-c">#</span> match everything</span>
<span class="pl-k">esac</span>

<span class="pl-c"><span class="pl-c">#</span> `for` loops iterate for as many arguments given:</span>
<span class="pl-c"><span class="pl-c">#</span> The contents of $Variable is printed three times.</span>
<span class="pl-k">for</span> <span class="pl-smi">Variable</span> <span class="pl-k">in</span> {1..3}
<span class="pl-k">do</span>
    <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$Variable</span><span class="pl-pds">"</span></span>
<span class="pl-k">done</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; 1</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; 2</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; 3</span>


<span class="pl-c"><span class="pl-c">#</span> Or write it the "traditional for loop" way:</span>
<span class="pl-k">for</span> <span class="pl-s"><span class="pl-pds">((</span>a<span class="pl-k">=</span><span class="pl-c1">1</span>; a <span class="pl-k">&lt;=</span> <span class="pl-c1">3</span>; a<span class="pl-k">++</span><span class="pl-pds">))</span></span>
<span class="pl-k">do</span>
    <span class="pl-c1">echo</span> <span class="pl-smi">$a</span>
<span class="pl-k">done</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; 1</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; 2</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; 3</span>

<span class="pl-c"><span class="pl-c">#</span> They can also be used to act on files..</span>
<span class="pl-c"><span class="pl-c">#</span> This will run the command `cat` on file1 and file2</span>
<span class="pl-k">for</span> <span class="pl-smi">Variable</span> <span class="pl-k">in</span> file1 file2
<span class="pl-k">do</span>
    cat <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$Variable</span><span class="pl-pds">"</span></span>
<span class="pl-k">done</span>

<span class="pl-c"><span class="pl-c">#</span> ..or the output from a command</span>
<span class="pl-c"><span class="pl-c">#</span> This will `cat` the output from `ls`.</span>
<span class="pl-k">for</span> <span class="pl-smi">Output</span> <span class="pl-k">in</span> <span class="pl-s"><span class="pl-pds">$(</span>ls<span class="pl-pds">)</span></span>
<span class="pl-k">do</span>
    cat <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$Output</span><span class="pl-pds">"</span></span>
<span class="pl-k">done</span>

<span class="pl-c"><span class="pl-c">#</span> Bash can also accept patterns, like this to `cat`</span>
<span class="pl-c"><span class="pl-c">#</span> all the Markdown files in current directory</span>
<span class="pl-k">for</span> <span class="pl-smi">Output</span> <span class="pl-k">in</span> ./<span class="pl-k">*</span>.markdown
<span class="pl-k">do</span>
    cat <span class="pl-s"><span class="pl-pds">"</span><span class="pl-smi">$Output</span><span class="pl-pds">"</span></span>
<span class="pl-k">done</span>

<span class="pl-c"><span class="pl-c">#</span> while loop:</span>
<span class="pl-k">while</span> [ <span class="pl-c1">true</span> ]
<span class="pl-k">do</span>
    <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>loop body here...<span class="pl-pds">"</span></span>
    <span class="pl-c1">break</span>
<span class="pl-k">done</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; loop body here...</span>

<span class="pl-c"><span class="pl-c">#</span> You can also define functions</span>
<span class="pl-c"><span class="pl-c">#</span> Definition:</span>
<span class="pl-k">function</span> <span class="pl-en">foo</span> ()
{
    <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Arguments work just like script arguments: <span class="pl-smi">$@</span><span class="pl-pds">"</span></span>
    <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>And: <span class="pl-smi">$1</span> <span class="pl-smi">$2</span>...<span class="pl-pds">"</span></span>
    <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>This is a function<span class="pl-pds">"</span></span>
    returnValue=0    <span class="pl-c"><span class="pl-c">#</span> Variable values can be returned</span>
    <span class="pl-k">return</span> <span class="pl-smi">$returnValue</span>
}
<span class="pl-c"><span class="pl-c">#</span> Call the function `foo` with two arguments, arg1 and arg2:</span>
foo arg1 arg2
<span class="pl-c"><span class="pl-c">#</span> =&gt; Arguments work just like script arguments: arg1 arg2</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; And: arg1 arg2...</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; This is a function</span>
<span class="pl-c"><span class="pl-c">#</span> Return values can be obtained with $?</span>
resultValue=<span class="pl-smi">$?</span>
<span class="pl-c"><span class="pl-c">#</span> More than 9 arguments are also possible by using braces, e.g. ${10}, ${11}, ...</span>

<span class="pl-c"><span class="pl-c">#</span> or simply</span>
<span class="pl-en">bar</span> ()
{
    <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Another way to declare functions!<span class="pl-pds">"</span></span>
    <span class="pl-k">return</span> 0
}
<span class="pl-c"><span class="pl-c">#</span> Call the function `bar` with no arguments:</span>
bar <span class="pl-c"><span class="pl-c">#</span> =&gt; Another way to declare functions!</span>

<span class="pl-c"><span class="pl-c">#</span> Calling your function</span>
foo <span class="pl-s"><span class="pl-pds">"</span>My name is<span class="pl-pds">"</span></span> <span class="pl-smi">$Name</span>

<span class="pl-c"><span class="pl-c">#</span> There are a lot of useful commands you should learn:</span>
<span class="pl-c"><span class="pl-c">#</span> prints last 10 lines of file.txt</span>
tail -n 10 file.txt

<span class="pl-c"><span class="pl-c">#</span> prints first 10 lines of file.txt</span>
head -n 10 file.txt

<span class="pl-c"><span class="pl-c">#</span> print file.txt's lines in sorted order</span>
sort file.txt

<span class="pl-c"><span class="pl-c">#</span> report or omit repeated lines, with -d it reports them</span>
uniq -d file.txt

<span class="pl-c"><span class="pl-c">#</span> prints only the first column before the ',' character</span>
cut -d <span class="pl-s"><span class="pl-pds">'</span>,<span class="pl-pds">'</span></span> -f 1 file.txt

<span class="pl-c"><span class="pl-c">#</span> replaces every occurrence of 'okay' with 'great' in file.txt</span>
<span class="pl-c"><span class="pl-c">#</span> (regex compatible)</span>
sed -i <span class="pl-s"><span class="pl-pds">'</span>s/okay/great/g<span class="pl-pds">'</span></span> file.txt
<span class="pl-c"><span class="pl-c">#</span> be aware that this -i flag means that file.txt will be changed</span>
<span class="pl-c"><span class="pl-c">#</span> -i or --in-place erase the input file (use --in-place=.backup to keep a back-up)</span>

<span class="pl-c"><span class="pl-c">#</span> print to stdout all lines of file.txt which match some regex</span>
<span class="pl-c"><span class="pl-c">#</span> The example prints lines which begin with "foo" and end in "bar"</span>
grep <span class="pl-s"><span class="pl-pds">"</span>^foo.*bar$<span class="pl-pds">"</span></span> file.txt

<span class="pl-c"><span class="pl-c">#</span> pass the option "-c" to instead print the number of lines matching the regex</span>
grep -c <span class="pl-s"><span class="pl-pds">"</span>^foo.*bar$<span class="pl-pds">"</span></span> file.txt

<span class="pl-c"><span class="pl-c">#</span> Other useful options are:</span>
grep -r <span class="pl-s"><span class="pl-pds">"</span>^foo.*bar$<span class="pl-pds">"</span></span> someDir/ <span class="pl-c"><span class="pl-c">#</span> recursively `grep`</span>
grep -n <span class="pl-s"><span class="pl-pds">"</span>^foo.*bar$<span class="pl-pds">"</span></span> file.txt <span class="pl-c"><span class="pl-c">#</span> give line numbers</span>
grep -rI <span class="pl-s"><span class="pl-pds">"</span>^foo.*bar$<span class="pl-pds">"</span></span> someDir/ <span class="pl-c"><span class="pl-c">#</span> recursively `grep`, but ignore binary files</span>

<span class="pl-c"><span class="pl-c">#</span> perform the same initial search, but filter out the lines containing "baz"</span>
grep <span class="pl-s"><span class="pl-pds">"</span>^foo.*bar$<span class="pl-pds">"</span></span> file.txt <span class="pl-k">|</span> grep -v <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> if you literally want to search for the string,</span>
<span class="pl-c"><span class="pl-c">#</span> and not the regex, use `fgrep` (or `grep -F`)</span>
fgrep <span class="pl-s"><span class="pl-pds">"</span>foobar<span class="pl-pds">"</span></span> file.txt

<span class="pl-c"><span class="pl-c">#</span> The `trap` command allows you to execute a command whenever your script</span>
<span class="pl-c"><span class="pl-c">#</span> receives a signal. Here, `trap` will execute `rm` if it receives any of the</span>
<span class="pl-c"><span class="pl-c">#</span> three listed signals.</span>
<span class="pl-c1">trap</span> <span class="pl-s"><span class="pl-pds">"</span>rm <span class="pl-smi">$TEMP_FILE</span>; exit<span class="pl-pds">"</span></span> SIGHUP SIGINT SIGTERM

<span class="pl-c"><span class="pl-c">#</span> `sudo` is used to perform commands as the superuser</span>
<span class="pl-c"><span class="pl-c">#</span> usually it will ask interactively the password of superuser</span>
NAME1=<span class="pl-s"><span class="pl-pds">$(</span>whoami<span class="pl-pds">)</span></span>
NAME2=<span class="pl-s"><span class="pl-pds">$(</span>sudo whoami<span class="pl-pds">)</span></span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Was <span class="pl-smi">$NAME1</span>, then became more powerful <span class="pl-smi">$NAME2</span><span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> Read Bash shell built-ins documentation with the bash `help` built-in:</span>
<span class="pl-c1">help</span>
<span class="pl-c1">help</span> <span class="pl-c1">help</span>
<span class="pl-c1">help</span> <span class="pl-k">for</span>
<span class="pl-c1">help</span> <span class="pl-k">return</span>
<span class="pl-c1">help</span> <span class="pl-c1">source</span>
<span class="pl-c1">help</span> <span class="pl-c1">.</span>

<span class="pl-c"><span class="pl-c">#</span> Read Bash manpage documentation with `man`</span>
apropos bash
man 1 bash
man bash

<span class="pl-c"><span class="pl-c">#</span> Read info documentation with `info` (`?` for help)</span>
apropos info <span class="pl-k">|</span> grep <span class="pl-s"><span class="pl-pds">'</span>^info.*(<span class="pl-pds">'</span></span>
man info
info info
info 5 info

<span class="pl-c"><span class="pl-c">#</span> Read bash info documentation:</span>
info bash
info bash <span class="pl-s"><span class="pl-pds">'</span>Bash Features<span class="pl-pds">'</span></span>
info bash 6
info --apropos bash</pre></div>
<hr>
<h2>Contributors</h2>
<pre class="notranslate"><code class="notranslate">- ["Max Yankov", "https://github.com/golergka"]
- ["Darren Lin", "https://github.com/CogBear"]
- ["Alexandre Medeiros", "http://alemedeiros.sdf.org"]
- ["Denis Arh", "https://github.com/darh"]
- ["akirahirose", "https://twitter.com/akirahirose"]
- ["Anton Strömkvist", "http://lutic.org/"]
- ["Rahil Momin", "https://github.com/iamrahil"]
- ["Gregrory Kielian", "https://github.com/gskielian"]
- ["Etan Reisner", "https://github.com/deryni"]
- ["Jonathan Wang", "https://github.com/Jonathansw"]
- ["Leo Rudberg", "https://github.com/LOZORD"]
- ["Betsy Lorton", "https://github.com/schbetsy"]
- ["John Detter", "https://github.com/jdetter"]
- ["Harry Mumford-Turner", "https://github.com/harrymt"]
- ["Martin Nicholson", "https://github.com/mn113"]
- ["Mark Grimwood", "https://github.com/MarkGrimwood"]
- ["Emily Grace Seville", "https://github.com/EmilySeville7cfg"]
</code></pre>