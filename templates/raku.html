<h1>Raku</h1>
<p>Raku (formerly Perl 6) is a highly capable, feature-rich programming language<br>
made for at least the next hundred years.</p>
<p>The primary Raku compiler is called <a href="http://rakudo.org" rel="nofollow">Rakudo</a>, which runs on<br>
the JVM and the <a href="http://moarvm.com" rel="nofollow">MoarVM</a>.</p>
<p>Meta-note:</p>
<ul>
<li>Although the pound sign (<code class="notranslate">#</code>) is used for sentences and notes, Pod-styled<br>
comments (more below about them) are used whenever it's convenient.</li>
<li><code class="notranslate"># OUTPUT:</code> is used to represent the output of a command to any standard<br>
stream. If the output has a newline, it's represented by the <code class="notranslate">␤</code> symbol.<br>
The output is always enclosed by angle brackets (<code class="notranslate">«</code> and <code class="notranslate">»</code>).</li>
<li><code class="notranslate">#=&gt;</code> represents the value of an expression, return value of a sub, etc.<br>
In some cases, the value is accompanied by a comment.</li>
<li>Backticks are used to distinguish and highlight the language constructs<br>
from the text.</li>
</ul>
<div class="highlight highlight-source-raku"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 0. Comments</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> Single line comments start with a pound sign.</span>

<span class="pl-c">#`( Multiline comments use #` and a quoting construct.</span>
<span class="pl-c">  <span class="pl-c">()</span>, [], {}, 「」, etc, will work.</span>
<span class="pl-c">)</span>

<span class="pl-k">=</span><span class="pl-e">for</span> comment<span class="pl-c"></span>
<span class="pl-c">Use the same syntax for multiline comments to embed comments.</span>
<span class="pl-c">for #`(each element in) @array {</span>
<span class="pl-c">    put #`(or print element) $_ #`(with newline);</span>
<span class="pl-c">}</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">#</span> You can also use Pod-styled comments. For example:</span>

<span class="pl-k">=</span><span class="pl-e">comment</span> <span class="pl-en">This is a comment that extends until an empty</span><span class="pl-c"></span>
<span class="pl-c">newline is found.</span>
<span class="pl-c"></span>
<span class="pl-k">=</span>comment
The comment doesn't <span class="pl-k">need</span> <span class="pl-c1">to</span> <span class="pl-k">start</span> in the same line <span class="pl-k">as</span> the directive<span class="pl-k">.</span>

<span class="pl-k">=</span><span class="pl-k">begin</span> <span class="pl-e">comment</span><span class="pl-c"></span>
<span class="pl-c">This comment is multiline.</span>
<span class="pl-c"></span>
<span class="pl-c">Empty newlines can exist here too!</span>
<span class="pl-c"></span><span class="pl-k">=</span><span class="pl-k">end</span> <span class="pl-e">comment</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 1. Variables</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> In Raku, you declare a lexical variable using the `my` keyword:</span>
<span class="pl-k">my</span> $variable;

<span class="pl-c"><span class="pl-c">#</span> Raku has 3 basic types of variables: scalars, arrays, and hashes.</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 1.1 Scalars</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Scalars represent a single value. They start with the `$` sigil:</span>
<span class="pl-k">my</span> $<span class="pl-c1">str</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>String<span class="pl-pds">'</span></span>;

<span class="pl-c"><span class="pl-c">#</span> Double quotes allow for interpolation (which we'll see later):</span>
<span class="pl-k">my</span> $str2 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>$str<span class="pl-pds">"</span></span>;

<span class="pl-c"><span class="pl-c">#</span> Variable names can contain but not end with simple quotes and dashes,</span>
<span class="pl-c"><span class="pl-c">#</span> and can contain (and end with) underscores:</span>
<span class="pl-k">my</span> $person's-belongings <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>towel<span class="pl-pds">'</span></span>; <span class="pl-c"><span class="pl-c">#</span> this works!</span>

<span class="pl-k">my</span> $<span class="pl-c1">bool</span> <span class="pl-k">=</span> <span class="pl-c1">True</span>;             <span class="pl-c"><span class="pl-c">#</span> `True` and `False` are Raku's boolean values.</span>
<span class="pl-k">my</span> $inverse <span class="pl-k">=</span> <span class="pl-k">!</span>$<span class="pl-c1">bool</span>;        <span class="pl-c"><span class="pl-c">#</span> Invert a bool with the prefix `!` operator.</span>
<span class="pl-k">my</span> $forced-bool <span class="pl-k">=</span> <span class="pl-k">so</span> $<span class="pl-c1">str</span>;   <span class="pl-c"><span class="pl-c">#</span> And you can use the prefix `so` operator</span>
$forced-bool <span class="pl-k">=</span> <span class="pl-k">?</span>$<span class="pl-c1">str</span>;        <span class="pl-c"><span class="pl-c">#</span> to turn its operand into a Bool. Or use `?`.</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 1.2 Arrays and Lists</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Arrays represent multiple values. An array variable starts with the `@`</span>
<span class="pl-c"><span class="pl-c">#</span> sigil. Unlike lists, from which arrays inherit, arrays are mutable.</span>

<span class="pl-k">my</span> @array <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>;
<span class="pl-c"><span class="pl-c">#</span> equivalent to:</span>
<span class="pl-k">my</span> @letters <span class="pl-k">=</span> &lt;<span class="pl-s">a b c</span>&gt;;
<span class="pl-c"><span class="pl-c">#</span> In the previous statement, we use the quote-words (`&lt;&gt;`) term for array</span>
<span class="pl-c"><span class="pl-c">#</span> of words, delimited by space. Similar to perl's qw, or Ruby's %w.</span>

@array <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">4</span>;

<span class="pl-c"><span class="pl-c">#</span> Array indices start at 0. Here the third element is being accessed.</span>
<span class="pl-c1">say</span> @array[<span class="pl-c1">2</span>]; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «4␤»</span>

<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Interpolate an array using []: @array[]<span class="pl-pds">"</span></span>;
<span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Interpolate an array using []: 1 2 3␤»</span>

@array[<span class="pl-c1">0</span>]    <span class="pl-k">=</span> <span class="pl-c1">-1</span>;     <span class="pl-c"><span class="pl-c">#</span> Assigning a new value to an array index</span>
@array[<span class="pl-c1">0</span>, <span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">5</span>, <span class="pl-c1">6</span>;   <span class="pl-c"><span class="pl-c">#</span> Assigning multiple values</span>

<span class="pl-k">my</span> @<span class="pl-c1">keys</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>, <span class="pl-c1">2</span>;
@array[@<span class="pl-c1">keys</span>] <span class="pl-k">=</span> @letters; <span class="pl-c"><span class="pl-c">#</span> Assignment using an array containing index values</span>
<span class="pl-c1">say</span> @array;               <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «a 6 b␤»</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 1.3 Hashes, or key-value Pairs.</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Hashes are pairs of keys and values. You can construct a `Pair` object</span>
<span class="pl-c"><span class="pl-c">#</span> using the syntax `key =&gt; value`. Hash tables are very fast for lookup,</span>
<span class="pl-c"><span class="pl-c">#</span> and are stored unordered. Keep in mind that keys get "flattened" in hash</span>
<span class="pl-c"><span class="pl-c">#</span> context, and any duplicated keys are deduplicated.</span>
<span class="pl-k">my</span> <span class="pl-k">%</span>hash <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">2</span>;

<span class="pl-c"><span class="pl-c">#</span> Keys get auto-quoted when the fat comman (`=&gt;`) is used. Trailing commas are</span>
<span class="pl-c"><span class="pl-c">#</span> okay.</span>
<span class="pl-k">%</span>hash <span class="pl-k">=</span> <span class="pl-s">a </span><span class="pl-k">=&gt;</span> <span class="pl-c1">1</span>, <span class="pl-s">b </span><span class="pl-k">=&gt;</span> <span class="pl-c1">2</span>, ;

<span class="pl-c"><span class="pl-c">#</span> Even though hashes are internally stored differently than arrays,</span>
<span class="pl-c"><span class="pl-c">#</span> Raku allows you to easily create a hash from an even numbered array:</span>
<span class="pl-k">%</span>hash <span class="pl-k">=</span> &lt;<span class="pl-s">key1 value1 key2 value2</span>&gt;;          <span class="pl-c"><span class="pl-c">#</span> Or:</span>
<span class="pl-k">%</span>hash <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>key1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>value1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>key2<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>value2<span class="pl-pds">"</span></span>;

<span class="pl-k">%</span>hash <span class="pl-k">=</span> <span class="pl-s">key1 </span><span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>value1<span class="pl-pds">'</span></span>, <span class="pl-s">key2 </span><span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>value2<span class="pl-pds">'</span></span>; <span class="pl-c"><span class="pl-c">#</span> same result as above</span>

<span class="pl-c"><span class="pl-c">#</span> You can also use the "colon pair" syntax. This syntax is especially</span>
<span class="pl-c"><span class="pl-c">#</span> handy for named parameters that you'll see later.</span>
<span class="pl-k">%</span>hash <span class="pl-k">=</span> <span class="pl-k">:</span>n(<span class="pl-c1">2</span>),    <span class="pl-c"><span class="pl-c">#</span> equivalent to `n =&gt; 2`</span>
        <span class="pl-k">:</span>is-even, <span class="pl-c"><span class="pl-c">#</span> equivalent to `:is-even(True)` or `is-even =&gt; True`</span>
        <span class="pl-k">:!</span>is-odd, <span class="pl-c"><span class="pl-c">#</span> equivalent to `:is-odd(False)` or `is-odd =&gt; False`</span>
;
<span class="pl-c"><span class="pl-c">#</span> The `:` (as in `:is-even`) and `:!` (as `:!is-odd`) constructs are known</span>
<span class="pl-c"><span class="pl-c">#</span> as the `True` and `False` shortcuts respectively.</span>

<span class="pl-c"><span class="pl-c">#</span> As demonstrated in the example below, you can use {} to get the value from a key.</span>
<span class="pl-c"><span class="pl-c">#</span> If it's a string without spaces, you can actually use the quote-words operator</span>
<span class="pl-c"><span class="pl-c">#</span> (`&lt;&gt;`). Since Raku doesn't have barewords, as Perl does, `{key1}` doesn't work</span>
<span class="pl-c"><span class="pl-c">#</span> though.</span>
<span class="pl-c1">say</span> <span class="pl-k">%</span>hash{<span class="pl-s"><span class="pl-pds">'</span>n<span class="pl-pds">'</span></span>};     <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «2␤», gets value associated to key 'n'</span>
<span class="pl-c1">say</span> <span class="pl-k">%</span>hash&lt;<span class="pl-s">is-even</span>&gt;; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», gets value associated to key 'is-even'</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 2. Subroutines</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> Subroutines, or functions as most other languages call them, are</span>
<span class="pl-c"><span class="pl-c">#</span> created with the `sub` keyword.</span>
<span class="pl-k">sub</span> say-hello { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Hello, world<span class="pl-pds">"</span></span> }

<span class="pl-c"><span class="pl-c">#</span> You can provide (typed) arguments. If specified, the type will be checked</span>
<span class="pl-c"><span class="pl-c">#</span> at compile-time if possible, otherwise at runtime.</span>
<span class="pl-k">sub</span> say-hello-to( <span class="pl-c1">Str</span> $<span class="pl-c1">name</span> ) {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Hello, $name !<span class="pl-pds">"</span></span>;
}

<span class="pl-c"><span class="pl-c">#</span> A sub returns the last value of the block. Similarly, the semicolon in</span>
<span class="pl-c"><span class="pl-c">#</span> the last expression can be omitted.</span>
<span class="pl-k">sub</span> return-value { <span class="pl-c1">5</span> }
<span class="pl-c1">say</span> return-value;      <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «5␤»</span>

<span class="pl-k">sub</span> return-empty { }
<span class="pl-c1">say</span> return-empty;      <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Nil␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Some control flow structures produce a value, for instance `if`:</span>
<span class="pl-k">sub</span> return-if {
	<span class="pl-k">if</span> <span class="pl-c1">True</span> { <span class="pl-s"><span class="pl-pds">"</span>Truthy<span class="pl-pds">"</span></span> }
}
<span class="pl-c1">say</span> return-if;         <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Truthy␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Some don't, like `for`:</span>
<span class="pl-k">sub</span> return-for {
    <span class="pl-k">for</span> <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> { <span class="pl-s"><span class="pl-pds">'</span>Hi<span class="pl-pds">'</span></span> }
}
<span class="pl-c1">say</span> return-for;        <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Nil␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Positional arguments are required by default. To make them optional, use</span>
<span class="pl-c"><span class="pl-c">#</span> the `?` after the parameters' names.</span>

<span class="pl-c"><span class="pl-c">#</span> In the following example, the sub `with-optional` returns `(Any)` (Perl's</span>
<span class="pl-c"><span class="pl-c">#</span> null-like value) if no argument is passed. Otherwise, it returns its argument.</span>
<span class="pl-k">sub</span> with-optional( $arg<span class="pl-k">?</span> ) {
    $arg;
}
with-optional;     <span class="pl-c"><span class="pl-c">#</span> returns Any</span>
with-optional();   <span class="pl-c"><span class="pl-c">#</span> returns Any</span>
with-optional(<span class="pl-c1">1</span>);  <span class="pl-c"><span class="pl-c">#</span> returns 1</span>

<span class="pl-c"><span class="pl-c">#</span> You can also give provide a default value when they're not passed. Doing</span>
<span class="pl-c"><span class="pl-c">#</span> this make said parameter optional. Required parameters must come before</span>
<span class="pl-c"><span class="pl-c">#</span> optional ones.</span>

<span class="pl-c"><span class="pl-c">#</span> In the sub `greeting`, the parameter `$type` is optional.</span>
<span class="pl-k">sub</span> greeting( $<span class="pl-c1">name</span>, $type <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span> ) {
  <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>$type, $name!<span class="pl-pds">"</span></span>;
}

greeting(<span class="pl-s"><span class="pl-pds">"</span>Althea<span class="pl-pds">"</span></span>);                 <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Hello, Althea!␤»</span>
greeting(<span class="pl-s"><span class="pl-pds">"</span>Arthur<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Good morning<span class="pl-pds">"</span></span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Good morning, Arthur!␤»</span>

<span class="pl-c"><span class="pl-c">#</span> You can also, by using a syntax akin to the one of hashes (yay unified syntax!),</span>
<span class="pl-c"><span class="pl-c">#</span> declared named parameters and thus pass named arguments to a subroutine.</span>
<span class="pl-c"><span class="pl-c">#</span> By default, named parameter are optional and will default to `Any`.</span>
<span class="pl-k">sub</span> with-named( $normal-arg, <span class="pl-k">:</span>$named ) {
	<span class="pl-c1">say</span> $normal-arg <span class="pl-k">+</span> $named;
}
with-named(<span class="pl-c1">1</span>, <span class="pl-s">named </span><span class="pl-k">=&gt;</span> <span class="pl-c1">6</span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «7␤»</span>

<span class="pl-c"><span class="pl-c">#</span> There's one gotcha to be aware of, here: If you quote your key, Raku</span>
<span class="pl-c"><span class="pl-c">#</span> won't be able to see it at compile time, and you'll have a single `Pair`</span>
<span class="pl-c"><span class="pl-c">#</span> object as a positional parameter, which means the function subroutine</span>
<span class="pl-c"><span class="pl-c">#</span> `with-named(1, 'named' =&gt; 6);` fails.</span>
with-named(<span class="pl-c1">2</span>, <span class="pl-k">:</span>named(<span class="pl-c1">5</span>));  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «7␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Similar to positional parameters, you can provide your named arguments with</span>
<span class="pl-c"><span class="pl-c">#</span> default values.</span>
<span class="pl-k">sub</span> named-def( <span class="pl-k">:</span>$def <span class="pl-k">=</span> <span class="pl-c1">5</span> ) {
    <span class="pl-c1">say</span> $def;
}
named-def;            <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «5»</span>
named-def(<span class="pl-s">def </span><span class="pl-k">=&gt;</span> <span class="pl-c1">15</span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «15»</span>

<span class="pl-c"><span class="pl-c">#</span> In order to make a named parameter mandatory, you can append `!` to the</span>
<span class="pl-c"><span class="pl-c">#</span> parameter. This is the inverse of `?`, which makes a required parameter</span>
<span class="pl-c"><span class="pl-c">#</span> optional.</span>

<span class="pl-k">sub</span> with-mandatory-named( <span class="pl-k">:</span>$<span class="pl-c1">str</span><span class="pl-k">!</span> )  {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>$str!<span class="pl-pds">"</span></span>;
}
with-mandatory-named(<span class="pl-s">str </span><span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>My String<span class="pl-pds">"</span></span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «My String!␤»</span>
<span class="pl-c"><span class="pl-c">#</span> with-mandatory-named;   # runtime error: "Required named parameter not passed"</span>
<span class="pl-c"><span class="pl-c">#</span> with-mandatory-named(3);# runtime error: "Too many positional parameters passed"</span>

<span class="pl-c"><span class="pl-c">#</span> If a sub takes a named boolean argument, you can use the same "short boolean"</span>
<span class="pl-c"><span class="pl-c">#</span> hash syntax we discussed earlier.</span>
<span class="pl-k">sub</span> takes-a-bool( $<span class="pl-c1">name</span>, <span class="pl-k">:</span>$<span class="pl-c1">bool</span> ) {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>$name takes $bool<span class="pl-pds">"</span></span>;
}
takes-a-bool(<span class="pl-s"><span class="pl-pds">'</span>config<span class="pl-pds">'</span></span>, <span class="pl-k">:</span>bool);  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «config takes True␤»</span>
takes-a-bool(<span class="pl-s"><span class="pl-pds">'</span>config<span class="pl-pds">'</span></span>, <span class="pl-k">:!</span><span class="pl-c1">bool</span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «config takes False␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Since parenthesis can be omitted when calling a subroutine, you need to use</span>
<span class="pl-c"><span class="pl-c">#</span> `&amp;` in order to distinguish between a call to a sub with no arguments and</span>
<span class="pl-c"><span class="pl-c">#</span> the code object.</span>

<span class="pl-c"><span class="pl-c">#</span> For instance, in this example we must use `&amp;` to store the sub `say-hello`</span>
<span class="pl-c"><span class="pl-c">#</span> (i.e., the sub's code object) in a variable, not a subroutine call.</span>
<span class="pl-k">my</span> &amp;s <span class="pl-k">=</span> &amp;say-hello;
<span class="pl-k">my</span> &amp;other-s <span class="pl-k">=</span> sub { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Anonymous function!<span class="pl-pds">"</span></span> }

<span class="pl-c"><span class="pl-c">#</span> A sub can have a "slurpy" parameter, or what one'd call a</span>
<span class="pl-c"><span class="pl-c">#</span> "doesn't-matter-how-many" parameter. This is Raku's way of supporting variadic</span>
<span class="pl-c"><span class="pl-c">#</span> functions. For this, you must use `*@` (slurpy) which will "take everything</span>
<span class="pl-c"><span class="pl-c">#</span> else". You can have as many parameters *before* a slurpy one, but not *after*.</span>
<span class="pl-k">sub</span> as-many($head, <span class="pl-k">*</span>@rest) {
    @rest<span class="pl-k">.</span><span class="pl-c1">join</span>(<span class="pl-s"><span class="pl-pds">'</span> / <span class="pl-pds">'</span></span>) <span class="pl-k">~</span> <span class="pl-s"><span class="pl-pds">"</span> !<span class="pl-pds">"</span></span>;
}
<span class="pl-c1">say</span> as-many(<span class="pl-s"><span class="pl-pds">'</span>Happy<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>Happy<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>Birthday<span class="pl-pds">'</span></span>);          <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Happy / Birthday !␤»</span>
<span class="pl-c1">say</span> as-many(<span class="pl-s"><span class="pl-pds">'</span>Happy<span class="pl-pds">'</span></span>, [<span class="pl-s"><span class="pl-pds">'</span>Happy<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>Birthday<span class="pl-pds">'</span></span>], <span class="pl-s"><span class="pl-pds">'</span>Day<span class="pl-pds">'</span></span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Happy / Birthday / Day !␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Note that the splat (the *) did not consume the parameter before it.</span>

<span class="pl-c"><span class="pl-c">#</span> There are other two variations of slurpy parameters in Raku. The previous one</span>
<span class="pl-c"><span class="pl-c">#</span> (namely, `*@`), known as flattened slurpy, flattens passed arguments. The other</span>
<span class="pl-c"><span class="pl-c">#</span> two are `**@` and `+@` known as unflattened slurpy and "single argument rule"</span>
<span class="pl-c"><span class="pl-c">#</span> slurpy respectively. The unflattened slurpy doesn't flatten its listy</span>
<span class="pl-c"><span class="pl-c">#</span> arguments (or Iterable ones).</span>
<span class="pl-k">sub</span> b(<span class="pl-k">**</span>@arr) { @arr<span class="pl-k">.</span><span class="pl-c1">perl</span><span class="pl-k">.</span><span class="pl-c1">say</span> };
b([<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>]);             <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «[["a", "b", "c"],]»</span>
b(<span class="pl-c1">1</span>, <span class="pl-k">$</span>(<span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>f<span class="pl-pds">'</span></span>), [<span class="pl-c1">2</span>, <span class="pl-c1">3</span>]); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «[1, ("d", "e", "f"), [2, 3]]»</span>
b(<span class="pl-c1">1</span>, [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>], ([<span class="pl-c1">3</span>, <span class="pl-c1">4</span>], <span class="pl-c1">5</span>));      <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»</span>

<span class="pl-c"><span class="pl-c">#</span> On the other hand, the "single argument rule" slurpy follows the "single argument</span>
<span class="pl-c"><span class="pl-c">#</span> rule" which dictates how to handle the slurpy argument based upon context and</span>
<span class="pl-c"><span class="pl-c">#</span> roughly states that if only a single argument is passed and that argument is</span>
<span class="pl-c"><span class="pl-c">#</span> Iterable, that argument is used to fill the slurpy parameter array. In any</span>
<span class="pl-c"><span class="pl-c">#</span> other case, `+@` works like `**@`.</span>
<span class="pl-k">sub</span> c(<span class="pl-k">+</span>@arr) { @arr<span class="pl-k">.</span><span class="pl-c1">perl</span><span class="pl-k">.</span><span class="pl-c1">say</span> };
c([<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>]);             <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «["a", "b", "c"]␤»</span>
c(<span class="pl-c1">1</span>, <span class="pl-k">$</span>(<span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>f<span class="pl-pds">'</span></span>), [<span class="pl-c1">2</span>, <span class="pl-c1">3</span>]); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «[1, ("d", "e", "f"), [2, 3]]␤»</span>
c(<span class="pl-c1">1</span>, [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>], ([<span class="pl-c1">3</span>, <span class="pl-c1">4</span>], <span class="pl-c1">5</span>));      <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»</span>

<span class="pl-c"><span class="pl-c">#</span> You can call a function with an array using the "argument list flattening"</span>
<span class="pl-c"><span class="pl-c">#</span> operator `|` (it's not actually the only role of this operator,</span>
<span class="pl-c"><span class="pl-c">#</span> but it's one of them).</span>
<span class="pl-k">sub</span> concat3($a, $b, $c) {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>$a, $b, $c<span class="pl-pds">"</span></span>;
}
concat3(<span class="pl-k">|</span>@array); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «a, b, c␤»</span>
                  <span class="pl-c"><span class="pl-c">#</span> `@array` got "flattened" as a part of the argument list</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 3. Containers</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> In Raku, values are actually stored in "containers". The assignment</span>
<span class="pl-c"><span class="pl-c">#</span> operator asks the container on the left to store the value on its right.</span>
<span class="pl-c"><span class="pl-c">#</span> When passed around, containers are marked as immutable which means that,</span>
<span class="pl-c"><span class="pl-c">#</span> in a function, you'll get an error if you try to mutate one of your</span>
<span class="pl-c"><span class="pl-c">#</span> arguments. If you really need to, you can ask for a mutable container by</span>
<span class="pl-c"><span class="pl-c">#</span> using the `is rw` trait.</span>
<span class="pl-k">sub</span> mutate( $n <span class="pl-k">is</span> <span class="pl-en">rw</span> ) {
    $n<span class="pl-k">++</span>; <span class="pl-c"><span class="pl-c">#</span> postfix ++ operator increments its argument but returns its old value</span>
}
<span class="pl-k">my</span> $m <span class="pl-k">=</span> <span class="pl-c1">42</span>;
mutate $m; <span class="pl-c"><span class="pl-c">#</span>=&gt; 42, the value is incremented but the old value is returned</span>
<span class="pl-c1">say</span> $m;    <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «43␤»</span>

<span class="pl-c"><span class="pl-c">#</span> This works because we are passing the container $m to the `mutate` sub.</span>
<span class="pl-c"><span class="pl-c">#</span> If we try to just pass a number instead of passing a variable, it won't work</span>
<span class="pl-c"><span class="pl-c">#</span> because there is no container being passed and integers are immutable by</span>
<span class="pl-c"><span class="pl-c">#</span> themselves:</span>

<span class="pl-c"><span class="pl-c">#</span> mutate 42; # Parameter '$n' expected a writable container, but got Int value</span>

<span class="pl-c"><span class="pl-c">#</span> Similar error would be obtained, if a bound variable is passed to</span>
<span class="pl-c"><span class="pl-c">#</span> to the subroutine. In Raku, you bind a value to a variable using the binding</span>
<span class="pl-c"><span class="pl-c">#</span> operator `:=`.</span>
<span class="pl-k">my</span> $v <span class="pl-k">:=</span> <span class="pl-c1">50</span>; <span class="pl-c"><span class="pl-c">#</span> binding 50 to the variable $v</span>
<span class="pl-c"><span class="pl-c">#</span> mutate $v;   # Parameter '$n' expected a writable container, but got Int value</span>

<span class="pl-c"><span class="pl-c">#</span> If what you want is a copy instead, use the `is copy` trait which will</span>
<span class="pl-c"><span class="pl-c">#</span> cause the argument to be copied and allow you to modify the argument</span>
<span class="pl-c"><span class="pl-c">#</span> inside the routine without modifying the passed argument.</span>

<span class="pl-c"><span class="pl-c">#</span> A sub itself returns a container, which means it can be marked as `rw`.</span>
<span class="pl-c"><span class="pl-c">#</span> Alternatively, you can explicitly mark the returned container as mutable</span>
<span class="pl-c"><span class="pl-c">#</span> by using `return-rw` instead of `return`.</span>
<span class="pl-k">my</span> $<span class="pl-k">x</span> <span class="pl-k">=</span> <span class="pl-c1">42</span>;
<span class="pl-k">my</span> $y <span class="pl-k">=</span> <span class="pl-c1">45</span>;
<span class="pl-k">sub</span> x-store <span class="pl-k">is</span> <span class="pl-en">rw</span> { $<span class="pl-k">x</span> }
<span class="pl-k">sub</span> y-store       { <span class="pl-k">return-rw</span> $y }

<span class="pl-c"><span class="pl-c">#</span> In this case, the parentheses are mandatory or else Raku thinks that</span>
<span class="pl-c"><span class="pl-c">#</span> `x-store` and `y-store` are identifiers.</span>
x-store() <span class="pl-k">=</span> <span class="pl-c1">52</span>;
y-store() <span class="pl-k">*=</span> <span class="pl-c1">2</span>;

<span class="pl-c1">say</span> $<span class="pl-k">x</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «52␤»</span>
<span class="pl-c1">say</span> $y; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «90␤»</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 4.Control Flow Structures</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 4.1 if/if-else/if-elsif-else/unless</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Before talking about `if`, we need to know which values are "truthy"</span>
<span class="pl-c"><span class="pl-c">#</span> (represent `True`), and which are "falsey" (represent `False`). Only these</span>
<span class="pl-c"><span class="pl-c">#</span> values are falsey: 0, (), {}, "", Nil, a type (like `Str`, `Int`, etc.) and</span>
<span class="pl-c"><span class="pl-c">#</span> of course, `False` itself. Any other value is truthy.</span>
<span class="pl-k">my</span> $number <span class="pl-k">=</span> <span class="pl-c1">5</span>;
<span class="pl-k">if</span> $number <span class="pl-k">&lt;</span> <span class="pl-c1">5</span> {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Number is less than 5<span class="pl-pds">"</span></span>
}
<span class="pl-k">elsif</span> $number <span class="pl-k">==</span> <span class="pl-c1">5</span> {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Number is equal to 5<span class="pl-pds">"</span></span>
}
<span class="pl-k">else</span> {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Number is greater than 5<span class="pl-pds">"</span></span>
}

<span class="pl-k">unless</span> <span class="pl-c1">False</span> {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>It's not false!<span class="pl-pds">"</span></span>;
}

<span class="pl-c"><span class="pl-c">#</span> `unless` is the equivalent of `if not (X)` which inverts the sense of a</span>
<span class="pl-c"><span class="pl-c">#</span> conditional statement. However, you cannot use `else` or `elsif` with it.</span>

<span class="pl-c"><span class="pl-c">#</span> As you can see, you don't need parentheses around conditions. However, you</span>
<span class="pl-c"><span class="pl-c">#</span> do need the curly braces around the "body" block. For example,</span>
<span class="pl-c"><span class="pl-c">#</span> `if (True) say 'It's true';` doesn't work.</span>

<span class="pl-c"><span class="pl-c">#</span> You can also use their statement modifier (postfix) versions:</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Quite truthy<span class="pl-pds">"</span></span> <span class="pl-k">if</span> <span class="pl-c1">True</span>;      <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Quite truthy␤»</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Quite falsey<span class="pl-pds">"</span></span> <span class="pl-k">unless</span> <span class="pl-c1">False</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Quite falsey␤»</span>

<span class="pl-c"><span class="pl-c">#</span> The ternary operator (`??..!!`) is structured as follows `condition ??</span>
<span class="pl-c"><span class="pl-c">#</span> expression1 !! expression2` and it returns expression1 if the condition is</span>
<span class="pl-c"><span class="pl-c">#</span> true. Otherwise, it returns expression2.</span>
<span class="pl-k">my</span> $age <span class="pl-k">=</span> <span class="pl-c1">30</span>;
<span class="pl-c1">say</span> $age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span> <span class="pl-k">??</span> <span class="pl-s"><span class="pl-pds">"</span>You are an adult<span class="pl-pds">"</span></span> <span class="pl-k">!!</span> <span class="pl-s"><span class="pl-pds">"</span>You are under 18<span class="pl-pds">"</span></span>;
<span class="pl-c"><span class="pl-c">#</span> OUTPUT: «You are an adult␤»</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 4.2 with/with-else/with-orwith-else/without</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> The `with` statement is like `if`, but it tests for definedness rather than</span>
<span class="pl-c"><span class="pl-c">#</span> truth, and it topicalizes on the condition, much like `given` which will</span>
<span class="pl-c"><span class="pl-c">#</span> be discussed later.</span>
<span class="pl-k">my</span> $s <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>raku<span class="pl-pds">"</span></span>;
<span class="pl-k">with</span>   $s<span class="pl-k">.</span><span class="pl-c1">index</span>(<span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>) { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Found a at $_<span class="pl-pds">"</span></span>      }
<span class="pl-k">orwith</span> $s<span class="pl-k">.</span><span class="pl-c1">index</span>(<span class="pl-s"><span class="pl-pds">"</span>k<span class="pl-pds">"</span></span>) { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Found c at $_<span class="pl-pds">"</span></span>      }
<span class="pl-k">else</span>                 { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Didn't find r or k<span class="pl-pds">"</span></span> }

<span class="pl-c"><span class="pl-c">#</span> Similar to `unless` that checks un-truthiness, you can use `without` to</span>
<span class="pl-c"><span class="pl-c">#</span> check for undefined-ness.</span>
<span class="pl-k">my</span> $input01;
<span class="pl-k">without</span> $input01 {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>No input given.<span class="pl-pds">"</span></span>
}
<span class="pl-c"><span class="pl-c">#</span> OUTPUT: «No input given.␤»</span>

<span class="pl-c"><span class="pl-c">#</span> There are also statement modifier versions for both `with` and `without`.</span>
<span class="pl-k">my</span> $input02 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>Hello<span class="pl-pds">'</span></span>;
<span class="pl-c1">say</span> $input02 <span class="pl-k">with</span> $input02;               <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Hello␤»</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>No input given.<span class="pl-pds">"</span></span> <span class="pl-k">without</span> $input02;

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 4.3 given/when, or Raku's switch construct</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-k">=</span><span class="pl-k">begin</span> <span class="pl-e">comment</span><span class="pl-c"></span>
<span class="pl-c">`given...when` looks like other languages' `switch`, but is much more</span>
<span class="pl-c">powerful thanks to smart matching and Raku's "topic variable", `$_`.</span>
<span class="pl-c"></span>
<span class="pl-c">The topic variable `$_ `contains the default argument of a block, a loop's</span>
<span class="pl-c">current iteration (unless explicitly named), etc.</span>
<span class="pl-c"></span>
<span class="pl-c">`given` simply puts its argument into `$_` (like a block would do),</span>
<span class="pl-c"> and `when` compares it using the "smart matching" (`~~`) operator.</span>
<span class="pl-c"></span>
<span class="pl-c">Since other Raku constructs use this variable (as said before, like `for`,</span>
<span class="pl-c">blocks, `with` statement etc), this means the powerful `when` is not only</span>
<span class="pl-c">applicable along with a `given`, but instead anywhere a `$_` exists.</span>
<span class="pl-c"></span>
<span class="pl-c"></span><span class="pl-k">=</span><span class="pl-k">end</span> <span class="pl-e">comment</span>

<span class="pl-k">given</span> <span class="pl-s"><span class="pl-pds">"</span>foo bar<span class="pl-pds">"</span></span> {
    <span class="pl-c1">say</span> <span class="pl-k">$_</span>;            <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «foo bar␤»</span>

    <span class="pl-c"><span class="pl-c">#</span> Don't worry about smart matching yet. Just know `when` uses it. This is</span>
    <span class="pl-c"><span class="pl-c">#</span> equivalent to `if $_ ~~ /foo/`.</span>
    <span class="pl-k">when</span> /<span class="pl-sr">foo</span>/ {
        <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Yay !<span class="pl-pds">"</span></span>;
    }

    <span class="pl-c"><span class="pl-c">#</span> smart matching anything with `True` is `True`, i.e. (`$a ~~ True`)</span>
    <span class="pl-c"><span class="pl-c">#</span> so you can also put "normal" conditionals. For example, this `when` is</span>
    <span class="pl-c"><span class="pl-c">#</span> equivalent to this `if`: `if $_ ~~ ($_.chars &gt; 50) {...}`</span>
    <span class="pl-c"><span class="pl-c">#</span> which means: `if $_.chars &gt; 50 {...}`</span>
    <span class="pl-k">when</span> <span class="pl-k">$_</span><span class="pl-k">.</span><span class="pl-c1">chars</span> <span class="pl-k">&gt;</span> <span class="pl-c1">50</span> {
        <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Quite a long string !<span class="pl-pds">"</span></span>;
    }

    <span class="pl-c"><span class="pl-c">#</span> same as `when *` (using the Whatever Star)</span>
    <span class="pl-k">default</span> {
        <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Something else<span class="pl-pds">"</span></span>
    }
}

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 4.4 Looping constructs</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> The `loop` construct is an infinite loop if you don't pass it arguments, but</span>
<span class="pl-c"><span class="pl-c">#</span> can also be a C-style `for` loop:</span>
<span class="pl-k">loop</span> {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>This is an infinite loop !<span class="pl-pds">"</span></span>;
    <span class="pl-k">last</span>;
}
<span class="pl-c"><span class="pl-c">#</span> In the previous example, `last` breaks out of the loop very much</span>
<span class="pl-c"><span class="pl-c">#</span> like the `break` keyword in other languages.</span>

<span class="pl-c"><span class="pl-c">#</span> The `next` keyword skips to the next iteration, like `continue` in other</span>
<span class="pl-c"><span class="pl-c">#</span> languages. Note that you can also use postfix conditionals, loops, etc.</span>
<span class="pl-k">loop</span> (<span class="pl-k">my</span> $i <span class="pl-k">=</span> <span class="pl-c1">0</span>; $i <span class="pl-k">&lt;</span> <span class="pl-c1">5</span>; $i<span class="pl-k">++</span>) {
    <span class="pl-k">next</span> <span class="pl-k">if</span> $i <span class="pl-k">==</span> <span class="pl-c1">3</span>;
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>This is a C-style for loop!<span class="pl-pds">"</span></span>;
}

<span class="pl-c"><span class="pl-c">#</span> The `for` constructs iterates over a list of elements.</span>
<span class="pl-k">my</span> @odd-array <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">5</span>, <span class="pl-c1">7</span>, <span class="pl-c1">9</span>;

<span class="pl-c"><span class="pl-c">#</span> Accessing the array's elements with the topic variable $_.</span>
<span class="pl-k">for</span> @odd-array {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>I've got $_ !<span class="pl-pds">"</span></span>;
}

<span class="pl-c"><span class="pl-c">#</span> Accessing the array's elements with a "pointy block", `-&gt;`.</span>
<span class="pl-c"><span class="pl-c">#</span> Here each element is read-only.</span>
<span class="pl-k">for</span> @odd-array <span class="pl-k">-&gt;</span> $variable {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>I've got $variable !<span class="pl-pds">"</span></span>;
}

<span class="pl-c"><span class="pl-c">#</span> Accessing the array's elements with a "doubly pointy block", `&lt;-&gt;`.</span>
<span class="pl-c"><span class="pl-c">#</span> Here each element is read-write so mutating `$variable` mutates</span>
<span class="pl-c"><span class="pl-c">#</span> that element in the array.</span>
<span class="pl-k">for</span> @odd-array &lt;<span class="pl-s">-</span>&gt; $variable {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>I've got $variable !<span class="pl-pds">"</span></span>;
}

<span class="pl-c"><span class="pl-c">#</span> As we saw with `given`, a `for` loop's default "current iteration" variable</span>
<span class="pl-c"><span class="pl-c">#</span> is `$_`. That means you can use `when` in a `for`loop just like you were</span>
<span class="pl-c"><span class="pl-c">#</span> able to in a `given`.</span>
<span class="pl-k">for</span> @odd-array {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>I've got $_<span class="pl-pds">"</span></span>;

    <span class="pl-c"><span class="pl-c">#</span> This is also allowed. A dot call with no "topic" (receiver) is sent to</span>
    <span class="pl-c"><span class="pl-c">#</span> `$_` (topic variable) by default.</span>
    <span class="pl-k">.</span><span class="pl-c1">say</span>;

    <span class="pl-c"><span class="pl-c">#</span> This is equivalent to the above statement.</span>
    <span class="pl-k">$_</span><span class="pl-k">.</span><span class="pl-c1">say</span>;
}

<span class="pl-k">for</span> @odd-array {
    <span class="pl-c"><span class="pl-c">#</span> You can...</span>
    <span class="pl-k">next</span> <span class="pl-k">if</span> <span class="pl-k">$_</span> <span class="pl-k">==</span> <span class="pl-c1">3</span>; <span class="pl-c"><span class="pl-c">#</span> Skip to the next iteration (`continue` in C-like lang.)</span>
    <span class="pl-k">redo</span> <span class="pl-k">if</span> <span class="pl-k">$_</span> <span class="pl-k">==</span> <span class="pl-c1">4</span>; <span class="pl-c"><span class="pl-c">#</span> Re-do iteration, keeping the same topic variable (`$_`)</span>
    <span class="pl-k">last</span> <span class="pl-k">if</span> <span class="pl-k">$_</span> <span class="pl-k">==</span> <span class="pl-c1">5</span>; <span class="pl-c"><span class="pl-c">#</span> Or break out of loop (like `break` in C-like lang.)</span>
}

<span class="pl-c"><span class="pl-c">#</span> The "pointy block" syntax isn't specific to the `for` loop. It's just a way</span>
<span class="pl-c"><span class="pl-c">#</span> to express a block in Raku.</span>
<span class="pl-k">sub</span> long-computation { <span class="pl-s"><span class="pl-pds">"</span>Finding factors of large primes<span class="pl-pds">"</span></span> }
<span class="pl-k">if</span> <span class="pl-c1">long</span>-computation() <span class="pl-k">-&gt;</span> $result {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>The result is $result.<span class="pl-pds">"</span></span>;
}

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 5. Operators</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-k">=</span><span class="pl-k">begin</span> <span class="pl-e">comment</span><span class="pl-c"></span>
<span class="pl-c">Since Perl languages are very much operator-based languages, Raku</span>
<span class="pl-c">operators are actually just funny-looking subroutines, in syntactic</span>
<span class="pl-c">categories, like infix:&lt;+&gt; (addition) or prefix:&lt;!&gt; (bool not).</span>
<span class="pl-c"></span>
<span class="pl-c">The categories are:</span>
<span class="pl-c">    - "prefix": before (like `!` in `!True`).</span>
<span class="pl-c">    - "postfix": after (like `++` in `$a++`).</span>
<span class="pl-c">    - "infix": in between (like `*` in `4 * 3`).</span>
<span class="pl-c">    - "circumfix": around (like `[`-`]` in `[1, 2]`).</span>
<span class="pl-c">    - "post-circumfix": around, after another term (like `{`-`}` in</span>
<span class="pl-c">                   `%hash{'key'}`)</span>
<span class="pl-c"></span>
<span class="pl-c">The associativity and precedence list are explained below.</span>
<span class="pl-c"></span>
<span class="pl-c">Alright, you're set to go!</span>
<span class="pl-c"></span>
<span class="pl-c"></span><span class="pl-k">=</span><span class="pl-k">end</span> <span class="pl-e">comment</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 5.1 Equality Checking</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> `==` is numeric comparison</span>
<span class="pl-c1">say</span> <span class="pl-c1">3</span> <span class="pl-k">==</span> <span class="pl-c1">4</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>
<span class="pl-c1">say</span> <span class="pl-c1">3</span> <span class="pl-k">!=</span> <span class="pl-c1">4</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>

<span class="pl-c"><span class="pl-c">#</span> `eq` is string comparison</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span> <span class="pl-k">eq</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span> <span class="pl-k">ne</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», not equal</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span> <span class="pl-k">!</span><span class="pl-k">eq</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», same as above</span>

<span class="pl-c"><span class="pl-c">#</span> `eqv` is canonical equivalence (or "deep equality")</span>
<span class="pl-c1">say</span> (<span class="pl-c1">1</span>, <span class="pl-c1">2</span>) <span class="pl-k">eqv</span> (<span class="pl-c1">1</span>, <span class="pl-c1">3</span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>
<span class="pl-c1">say</span> (<span class="pl-c1">1</span>, <span class="pl-c1">2</span>) <span class="pl-k">eqv</span> (<span class="pl-c1">1</span>, <span class="pl-c1">2</span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>
<span class="pl-c1">say</span> <span class="pl-c1">Int</span> <span class="pl-k">===</span> <span class="pl-c1">Int</span>;       <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>

<span class="pl-c"><span class="pl-c">#</span> `~~` is the smart match operator which aliases the left hand side to $_ and</span>
<span class="pl-c"><span class="pl-c">#</span> then evaluates the right hand side.</span>
<span class="pl-c"><span class="pl-c">#</span> Here are some common comparison semantics:</span>

<span class="pl-c"><span class="pl-c">#</span> String or numeric equality</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>Foo<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> <span class="pl-s"><span class="pl-pds">'</span>Foo<span class="pl-pds">'</span></span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», if strings are equal.</span>
<span class="pl-c1">say</span> <span class="pl-c1">12.5</span> <span class="pl-k">~~</span> <span class="pl-c1">12.50</span>;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», if numbers are equal.</span>

<span class="pl-c"><span class="pl-c">#</span> Regex - For matching a regular expression against the left side.</span>
<span class="pl-c"><span class="pl-c">#</span> Returns a `Match` object, which evaluates as True if regexp matches.</span>
<span class="pl-k">my</span> $obj <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr">a</span>/;
<span class="pl-c1">say</span> $obj;       <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «｢a｣␤»</span>
<span class="pl-c1">say</span> $obj<span class="pl-k">.</span><span class="pl-c1">WHAT</span>;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «(Match)␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Hashes</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>key<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> <span class="pl-k">%</span>hash; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», if key exists in hash.</span>

<span class="pl-c"><span class="pl-c">#</span> Type - Checks if left side "is of type" (can check superclasses and roles).</span>
<span class="pl-c1">say</span> <span class="pl-c1">1</span> <span class="pl-k">~~</span> <span class="pl-c1">Int</span>;       <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Smart-matching against a boolean always returns that boolean (and will warn).</span>
<span class="pl-c1">say</span> <span class="pl-c1">1</span> <span class="pl-k">~~</span> <span class="pl-c1">True</span>;        <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», smartmatch against True always matches</span>
<span class="pl-c1">say</span> <span class="pl-c1">False</span><span class="pl-k">.</span><span class="pl-k">so</span> <span class="pl-k">~~</span> <span class="pl-c1">True</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», use .so for truthiness</span>

<span class="pl-c"><span class="pl-c">#</span> General syntax is `$arg ~~ &amp;bool-returning-function;`. For a complete list</span>
<span class="pl-c"><span class="pl-c">#</span> of combinations, refer to the table at:</span>
<span class="pl-c"><span class="pl-c">#</span> https://docs.raku.org/language/operators#index-entry-smartmatch_operator</span>

<span class="pl-c"><span class="pl-c">#</span> Of course, you also use `&lt;`, `&lt;=`, `&gt;`, `&gt;=` for numeric comparison.</span>
<span class="pl-c"><span class="pl-c">#</span> Their string equivalent are also available: `lt`, `le`, `gt`, `ge`.</span>
<span class="pl-c1">say</span> <span class="pl-c1">3</span> <span class="pl-k">&gt;</span> <span class="pl-c1">4</span>;       <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>
<span class="pl-c1">say</span> <span class="pl-c1">3</span> <span class="pl-k">&gt;=</span> <span class="pl-c1">4</span>;      <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>
<span class="pl-c1">say</span> <span class="pl-c1">3</span> <span class="pl-k">&lt;</span> <span class="pl-c1">4</span>;       <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>
<span class="pl-c1">say</span> <span class="pl-c1">3</span> <span class="pl-k">&lt;=</span> <span class="pl-c1">4</span>;      <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span> <span class="pl-k">gt</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span> <span class="pl-k">ge</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span> <span class="pl-k">lt</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span> <span class="pl-k">le</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 5.2 Range constructor</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c1">say</span> <span class="pl-c1">3</span> <span class="pl-k">..</span> <span class="pl-c1">7</span>;          <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «3..7␤»,   both included.</span>
<span class="pl-c1">say</span> <span class="pl-c1">3</span> <span class="pl-k">..</span><span class="pl-k">^</span> <span class="pl-c1">7</span>;         <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «3..^7␤»,  exclude right endpoint.</span>
<span class="pl-c1">say</span> <span class="pl-c1">3</span> <span class="pl-k">^..</span> <span class="pl-c1">7</span>;         <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «3^..7␤»,  exclude left endpoint.</span>
<span class="pl-c1">say</span> <span class="pl-c1">3</span> <span class="pl-k">^..</span><span class="pl-k">^</span> <span class="pl-c1">7</span>;        <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «3^..^7␤», exclude both endpoints.</span>

<span class="pl-c"><span class="pl-c">#</span> The range 3 ^.. 7 is similar like 4 .. 7 when we only consider integers.</span>
<span class="pl-c"><span class="pl-c">#</span> But when we consider decimals:</span>

<span class="pl-c1">say</span> <span class="pl-c1">3.5</span> <span class="pl-k">~~</span> <span class="pl-c1">4</span> <span class="pl-k">..</span> <span class="pl-c1">7</span>;	 <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>
<span class="pl-c1">say</span> <span class="pl-c1">3.5</span> <span class="pl-k">~~</span> <span class="pl-c1">3</span> <span class="pl-k">^..</span> <span class="pl-c1">7</span>;	 <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»,</span>

<span class="pl-c"><span class="pl-c">#</span> This is because the range `3 ^.. 7` only excludes anything strictly</span>
<span class="pl-c"><span class="pl-c">#</span> equal to 3. Hence, it contains decimals greater than 3. This could</span>
<span class="pl-c"><span class="pl-c">#</span> mathematically be described as 3.5 ∈ (3,7] or in set notation,</span>
<span class="pl-c"><span class="pl-c">#</span> 3.5 ∈ { x | 3 &lt; x ≤ 7 }.</span>

<span class="pl-c1">say</span> <span class="pl-c1">3</span> <span class="pl-k">^..</span> <span class="pl-c1">7</span> <span class="pl-k">~~</span> <span class="pl-c1">4</span> <span class="pl-k">..</span> <span class="pl-c1">7</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>

<span class="pl-c"><span class="pl-c">#</span> This also works as a shortcut for `0..^N`:</span>
<span class="pl-c1">say</span> <span class="pl-k">^</span><span class="pl-c1">10</span>;             <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «^10␤», which means 0..^10</span>

<span class="pl-c"><span class="pl-c">#</span> This also allows us to demonstrate that Raku has lazy/infinite arrays,</span>
<span class="pl-c"><span class="pl-c">#</span> using the Whatever Star:</span>
<span class="pl-k">my</span> @natural <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">..</span><span class="pl-k">*</span>; <span class="pl-c"><span class="pl-c">#</span> 1 to Infinite! Equivalent to `1..Inf`.</span>

<span class="pl-c"><span class="pl-c">#</span> You can pass ranges as subscripts and it'll return an array of results.</span>
<span class="pl-c1">say</span> @natural[<span class="pl-k">^</span><span class="pl-c1">10</span>]; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «1 2 3 4 5 6 7 8 9 10␤», doesn't run out of memory!</span>

<span class="pl-c"><span class="pl-c">#</span> NOTE: when reading an infinite list, Raku will "reify" the elements</span>
<span class="pl-c"><span class="pl-c">#</span> it needs, then keep them in memory. They won't be calculated more than once.</span>
<span class="pl-c"><span class="pl-c">#</span> It also will never calculate more elements than that are needed.</span>

<span class="pl-c"><span class="pl-c">#</span> An array subscript can also be a closure. It'll be called with the array's</span>
<span class="pl-c"><span class="pl-c">#</span> length as the argument. The following two examples are equivalent:</span>
<span class="pl-c1">say</span> <span class="pl-c1">join</span>(<span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>, @array[<span class="pl-c1">15</span><span class="pl-k">..</span><span class="pl-c1">*</span>]);            <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «15 16 17 18 19␤»</span>
<span class="pl-c1">say</span> <span class="pl-c1">join</span>(<span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>, @array[<span class="pl-k">-&gt;</span> $n { <span class="pl-c1">15</span><span class="pl-k">..</span>$n }]); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «15 16 17 18 19␤»</span>

<span class="pl-c"><span class="pl-c">#</span> NOTE: if you try to do either of those with an infinite array, you'll</span>
<span class="pl-c"><span class="pl-c">#</span> trigger an infinite loop (your program won't finish).</span>

<span class="pl-c"><span class="pl-c">#</span> You can use that in most places you'd expect, even when assigning to an array:</span>
<span class="pl-k">my</span> @numbers <span class="pl-k">=</span> <span class="pl-k">^</span><span class="pl-c1">20</span>;

<span class="pl-c"><span class="pl-c">#</span> Here the numbers increase by 6, like an arithmetic sequence; more on the</span>
<span class="pl-c"><span class="pl-c">#</span> sequence (`...`) operator later.</span>
<span class="pl-k">my</span> @seq <span class="pl-k">=</span>  <span class="pl-c1">3</span>, <span class="pl-c1">9</span> <span class="pl-k">...</span> <span class="pl-k">*</span> <span class="pl-k">&gt;</span> <span class="pl-c1">95</span>;  <span class="pl-c"><span class="pl-c">#</span> 3 9 15 21 27 [...] 81 87 93 99;</span>

<span class="pl-c"><span class="pl-c">#</span> In this example, even though the sequence is infinite, only the 15</span>
<span class="pl-c"><span class="pl-c">#</span> needed values will be calculated.</span>
@numbers[<span class="pl-c1">5</span><span class="pl-k">..</span><span class="pl-c1">*</span>] <span class="pl-k">=</span> <span class="pl-c1">3</span>, <span class="pl-c1">9</span> <span class="pl-k">...</span> <span class="pl-k">*</span>;
<span class="pl-c1">say</span> @numbers; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «0 1 2 3 4 3 9 15 21 [...] 81 87␤», only 20 values</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 5.3 and (&amp;&amp;), or (||)</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Here `and` calls `.Bool` on both 3 and 4 and gets `True` so it returns</span>
<span class="pl-c"><span class="pl-c">#</span> 4 since both are `True`.</span>
<span class="pl-c1">say</span> (<span class="pl-c1">3</span> <span class="pl-k">and</span> <span class="pl-c1">4</span>);     <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «4␤», which is truthy.</span>
<span class="pl-c1">say</span> (<span class="pl-c1">3</span> <span class="pl-k">and</span> <span class="pl-c1">0</span>);     <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «0␤»</span>
<span class="pl-c1">say</span> (<span class="pl-c1">0</span> <span class="pl-k">and</span> <span class="pl-c1">4</span>);     <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «0␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Here `or` calls `.Bool` on `0` and `False` which are both `False`</span>
<span class="pl-c"><span class="pl-c">#</span> so it returns `False` since both are `False`.</span>
<span class="pl-c1">say</span> (<span class="pl-c1">0</span> <span class="pl-k">or</span> <span class="pl-c1">False</span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤».</span>

<span class="pl-c"><span class="pl-c">#</span> Both `and` and `or` have tighter versions which also shortcut circuits.</span>
<span class="pl-c"><span class="pl-c">#</span> They're `&amp;&amp;` and `||` respectively.</span>

<span class="pl-c"><span class="pl-c">#</span> `&amp;&amp;` returns the first operand that evaluates to `False`. Otherwise,</span>
<span class="pl-c"><span class="pl-c">#</span> it returns the last operand.</span>
<span class="pl-k">my</span> ($a, $b, $c, $d, $e) <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">False</span>, <span class="pl-c1">True</span>, <span class="pl-s"><span class="pl-pds">'</span>pi<span class="pl-pds">'</span></span>;
<span class="pl-c1">say</span> $a <span class="pl-k">&amp;&amp;</span> $b <span class="pl-k">&amp;&amp;</span> $c; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «0␤», the first falsey value</span>
<span class="pl-c1">say</span> $a <span class="pl-k">&amp;&amp;</span> $b <span class="pl-k">&amp;&amp;</span> $c; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤», the first falsey value</span>
<span class="pl-c1">say</span> $a <span class="pl-k">&amp;&amp;</span> $d <span class="pl-k">&amp;&amp;</span> $e; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «pi␤», last operand since everything before is truthy</span>

<span class="pl-c"><span class="pl-c">#</span> `||` returns the first argument that evaluates to `True`.</span>
<span class="pl-c1">say</span> $b <span class="pl-k">||</span> $a <span class="pl-k">||</span> $d; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «1␤»</span>
<span class="pl-c1">say</span> $e <span class="pl-k">||</span> $d <span class="pl-k">||</span> $a; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «pi␤»</span>

<span class="pl-c"><span class="pl-c">#</span> And because you're going to want them, you also have compound assignment</span>
<span class="pl-c"><span class="pl-c">#</span> operators:</span>
$a <span class="pl-k">*=</span> <span class="pl-c1">2</span>;        <span class="pl-c"><span class="pl-c">#</span> multiply and assignment. Equivalent to $a = $a * 2;</span>
$b <span class="pl-k">%%</span><span class="pl-k">=</span> <span class="pl-c1">5</span>;       <span class="pl-c"><span class="pl-c">#</span> divisible by and assignment. Equivalent to $b = $b %% 2;</span>
$c <span class="pl-k">div</span><span class="pl-k">=</span> <span class="pl-c1">3</span>;      <span class="pl-c"><span class="pl-c">#</span> return divisor and assignment. Equivalent to $c = $c div 3;</span>
$d <span class="pl-k">mod</span><span class="pl-k">=</span> <span class="pl-c1">4</span>;      <span class="pl-c"><span class="pl-c">#</span> return remainder and assignment. Equivalent to $d = $d mod 4;</span>
@array <span class="pl-k">.=</span> <span class="pl-c1">sort</span>; <span class="pl-c"><span class="pl-c">#</span> calls the `sort` method and assigns the result back</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 6. More on subs!</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> As we said before, Raku has *really* powerful subs. We're going</span>
<span class="pl-c"><span class="pl-c">#</span> to see a few more key concepts that make them better than in any</span>
<span class="pl-c"><span class="pl-c">#</span> other language :-).</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 6.1 Unpacking!</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Unpacking is the ability to "extract" arrays and keys</span>
<span class="pl-c"><span class="pl-c">#</span> (AKA "destructuring"). It'll work in `my`s and in parameter lists.</span>
<span class="pl-k">my</span> ($f, $g) <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">2</span>;
<span class="pl-c1">say</span> $f;                  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «1␤»</span>
<span class="pl-k">my</span> (<span class="pl-k">$</span>, <span class="pl-k">$</span>, $h) <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>; <span class="pl-c"><span class="pl-c">#</span> keep the non-interesting values anonymous (`$`)</span>
<span class="pl-c1">say</span> $h;                  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «3␤»</span>

<span class="pl-k">my</span> ($head, <span class="pl-k">*</span>@<span class="pl-c1">tail</span>) <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>; <span class="pl-c"><span class="pl-c">#</span> Yes, it's the same as with "slurpy subs"</span>
<span class="pl-k">my</span> (<span class="pl-k">*</span>@small) <span class="pl-k">=</span> <span class="pl-c1">1</span>;

<span class="pl-k">sub</span> unpack_array( @array [$fst, $snd] ) {
  <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>My first is $fst, my second is $snd! All in all, I'm @array[].<span class="pl-pds">"</span></span>;
  <span class="pl-c"><span class="pl-c">#</span> (^ remember the `[]` to interpolate the array)</span>
}
unpack_array(@<span class="pl-c1">tail</span>);
<span class="pl-c"><span class="pl-c">#</span> OUTPUT: «My first is 2, my second is 3! All in all, I'm 2 3.␤»</span>

<span class="pl-c"><span class="pl-c">#</span> If you're not using the array itself, you can also keep it anonymous,</span>
<span class="pl-c"><span class="pl-c">#</span> much like a scalar:</span>
<span class="pl-k">sub</span> first-of-array( <span class="pl-k">@</span> [$fst] ) { $fst }
first-of-array(@small); <span class="pl-c"><span class="pl-c">#</span>=&gt; 1</span>

<span class="pl-c"><span class="pl-c">#</span> However calling `first-of-array(@tail);` will throw an error ("Too many</span>
<span class="pl-c"><span class="pl-c">#</span> positional parameters passed"), which means the `@tail` has too many</span>
<span class="pl-c"><span class="pl-c">#</span> elements.</span>

<span class="pl-c"><span class="pl-c">#</span> You can also use a slurpy parameter. You could keep `*@rest` anonymous</span>
<span class="pl-c"><span class="pl-c">#</span> Here, `@rest` is `(3,)`, since `$fst` holds the `2`. This results</span>
<span class="pl-c"><span class="pl-c">#</span> since the length (.elems) of `@rest` is 1.</span>
<span class="pl-k">sub</span> slurp-in-array(<span class="pl-k">@</span> [$fst, <span class="pl-k">*</span>@rest]) {
    <span class="pl-c1">say</span> $fst <span class="pl-k">+</span> @rest<span class="pl-k">.</span><span class="pl-c1">elems</span>;
}
slurp-in-array(@<span class="pl-c1">tail</span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «3␤»</span>

<span class="pl-c"><span class="pl-c">#</span> You could even extract on a slurpy (but it's pretty useless ;-).)</span>
<span class="pl-k">sub</span> fst(<span class="pl-k">*</span><span class="pl-k">@</span> [$fst]) { <span class="pl-c"><span class="pl-c">#</span> or simply: `sub fst($fst) { ... }`</span>
    <span class="pl-c1">say</span> $fst;
}
fst(<span class="pl-c1">1</span>);    <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «1␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Calling `fst(1, 2);` will throw an error ("Too many positional parameters</span>
<span class="pl-c"><span class="pl-c">#</span> passed") though. After all, the `fst` sub declares only a single positional</span>
<span class="pl-c"><span class="pl-c">#</span> parameter.</span>

<span class="pl-c"><span class="pl-c">#</span> You can also destructure hashes (and classes, which you'll learn about later).</span>
<span class="pl-c"><span class="pl-c">#</span> The syntax is basically the same as</span>
<span class="pl-c"><span class="pl-c">#</span> `%hash-name (:key($variable-to-store-value-in))`.</span>
<span class="pl-c"><span class="pl-c">#</span> The hash can stay anonymous if you only need the values you extracted.</span>

<span class="pl-c"><span class="pl-c">#</span> In order to call the function, you must supply a hash wither created with</span>
<span class="pl-c"><span class="pl-c">#</span> curly braces or with `%()` (recommended). Alternatively, you can pass</span>
<span class="pl-c"><span class="pl-c">#</span> a variable that contains a hash.</span>

<span class="pl-k">sub</span> key-of(<span class="pl-k"> %</span> (<span class="pl-k">:</span>value($val), <span class="pl-k">:</span>qua($qua)) ) {
 	<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Got value $val, $qua time<span class="pl-pds">"</span></span> <span class="pl-k">~~</span>
        $qua <span class="pl-k">==</span> <span class="pl-c1">1</span> <span class="pl-k">??</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span> <span class="pl-k">!!</span> <span class="pl-s"><span class="pl-pds">'</span>s<span class="pl-pds">'</span></span>;
}

<span class="pl-k">my</span> <span class="pl-k">%</span>foo-once <span class="pl-k">=</span> <span class="pl-k">%</span>(<span class="pl-s">value </span><span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span>, <span class="pl-s">qua </span><span class="pl-k">=&gt;</span> <span class="pl-c1">1</span>);
key-of({<span class="pl-s">value </span><span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span>, <span class="pl-s">qua </span><span class="pl-k">=&gt;</span> <span class="pl-c1">2</span>});  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Got val foo, 2 times.␤»</span>
key-of(<span class="pl-k">%</span>(<span class="pl-s">value </span><span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span>, <span class="pl-s">qua </span><span class="pl-k">=&gt;</span> <span class="pl-c1">0</span>)); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Got val foo, 0 times.␤»</span>
key-of(%foo-once);                   <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Got val foo, 1 time.␤»</span>

<span class="pl-c"><span class="pl-c">#</span> The last expression of a sub is returned automatically (though you may</span>
<span class="pl-c"><span class="pl-c">#</span> indicate explicitly by using the `return` keyword, of course):</span>
<span class="pl-k">sub</span> next-index( $n ) {
 	$n <span class="pl-k">+</span> <span class="pl-c1">1</span>;
}
<span class="pl-k">my</span> $new-n <span class="pl-k">=</span> next-index(<span class="pl-c1">3</span>); <span class="pl-c"><span class="pl-c">#</span> $new-n is now 4</span>

<span class="pl-c"><span class="pl-c">#</span> This is true for everything, except for the looping constructs (due to</span>
<span class="pl-c"><span class="pl-c">#</span> performance reasons): there's no reason to build a list if we're just going to</span>
<span class="pl-c"><span class="pl-c">#</span> discard all the results. If you still want to build one, you can use the</span>
<span class="pl-c"><span class="pl-c">#</span> `do` statement prefix or the `gather` prefix, which we'll see later:</span>

<span class="pl-k">sub</span> list-of( $n ) {
 	<span class="pl-k">do</span> <span class="pl-k">for</span> <span class="pl-k">^</span>$n { <span class="pl-k">$_</span> }
}
<span class="pl-k">my</span> @list3 <span class="pl-k">=</span> list-of(<span class="pl-c1">3</span>); <span class="pl-c"><span class="pl-c">#</span>=&gt; (0, 1, 2)</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 6.2 Lambdas (or anonymous subroutines)</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> You can create a lambda by using a pointy block (`-&gt; {}`), a</span>
<span class="pl-c"><span class="pl-c">#</span> block (`{}`) or creating a `sub` without a name.</span>

<span class="pl-k">my</span> &amp;lambda1 <span class="pl-k">=</span> <span class="pl-k">-&gt;</span> $argument {
	<span class="pl-s"><span class="pl-pds">"</span>The argument passed to this lambda is $argument<span class="pl-pds">"</span></span>
}

<span class="pl-k">my</span> &amp;lambda2 <span class="pl-k">=</span> {
	<span class="pl-s"><span class="pl-pds">"</span>The argument passed to this lambda is $_<span class="pl-pds">"</span></span>
}

<span class="pl-k">my</span> &amp;lambda3 <span class="pl-k">=</span> sub ($argument) {
	<span class="pl-s"><span class="pl-pds">"</span>The argument passed to this lambda is $argument<span class="pl-pds">"</span></span>
}

<span class="pl-c"><span class="pl-c">#</span> Both pointy blocks and blocks are pretty much the same thing, except that</span>
<span class="pl-c"><span class="pl-c">#</span> the former can take arguments, and that the latter can be mistaken as</span>
<span class="pl-c"><span class="pl-c">#</span> a hash by the parser. That being said, blocks can declare what's known</span>
<span class="pl-c"><span class="pl-c">#</span> as placeholders parameters through the twigils `$^` (for positional</span>
<span class="pl-c"><span class="pl-c">#</span> parameters) and `$:` (for named parameters). More on them later on.</span>

<span class="pl-k">my</span> &amp;mult <span class="pl-k">=</span> { $<span class="pl-k">^</span>numbers <span class="pl-k">*</span> $<span class="pl-k">:</span>times }
<span class="pl-c1">say</span> mult <span class="pl-c1">4</span>, <span class="pl-k">:</span>times(<span class="pl-c1">6</span>); <span class="pl-c"><span class="pl-c">#</span>=&gt; «24␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Both pointy blocks and blocks are quite versatile when working with functions</span>
<span class="pl-c"><span class="pl-c">#</span> that accepts other functions such as `map`, `grep`, etc. For example,</span>
<span class="pl-c"><span class="pl-c">#</span> we add 3 to each value of an array using the `map` function with a lambda:</span>
<span class="pl-k">my</span> @nums <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">..</span><span class="pl-c1">4</span>;
<span class="pl-k">my</span> @res1 <span class="pl-k">=</span> <span class="pl-c1">map</span> <span class="pl-k">-&gt;</span> $v { $v <span class="pl-k">+</span> <span class="pl-c1">3</span> }, @nums; <span class="pl-c"><span class="pl-c">#</span> pointy block, explicit parameter</span>
<span class="pl-k">my</span> @res2 <span class="pl-k">=</span> <span class="pl-c1">map</span> { <span class="pl-k">$_</span> <span class="pl-k">+</span> <span class="pl-c1">3</span> },       @nums; <span class="pl-c"><span class="pl-c">#</span> block using an implicit parameter</span>
<span class="pl-k">my</span> @res3 <span class="pl-k">=</span> <span class="pl-c1">map</span> { $<span class="pl-k">^</span>val <span class="pl-k">+</span> <span class="pl-c1">3</span> },    @nums; <span class="pl-c"><span class="pl-c">#</span> block with placeholder parameter</span>

<span class="pl-c"><span class="pl-c">#</span> A sub (`sub {}`) has different semantics than a block (`{}` or `-&gt; {}`):</span>
<span class="pl-c"><span class="pl-c">#</span> A block doesn't have a "function context" (though it can have arguments),</span>
<span class="pl-c"><span class="pl-c">#</span> which means that if you return from it, you're going to return from the</span>
<span class="pl-c"><span class="pl-c">#</span> parent function.</span>

<span class="pl-c"><span class="pl-c">#</span> Compare:</span>
<span class="pl-k">sub</span> is-in( @array, $elem ) {
   <span class="pl-c1">say</span> <span class="pl-c1">map</span>({ <span class="pl-k">return</span> <span class="pl-c1">True</span> <span class="pl-k">if</span> <span class="pl-k">$_</span> <span class="pl-k">==</span> $elem }, @array);
   <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>Hi<span class="pl-pds">'</span></span>;
}

<span class="pl-c"><span class="pl-c">#</span> with:</span>
<span class="pl-k">sub</span> truthy-array( @array ) {
    <span class="pl-c1">say</span> <span class="pl-c1">map</span> sub ($i) { $i <span class="pl-k">??</span> <span class="pl-k">return</span> <span class="pl-c1">True</span> <span class="pl-k">!!</span> <span class="pl-k">return</span> <span class="pl-c1">False</span> }, @array;
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>Hi<span class="pl-pds">'</span></span>;
}

<span class="pl-c"><span class="pl-c">#</span> In the `is-in` sub, the block will `return` out of the `is-in` sub once the</span>
<span class="pl-c"><span class="pl-c">#</span> condition evaluates to `True`, the loop won't be run anymore and the</span>
<span class="pl-c"><span class="pl-c">#</span> following statement won't be executed. The last statement is only executed</span>
<span class="pl-c"><span class="pl-c">#</span> if the block never returns.</span>

<span class="pl-c"><span class="pl-c">#</span> On the contrary, the `truthy-array` sub will produce an array of `True` and</span>
<span class="pl-c"><span class="pl-c">#</span> `False`, which will printed, and always execute the last execute statement.</span>
<span class="pl-c"><span class="pl-c">#</span> Thus, the `return` only returns from the anonymous `sub`</span>

<span class="pl-c"><span class="pl-c">#</span> The `anon` declarator can be used to create an anonymous sub from a</span>
<span class="pl-c"><span class="pl-c">#</span> regular subroutine. The regular sub knows its name but its symbol is</span>
<span class="pl-c"><span class="pl-c">#</span> prevented from getting installed in the lexical scope, the method table</span>
<span class="pl-c"><span class="pl-c">#</span> and everywhere else.</span>
<span class="pl-k">my</span> $anon-sum <span class="pl-k">=</span> anon <span class="pl-k">sub</span> summation(<span class="pl-k">*</span>@a) { [<span class="pl-k">+</span>] @a }
<span class="pl-c1">say</span> $anon-sum<span class="pl-k">.</span><span class="pl-c1">name</span>;     <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «summation␤»</span>
<span class="pl-c1">say</span> $anon-sum(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">5</span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «10␤»</span>
<span class="pl-c"><span class="pl-c">#</span>say summation;         # Error: Undeclared routine: ...</span>

<span class="pl-c"><span class="pl-c">#</span> You can also use the Whatever Star to create an anonymous subroutine.</span>
<span class="pl-c"><span class="pl-c">#</span> (it'll stop at the furthest operator in the current expression).</span>
<span class="pl-c"><span class="pl-c">#</span> The following is the same as `{$_ + 3 }`, `-&gt; { $a + 3 }`,</span>
<span class="pl-c"><span class="pl-c">#</span> `sub ($a) { $a + 3 }`, or even `{$^a + 3}` (more on this later).</span>
<span class="pl-k">my</span> @arrayplus3v0 <span class="pl-k">=</span> <span class="pl-c1">map</span> <span class="pl-k">*</span> <span class="pl-k">+</span> <span class="pl-c1">3</span>, @nums;

<span class="pl-c"><span class="pl-c">#</span> The following is the same as `-&gt; $a, $b { $a + $b + 3 }`,</span>
<span class="pl-c"><span class="pl-c">#</span> `sub ($a, $b) { $a + $b + 3 }`, or `{ $^a + $^b + 3 }` (more on this later).</span>
<span class="pl-k">my</span> @arrayplus3v1 <span class="pl-k">=</span> <span class="pl-c1">map</span> <span class="pl-k">*</span> <span class="pl-k">+</span> <span class="pl-k">*</span> <span class="pl-k">+</span> <span class="pl-c1">3</span>, @nums;

<span class="pl-c1">say</span> (<span class="pl-k">*/</span><span class="pl-c1">2</span>)(<span class="pl-c1">4</span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «2␤», immediately execute the Whatever function created.</span>
<span class="pl-c1">say</span> ((<span class="pl-k">*</span><span class="pl-c1">+3</span>)<span class="pl-k">/</span><span class="pl-c1">5</span>)(<span class="pl-c1">5</span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «1.6␤», it works even in parens!</span>

<span class="pl-c"><span class="pl-c">#</span> But if you need to have more than one argument (`$_`) in a block (without</span>
<span class="pl-c"><span class="pl-c">#</span> wanting to resort to `-&gt; {}`), you can also either `$^` and `$:` which</span>
<span class="pl-c"><span class="pl-c">#</span> declared placeholder parameters or self-declared positional/named parameters.</span>
<span class="pl-c1">say</span> <span class="pl-c1">map</span> { $<span class="pl-k">^</span>a <span class="pl-k">+</span> $<span class="pl-k">^</span>b <span class="pl-k">+</span> <span class="pl-c1">3</span> }, @nums;

<span class="pl-c"><span class="pl-c">#</span> which is equivalent to the following which uses a `sub`:</span>
<span class="pl-c1">map</span> sub ($a, $b) { $a <span class="pl-k">+</span> $b <span class="pl-k">+</span> <span class="pl-c1">3</span> }, @nums;

<span class="pl-c"><span class="pl-c">#</span> Placeholder parameters are sorted lexicographically so the following two</span>
<span class="pl-c"><span class="pl-c">#</span> statements are equivalent:</span>
<span class="pl-c1">say</span> <span class="pl-c1">sort</span>           { $<span class="pl-k">^</span>b &lt;<span class="pl-s">=</span>&gt; $<span class="pl-k">^</span>a }, @nums;
<span class="pl-c1">say</span> <span class="pl-c1">sort</span> <span class="pl-k">-&gt;</span> $a, $b { $b  &lt;<span class="pl-s">=</span>&gt; $a  }, @nums;

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 6.3 Multiple Dispatch</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Raku can decide which variant of a `sub` to call based on the type of the</span>
<span class="pl-c"><span class="pl-c">#</span> arguments, or on arbitrary preconditions, like with a type or `where`:</span>

<span class="pl-c"><span class="pl-c">#</span> with types:</span>
<span class="pl-k">multi</span> <span class="pl-k">sub</span> sayit( <span class="pl-c1">Int</span> $n ) { <span class="pl-c"><span class="pl-c">#</span> note the `multi` keyword here</span>
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Number: $n<span class="pl-pds">"</span></span>;
}
<span class="pl-k">multi</span> sayit( <span class="pl-c1">Str</span> $s ) {     <span class="pl-c"><span class="pl-c">#</span> a multi is a `sub` by default</span>
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>String: $s<span class="pl-pds">"</span></span>;
}
sayit <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «String: foo␤»</span>
sayit <span class="pl-c1">25</span>;    <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Number: 25␤»</span>
sayit <span class="pl-c1">True</span>;  <span class="pl-c"><span class="pl-c">#</span> fails at *compile time* with "calling 'sayit' will never</span>
             <span class="pl-c"><span class="pl-c">#</span> work with arguments of types ..."</span>

<span class="pl-c"><span class="pl-c">#</span> with arbitrary preconditions (remember subsets?):</span>
<span class="pl-k">multi</span> is-big(<span class="pl-c1">Int</span> $n <span class="pl-k">where</span> <span class="pl-k">*</span> <span class="pl-k">&gt;</span> <span class="pl-c1">50</span>) { <span class="pl-s"><span class="pl-pds">"</span>Yes!<span class="pl-pds">"</span></span> }    <span class="pl-c"><span class="pl-c">#</span> using a closure</span>
<span class="pl-k">multi</span> is-big(<span class="pl-c1">Int</span> $n <span class="pl-k">where</span> {<span class="pl-k">$_</span> <span class="pl-k">&gt;</span> <span class="pl-c1">50</span>}) { <span class="pl-s"><span class="pl-pds">"</span>Yes!<span class="pl-pds">"</span></span> } <span class="pl-c"><span class="pl-c">#</span> similar to above</span>
<span class="pl-k">multi</span> is-big(<span class="pl-c1">Int</span> <span class="pl-k">$</span> <span class="pl-k">where</span> <span class="pl-c1">10</span><span class="pl-k">..</span><span class="pl-c1">50</span>)  { <span class="pl-s"><span class="pl-pds">"</span>Quite.<span class="pl-pds">"</span></span> }  <span class="pl-c"><span class="pl-c">#</span> Using smart-matching</span>
<span class="pl-k">multi</span> is-big(<span class="pl-c1">Int</span> $) { <span class="pl-s"><span class="pl-pds">"</span>No<span class="pl-pds">"</span></span> }

<span class="pl-k">subset</span> <span class="pl-en">Even</span> <span class="pl-k">of</span> <span class="pl-c1">Int</span> <span class="pl-k">where</span> <span class="pl-k">*</span> <span class="pl-k">%%</span> <span class="pl-c1">2</span>;
<span class="pl-k">multi</span> odd-or-even(Even) { <span class="pl-s"><span class="pl-pds">"</span>Even<span class="pl-pds">"</span></span> } <span class="pl-c"><span class="pl-c">#</span> Using the type. We don't name the argument.</span>
<span class="pl-k">multi</span> odd-or-even($) { <span class="pl-s"><span class="pl-pds">"</span>Odd<span class="pl-pds">"</span></span> }     <span class="pl-c"><span class="pl-c">#</span> "everything else" hence the $ variable</span>

<span class="pl-c"><span class="pl-c">#</span> You can even dispatch based on the presence of positional and named arguments:</span>
<span class="pl-k">multi</span> with-or-without-you($<span class="pl-k">with</span>) {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>I wish I could but I can't<span class="pl-pds">"</span></span>;
}
<span class="pl-k">multi</span> with-or-without-you(<span class="pl-k">:</span>$<span class="pl-k">with</span>) {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>I can live! Actually, I can't.<span class="pl-pds">"</span></span>;
}
<span class="pl-k">multi</span> with-or-without-you {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Definitely can't live.<span class="pl-pds">"</span></span>;
}

<span class="pl-c"><span class="pl-c">#</span> This is very, very useful for many purposes, like `MAIN` subs (covered</span>
<span class="pl-c"><span class="pl-c">#</span> later), and even the language itself uses it in several places.</span>

<span class="pl-c"><span class="pl-c">#</span> For example, the `is` trait is actually a `multi sub` named `trait_mod:&lt;is&gt;`,</span>
<span class="pl-c"><span class="pl-c">#</span> and it works off that. Thus, `is rw`, is simply a dispatch to a function with</span>
<span class="pl-c"><span class="pl-c">#</span> this signature `sub trait_mod:&lt;is&gt;(Routine $r, :$rw!) {}`</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 7. About types...</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> Raku is gradually typed. This means you can specify the type of your</span>
<span class="pl-c"><span class="pl-c">#</span> variables/arguments/return types, or you can omit the type annotations in</span>
<span class="pl-c"><span class="pl-c">#</span> in which case they'll default to `Any`. Obviously you get access to a few</span>
<span class="pl-c"><span class="pl-c">#</span> base types, like `Int` and `Str`. The constructs for declaring types are</span>
<span class="pl-c"><span class="pl-c">#</span> `subset`, `class`, `role`, etc. which you'll see later.</span>

<span class="pl-c"><span class="pl-c">#</span> For now, let us examine `subset` which is a "sub-type" with additional</span>
<span class="pl-c"><span class="pl-c">#</span> checks. For example, "a very big integer is an `Int` that's greater than 500".</span>
<span class="pl-c"><span class="pl-c">#</span> You can specify the type you're subtyping (by default, `Any`), and add</span>
<span class="pl-c"><span class="pl-c">#</span> additional checks with the `where` clause.</span>
<span class="pl-k">subset</span> <span class="pl-en">VeryBigInteger</span> <span class="pl-k">of</span> <span class="pl-c1">Int</span> <span class="pl-k">where</span> <span class="pl-k">*</span> <span class="pl-k">&gt;</span> <span class="pl-c1">500</span>;

<span class="pl-c"><span class="pl-c">#</span> Or the set of the whole numbers:</span>
<span class="pl-k">subset</span> <span class="pl-en">WholeNumber</span> <span class="pl-k">of</span> <span class="pl-c1">Int</span> <span class="pl-k">where</span> <span class="pl-k">*</span> <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>;
<span class="pl-k">my</span> WholeNumber $whole-six    <span class="pl-k">=</span> <span class="pl-c1">6</span>;  <span class="pl-c"><span class="pl-c">#</span> OK</span>
<span class="pl-c"><span class="pl-c">#</span>my WholeNumber $nonwhole-one = -1; # Error: type check failed...</span>

<span class="pl-c"><span class="pl-c">#</span> Or the set of Positive Even Numbers whose Mod 5 is 1. Notice we're</span>
<span class="pl-c"><span class="pl-c">#</span> using the previously defined WholeNumber subset.</span>
<span class="pl-k">subset</span> <span class="pl-en">PENFO</span> <span class="pl-k">of</span> WholeNumber <span class="pl-k">where</span> { <span class="pl-k">$_</span> <span class="pl-k">%%</span> <span class="pl-c1">2</span> <span class="pl-k">and</span> <span class="pl-k">$_</span> <span class="pl-k">mod</span> <span class="pl-c1">5</span> <span class="pl-k">==</span> <span class="pl-c1">1</span> };
<span class="pl-k">my</span> PENFO $yes-penfo <span class="pl-k">=</span> <span class="pl-c1">36</span>;  <span class="pl-c"><span class="pl-c">#</span> OK</span>
<span class="pl-c"><span class="pl-c">#</span>my PENFO $no-penfo  = 2;  # Error: type check failed...</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 8. Scoping</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> In Raku, unlike many scripting languages, (such as Python, Ruby, PHP),</span>
<span class="pl-c"><span class="pl-c">#</span> you must declare your variables before using them. The `my` declarator</span>
<span class="pl-c"><span class="pl-c">#</span> we've used so far uses "lexical scoping". There are a few other declarators,</span>
<span class="pl-c"><span class="pl-c">#</span> (`our`, `state`, ..., ) which we'll see later. This is called</span>
<span class="pl-c"><span class="pl-c">#</span> "lexical scoping", where in inner blocks, you can access variables from</span>
<span class="pl-c"><span class="pl-c">#</span> outer blocks.</span>

<span class="pl-k">my</span> $file_scoped <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>Foo<span class="pl-pds">'</span></span>;
<span class="pl-k">sub</span> outer {
    <span class="pl-k">my</span> $outer_scoped <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>Bar<span class="pl-pds">'</span></span>;
    <span class="pl-k">sub</span> inner {
        <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>$file_scoped $outer_scoped<span class="pl-pds">"</span></span>;
    }
    &amp;inner; <span class="pl-c"><span class="pl-c">#</span> return the function</span>
}
outer()();  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Foo Bar␤»</span>

<span class="pl-c"><span class="pl-c">#</span> As you can see, `$file_scoped` and `$outer_scoped` were captured.</span>
<span class="pl-c"><span class="pl-c">#</span> But if we were to try and use `$outer_scoped` outside the `outer` sub,</span>
<span class="pl-c"><span class="pl-c">#</span> the variable would be undefined (and you'd get a compile time error).</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 9. Twigils</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> There are many special `twigils` (composed sigils) in Raku. Twigils</span>
<span class="pl-c"><span class="pl-c">#</span> define a variable's scope.</span>
<span class="pl-c"><span class="pl-c">#</span> The `*` and `?` twigils work on standard variables:</span>
<span class="pl-c"><span class="pl-c">#</span>     * for dynamic variables</span>
<span class="pl-c"><span class="pl-c">#</span>     ? for compile-time variables</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> The `!` and the `.` twigils are used with Raku's objects:</span>
<span class="pl-c"><span class="pl-c">#</span>     ! for attributes (instance attribute)</span>
<span class="pl-c"><span class="pl-c">#</span>     . for methods (not really a variable)</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> `*` twigil: Dynamic Scope</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> These variables use the `*` twigil to mark dynamically-scoped variables.</span>
<span class="pl-c"><span class="pl-c">#</span> Dynamically-scoped variables are looked up through the caller, not through</span>
<span class="pl-c"><span class="pl-c">#</span> the outer scope.</span>

<span class="pl-k">my</span> $<span class="pl-k">*</span>dyn_scoped_1 <span class="pl-k">=</span> <span class="pl-c1">1</span>;
<span class="pl-k">my</span> $<span class="pl-k">*</span>dyn_scoped_2 <span class="pl-k">=</span> <span class="pl-c1">10</span>;

<span class="pl-k">sub</span> say_dyn {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>$*dyn_scoped_1 $*dyn_scoped_2<span class="pl-pds">"</span></span>;
}

<span class="pl-k">sub</span> call_say_dyn {
    <span class="pl-c"><span class="pl-c">#</span> Defines $*dyn_scoped_1 only for this sub.</span>
    <span class="pl-k">my</span> $<span class="pl-k">*</span>dyn_scoped_1 <span class="pl-k">=</span> <span class="pl-c1">25</span>;

    <span class="pl-c"><span class="pl-c">#</span> Will change the value of the file scoped variable.</span>
    $<span class="pl-k">*</span>dyn_scoped_2 <span class="pl-k">=</span> <span class="pl-c1">100</span>;

    <span class="pl-c"><span class="pl-c">#</span> $*dyn_scoped 1 and 2 will be looked for in the call.</span>
    say_dyn();  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «25 100␤»</span>

    <span class="pl-c"><span class="pl-c">#</span> The call to `say_dyn` uses the value of $*dyn_scoped_1 from inside</span>
    <span class="pl-c"><span class="pl-c">#</span> this sub's lexical scope even though the blocks aren't nested (they're</span>
    <span class="pl-c"><span class="pl-c">#</span> call-nested).</span>
}
say_dyn();      <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «1 10␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Uses $*dyn_scoped_1 as defined in `call_say_dyn` even though we are calling it</span>
<span class="pl-c"><span class="pl-c">#</span> from outside.</span>
call_say_dyn(); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «25 100␤»</span>

<span class="pl-c"><span class="pl-c">#</span> We changed the value of $*dyn_scoped_2 in `call_say_dyn` so now its</span>
<span class="pl-c"><span class="pl-c">#</span> value has changed.</span>
say_dyn();      <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «1 100␤»</span>

<span class="pl-c"><span class="pl-c">#</span> TODO: Add information about remaining twigils</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 10. Object Model</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> To call a method on an object, add a dot followed by the method name:</span>
<span class="pl-c"><span class="pl-c">#</span> `$object.method`</span>

<span class="pl-c"><span class="pl-c">#</span> Classes are declared with the `class` keyword. Attributes are declared</span>
<span class="pl-c"><span class="pl-c">#</span> with the `has` keyword, and methods declared with the `method` keyword.</span>

<span class="pl-c"><span class="pl-c">#</span> Every attribute that is private uses the `!` twigil. For example: `$!attr`.</span>
<span class="pl-c"><span class="pl-c">#</span> Immutable public attributes use the `.` twigil which creates a read-only</span>
<span class="pl-c"><span class="pl-c">#</span> method named after the attribute. In fact, declaring an attribute with `.`</span>
<span class="pl-c"><span class="pl-c">#</span> is equivalent to declaring the same attribute with `!` and then creating</span>
<span class="pl-c"><span class="pl-c">#</span> a read-only method with the attribute's name. However, this is done for us</span>
<span class="pl-c"><span class="pl-c">#</span> by Raku automatically. The easiest way to remember the `$.` twigil is</span>
<span class="pl-c"><span class="pl-c">#</span> by comparing it to how methods are called.</span>

<span class="pl-c"><span class="pl-c">#</span> Raku's object model ("SixModel") is very flexible, and allows you to</span>
<span class="pl-c"><span class="pl-c">#</span> dynamically add methods, change semantics, etc... Unfortunately, these will</span>
<span class="pl-c"><span class="pl-c">#</span> not all be covered here, and you should refer to:</span>
<span class="pl-c"><span class="pl-c">#</span> https://docs.raku.org/language/objects.html.</span>

<span class="pl-k">class</span> <span class="pl-en">Human</span> {
    <span class="pl-k">has</span> <span class="pl-c1">Str</span> $.<span class="pl-c1">name</span>;           <span class="pl-c"><span class="pl-c">#</span> `$.name` is immutable but with an accessor method.</span>
    <span class="pl-k">has</span> <span class="pl-c1">Str</span> $.bcountry;       <span class="pl-c"><span class="pl-c">#</span> Use `$!bcountry` to modify it inside the class.</span>
	<span class="pl-k">has</span> <span class="pl-c1">Str</span> $.ccountry <span class="pl-k">is</span> <span class="pl-en">rw</span>; <span class="pl-c"><span class="pl-c">#</span> This attribute can be modified from outside.</span>
	<span class="pl-k">has</span> <span class="pl-c1">Int</span> $<span class="pl-k">!</span>age <span class="pl-k">=</span> <span class="pl-c1">0</span>;        <span class="pl-c"><span class="pl-c">#</span> A private attribute with default value.</span>

	<span class="pl-k">method</span> birthday {
		$<span class="pl-k">!</span>age <span class="pl-k">+=</span> <span class="pl-c1">1</span>; <span class="pl-c"><span class="pl-c">#</span> Add a year to human's age</span>
	}

	<span class="pl-k">method</span> get-age {
		<span class="pl-k">return</span> $<span class="pl-k">!</span>age;
	}

	<span class="pl-c"><span class="pl-c">#</span> This method is private to the class. Note the `!` before the</span>
	<span class="pl-c"><span class="pl-c">#</span> method's name.</span>
	<span class="pl-k">method</span> <span class="pl-c1">!</span>do-decoration {
    	<span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>$!name born in $!bcountry and now lives in $!ccountry.<span class="pl-pds">"</span></span>
  	}

  	<span class="pl-c"><span class="pl-c">#</span> This method is public, just like `birthday` and `get-age`.</span>
  	<span class="pl-k">method</span> get-info {
        <span class="pl-c"><span class="pl-c">#</span> Invoking a method on `self` inside the class.</span>
        <span class="pl-c"><span class="pl-c">#</span> Use `self!priv-method` for private method.</span>
  		<span class="pl-c1">say</span> <span class="pl-c1">self</span><span class="pl-k">!</span>do-decoration;

  		<span class="pl-c"><span class="pl-c">#</span> Use `self.public-method` for public method.</span>
  		<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Age: <span class="pl-pds">"</span></span>, <span class="pl-c1">self</span><span class="pl-k">.</span>get-age;
  	}
};

<span class="pl-c"><span class="pl-c">#</span> Create a new instance of Human class.</span>
<span class="pl-c"><span class="pl-c">#</span> NOTE: Only attributes declared with the `.` twigil can be set via the</span>
<span class="pl-c"><span class="pl-c">#</span> default constructor (more later on). This constructor only accepts named</span>
<span class="pl-c"><span class="pl-c">#</span> arguments.</span>
<span class="pl-k">my</span> $person1 <span class="pl-k">=</span> Human<span class="pl-k">.</span><span class="pl-c1">new</span>(
	<span class="pl-s">name     </span><span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Jord<span class="pl-pds">"</span></span>,
	<span class="pl-s">bcountry </span><span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Togo<span class="pl-pds">"</span></span>,
	<span class="pl-s">ccountry </span><span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Togo<span class="pl-pds">"</span></span>
);

<span class="pl-c"><span class="pl-c">#</span> Make human 10 years old.</span>
$person1<span class="pl-k">.</span>birthday <span class="pl-k">for</span> <span class="pl-c1">1</span><span class="pl-k">..</span><span class="pl-c1">10</span>;

<span class="pl-c1">say</span> $person1<span class="pl-k">.</span><span class="pl-c1">name</span>;     <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Jord␤»</span>
<span class="pl-c1">say</span> $person1<span class="pl-k">.</span>bcountry; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Togo␤»</span>
<span class="pl-c1">say</span> $person1<span class="pl-k">.</span>ccountry; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Togo␤»</span>
<span class="pl-c1">say</span> $person1<span class="pl-k">.</span>get-age;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «10␤»</span>

<span class="pl-c"><span class="pl-c">#</span> This fails, because the `has $.bcountry`is immutable. Jord can't change</span>
<span class="pl-c"><span class="pl-c">#</span> his birthplace.</span>
<span class="pl-c"><span class="pl-c">#</span> $person1.bcountry = "Mali";</span>

<span class="pl-c"><span class="pl-c">#</span> This works because the `$.ccountry` is mutable (`is rw`). Now Jord's</span>
<span class="pl-c"><span class="pl-c">#</span> current country is France.</span>
$person1<span class="pl-k">.</span>ccountry <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>France<span class="pl-pds">"</span></span>;

<span class="pl-c"><span class="pl-c">#</span> Calling methods on the instance objects.</span>
$person1<span class="pl-k">.</span>birthday;      <span class="pl-c"><span class="pl-c">#</span>=&gt; 1</span>
$person1<span class="pl-k">.</span>get-info;      <span class="pl-c"><span class="pl-c">#</span>=&gt; Jord born in Togo and now lives in France. Age: 10</span>
<span class="pl-c"><span class="pl-c">#</span> $person1.do-decoration; # This fails since the method `do-decoration` is private.</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 10.1 Object Inheritance</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Raku also has inheritance (along with multiple inheritance). While</span>
<span class="pl-c"><span class="pl-c">#</span> methods are inherited, submethods are not. Submethods are useful for</span>
<span class="pl-c"><span class="pl-c">#</span> object construction and destruction tasks, such as `BUILD`, or methods that</span>
<span class="pl-c"><span class="pl-c">#</span> must be overridden by subtypes. We will learn about `BUILD` later on.</span>

<span class="pl-k">class</span> <span class="pl-en">Parent</span> {
  	<span class="pl-k">has</span> $.age;
 	<span class="pl-k">has</span> $.<span class="pl-c1">name</span>;

  	<span class="pl-c"><span class="pl-c">#</span> This submethod won't be inherited by the Child class.</span>
  	<span class="pl-k">submethod</span> favorite-color {
    	<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>My favorite color is Blue<span class="pl-pds">"</span></span>;
  	}

  	<span class="pl-c"><span class="pl-c">#</span> This method is inherited</span>
  	<span class="pl-k">method</span> talk { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Hi, my name is $!name<span class="pl-pds">"</span></span> }
}

<span class="pl-c"><span class="pl-c">#</span> Inheritance uses the `is` keyword</span>
<span class="pl-k">class</span> <span class="pl-en">Child</span> <span class="pl-k">is</span> Parent {
  	<span class="pl-k">method</span> talk { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Goo goo ga ga<span class="pl-pds">"</span></span> }
  	<span class="pl-c"><span class="pl-c">#</span> This shadows Parent's `talk` method.</span>
  	<span class="pl-c"><span class="pl-c">#</span> This child hasn't learned to speak yet!</span>
}

<span class="pl-k">my</span> Parent $Richard <span class="pl-k">.=</span> <span class="pl-c1">new</span>(<span class="pl-s">age </span><span class="pl-k">=&gt;</span> <span class="pl-c1">40</span>, <span class="pl-s">name </span><span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>Richard<span class="pl-pds">'</span></span>);
$Richard<span class="pl-k">.</span>favorite-color;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «My favorite color is Blue␤»</span>
$Richard<span class="pl-k">.</span>talk;            <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Hi, my name is Richard␤»</span>
<span class="pl-c"><span class="pl-c">#</span> $Richard is able to access the submethod and he knows how to say his name.</span>

<span class="pl-k">my</span> Child $Madison <span class="pl-k">.=</span> <span class="pl-c1">new</span>(<span class="pl-s">age </span><span class="pl-k">=&gt;</span> <span class="pl-c1">1</span>, <span class="pl-s">name </span><span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>Madison<span class="pl-pds">'</span></span>);
$Madison<span class="pl-k">.</span>talk;            <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Goo goo ga ga␤», due to the overridden method.</span>
<span class="pl-c"><span class="pl-c">#</span> $Madison.favorite-color # does not work since it is not inherited.</span>

<span class="pl-c"><span class="pl-c">#</span> When you use `my T $var`, `$var` starts off with `T` itself in it, so you can</span>
<span class="pl-c"><span class="pl-c">#</span> call `new` on it. (`.=` is just the dot-call and the assignment operator).</span>
<span class="pl-c"><span class="pl-c">#</span> Thus, `$a .= b` is the same as `$a = $a.b`. Also note that `BUILD` (the method</span>
<span class="pl-c"><span class="pl-c">#</span> called inside `new`) will set parent's properties too, so you can pass `val =&gt;</span>
<span class="pl-c"><span class="pl-c">#</span> 5`.</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 10.2 Roles, or Mixins</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Roles are supported too (which are called Mixins in other languages)</span>
<span class="pl-k">role</span> <span class="pl-en">PrintableVal</span> {
  	<span class="pl-k">has</span> $<span class="pl-k">!</span>counter <span class="pl-k">=</span> <span class="pl-c1">0</span>;
  	<span class="pl-k">method</span> print {
    	<span class="pl-c1">say</span> $.val;
  	}
}

<span class="pl-c"><span class="pl-c">#</span> you "apply" a role (or mixin) with the `does` keyword:</span>
<span class="pl-k">class</span> <span class="pl-en">Item</span> <span class="pl-k">does</span> PrintableVal {
  	<span class="pl-k">has</span> $.val;

    <span class="pl-k">=</span><span class="pl-k">begin</span> <span class="pl-e">comment</span><span class="pl-c"></span>
<span class="pl-c">    When `does`-ed, a `role` literally "mixes in" the class:</span>
<span class="pl-c">    the methods and attributes are put together, which means a class</span>
<span class="pl-c">    can access the private attributes/methods of its roles (but</span>
<span class="pl-c">    not the inverse!):</span>
<span class="pl-c"></span>    <span class="pl-k">=</span><span class="pl-k">end</span> <span class="pl-e">comment</span>
  	<span class="pl-k">method</span> access {
  		<span class="pl-c1">say</span> $<span class="pl-k">!</span>counter<span class="pl-k">++</span>;
  	}

    <span class="pl-k">=</span><span class="pl-k">begin</span> <span class="pl-e">comment</span><span class="pl-c"></span>
<span class="pl-c">    However, this: method print {} is ONLY valid when `print` isn't a `multi`</span>
<span class="pl-c">    with the same dispatch. This means a parent class can shadow a child class's</span>
<span class="pl-c">    `multi print() {}`, but it's an error if a role does)</span>
<span class="pl-c"></span>
<span class="pl-c">    NOTE: You can use a role as a class (with `is ROLE`). In this case,</span>
<span class="pl-c">    methods will be shadowed, since the compiler will consider `ROLE`</span>
<span class="pl-c">    to be a class.</span>
<span class="pl-c"></span>    <span class="pl-k">=</span><span class="pl-k">end</span> <span class="pl-e">comment</span>
}

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 11. Exceptions</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> Exceptions are built on top of classes, in the package `X` (like `X::IO`).</span>
<span class="pl-c"><span class="pl-c">#</span> In Raku, exceptions are automatically 'thrown':</span>

<span class="pl-c"><span class="pl-c">#</span> open 'foo';   # OUTPUT: «Failed to open file foo: no such file or directory␤»</span>

<span class="pl-c"><span class="pl-c">#</span> It will also print out what line the error was thrown at</span>
<span class="pl-c"><span class="pl-c">#</span> and other error info.</span>

<span class="pl-c"><span class="pl-c">#</span> You can throw an exception using `die`. Here it's been commented out to</span>
<span class="pl-c"><span class="pl-c">#</span> avoid stopping the program's execution:</span>
<span class="pl-c"><span class="pl-c">#</span> die 'Error!'; # OUTPUT: «Error!␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Or more explicitly (commented out too):</span>
<span class="pl-c"><span class="pl-c">#</span> X::AdHoc.new(payload =&gt; 'Error!').throw; # OUTPUT: «Error!␤»</span>

<span class="pl-c"><span class="pl-c">#</span> In Raku, `orelse` is similar to the `or` operator, except it only matches</span>
<span class="pl-c"><span class="pl-c">#</span> undefined variables instead of anything evaluating as `False`.</span>
<span class="pl-c"><span class="pl-c">#</span> Undefined values include: `Nil`, `Mu` and `Failure` as well as `Int`, `Str`</span>
<span class="pl-c"><span class="pl-c">#</span> and other types that have not been initialized to any value yet.</span>
<span class="pl-c"><span class="pl-c">#</span> You can check if something is defined or not using the defined method:</span>
<span class="pl-k">my</span> $uninitialized;
<span class="pl-c1">say</span> $uninitialized<span class="pl-k">.</span><span class="pl-c1">defined</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>

<span class="pl-c"><span class="pl-c">#</span> When using `orelse` it will disarm the exception and alias $_ to that</span>
<span class="pl-c"><span class="pl-c">#</span> failure. This will prevent it to being automatically handled and printing</span>
<span class="pl-c"><span class="pl-c">#</span> lots of scary error messages to the screen. We can use the `exception`</span>
<span class="pl-c"><span class="pl-c">#</span> method on the `$_` variable to access the exception</span>
<span class="pl-c1">open</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span> <span class="pl-k">orelse</span> <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Something happened <span class="pl-pse">{</span><span class="pl-k">.</span>exception<span class="pl-pse">}</span><span class="pl-pds">"</span></span>;

<span class="pl-c"><span class="pl-c">#</span> This also works:</span>
<span class="pl-c1">open</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span> <span class="pl-k">orelse</span> <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Something happened $_<span class="pl-pds">"</span></span>;
<span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Something happened Failed to open file foo: no such file or directory␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Both of those above work but in case we get an object from the left side</span>
<span class="pl-c"><span class="pl-c">#</span> that is not a failure we will probably get a warning. We see below how we</span>
<span class="pl-c"><span class="pl-c">#</span> can use try` and `CATCH` to be more specific with the exceptions we catch.</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 11.1 Using `try` and `CATCH`</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> By using `try` and `CATCH` you can contain and handle exceptions without</span>
<span class="pl-c"><span class="pl-c">#</span> disrupting the rest of the program. The `try` block will set the last</span>
<span class="pl-c"><span class="pl-c">#</span> exception to the special variable `$!` (known as the error variable).</span>
<span class="pl-c"><span class="pl-c">#</span> NOTE: This has no relation to $!variables seen inside class definitions.</span>

<span class="pl-k">try</span> <span class="pl-c1">open</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span>;
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Well, I tried! $!<span class="pl-pds">"</span></span> <span class="pl-k">if</span> <span class="pl-c1">defined</span> <span class="pl-k">$!</span>;
<span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Well, I tried! Failed to open file foo: no such file or directory␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Now, what if we want more control over handling the exception?</span>
<span class="pl-c"><span class="pl-c">#</span> Unlike many other languages, in Raku, you put the `CATCH` block *within*</span>
<span class="pl-c"><span class="pl-c">#</span> the block to `try`. Similar to how the `$_` variable was set when we</span>
<span class="pl-c"><span class="pl-c">#</span> 'disarmed' the exception with `orelse`, we also use `$_` in the CATCH block.</span>
<span class="pl-c"><span class="pl-c">#</span> NOTE: The `$!` variable is only set *after* the `try` block has caught an</span>
<span class="pl-c"><span class="pl-c">#</span> exception. By default, a `try` block has a `CATCH` block of its own that</span>
<span class="pl-c"><span class="pl-c">#</span> catches any exception (`CATCH { default {} }`).</span>

<span class="pl-k">try</span> {
    <span class="pl-k">my</span> $a <span class="pl-k">=</span> (<span class="pl-c1">0</span> <span class="pl-k">%%</span> <span class="pl-c1">0</span>);
    <span class="pl-k">CATCH</span> {
        <span class="pl-k">default</span> { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Something happened: $_<span class="pl-pds">"</span></span> }
    }
}
<span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Something happened: Attempt to divide by zero using infix:&lt;%%&gt;␤»</span>

<span class="pl-c"><span class="pl-c">#</span> You can redefine it using `when`s (and `default`) to handle the exceptions</span>
<span class="pl-c"><span class="pl-c">#</span> you want to catch explicitly:</span>

<span class="pl-k">try</span> {
  <span class="pl-c1">open</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span>;
    <span class="pl-k">CATCH</span> {
        <span class="pl-c"><span class="pl-c">#</span> In the `CATCH` block, the exception is set to the $_ variable.</span>
        <span class="pl-k">when</span> <span class="pl-c1">X::AdHoc</span> {
            <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Error: $_<span class="pl-pds">"</span></span>
        }
        <span class="pl-k">when</span> <span class="pl-c1">X::Numeric::DivideByZero</span> {
            <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Error: $_<span class="pl-pds">"</span></span>;
        }

        <span class="pl-k">=</span><span class="pl-k">begin</span> <span class="pl-e">comment</span><span class="pl-c"></span>
<span class="pl-c">        Any other exceptions will be re-raised, since we don't have a `default`.</span>
<span class="pl-c">        Basically, if a `when` matches (or there's a `default`), the</span>
<span class="pl-c">	    exception is marked as "handled" so as to prevent its re-throw</span>
<span class="pl-c">        from the `CATCH` block. You still can re-throw the exception</span>
<span class="pl-c">        (see below) by hand.</span>
<span class="pl-c"></span>        <span class="pl-k">=</span><span class="pl-k">end</span> <span class="pl-e">comment</span>
        <span class="pl-k">default</span> {
            <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Any other error: $_<span class="pl-pds">"</span></span>
        }
  }
}
<span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Failed to open file /dir/foo: no such file or directory␤»</span>

<span class="pl-c"><span class="pl-c">#</span> There are also some subtleties to exceptions. Some Raku subs return a</span>
<span class="pl-c"><span class="pl-c">#</span> `Failure`, which is a wrapper around an `Exception` object which is</span>
<span class="pl-c"><span class="pl-c">#</span> "unthrown". They're not thrown until you try to use the variables containing</span>
<span class="pl-c"><span class="pl-c">#</span> them unless you call `.Bool`/`.defined` on them - then they're handled.</span>
<span class="pl-c"><span class="pl-c">#</span> (the `.handled` method is `rw`, so you can mark it as `False` back yourself)</span>
<span class="pl-c"><span class="pl-c">#</span> You can throw a `Failure` using `fail`. Note that if the pragma `use fatal`</span>
<span class="pl-c"><span class="pl-c">#</span> is on, `fail` will throw an exception (like `die`).</span>

<span class="pl-k">my</span> $<span class="pl-c1">value</span> <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">/</span><span class="pl-c1">0</span>; <span class="pl-c"><span class="pl-c">#</span> We're not trying to access the value, so no problem.</span>
<span class="pl-k">try</span> {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>Value: <span class="pl-pds">'</span></span>, $<span class="pl-c1">value</span>; <span class="pl-c"><span class="pl-c">#</span> Trying to use the value</span>
    <span class="pl-k">CATCH</span> {
        <span class="pl-k">default</span> {
            <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>It threw because we tried to get the fail's value!<span class="pl-pds">"</span></span>
        }
  }
}

<span class="pl-c"><span class="pl-c">#</span> There is also another kind of exception: Control exceptions. Those are "good"</span>
<span class="pl-c"><span class="pl-c">#</span> exceptions, which happen when you change your program's flow, using operators</span>
<span class="pl-c"><span class="pl-c">#</span> like `return`, `next` or `last`. You can "catch" those with `CONTROL` (not 100%</span>
<span class="pl-c"><span class="pl-c">#</span> working in Rakudo yet).</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 12. Packages</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> Packages are a way to reuse code. Packages are like "namespaces", and any</span>
<span class="pl-c"><span class="pl-c">#</span> element of the six model (`module`, `role`, `class`, `grammar`, `subset` and</span>
<span class="pl-c"><span class="pl-c">#</span> `enum`) are actually packages. (Packages are the lowest common denominator)</span>
<span class="pl-c"><span class="pl-c">#</span> Packages are important - especially as Perl is well-known for CPAN,</span>
<span class="pl-c"><span class="pl-c">#</span> the Comprehensive Perl Archive Network.</span>

<span class="pl-c"><span class="pl-c">#</span> You can use a module (bring its declarations into scope) with `use`:</span>
<span class="pl-k">use</span> JSON::Tiny; <span class="pl-c"><span class="pl-c">#</span> if you installed Rakudo* or Panda, you'll have this module</span>
<span class="pl-c1">say</span> from-json(<span class="pl-s"><span class="pl-pds">'</span>[1]<span class="pl-pds">'</span></span>)<span class="pl-k">.</span><span class="pl-c1">perl</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «[1]␤»</span>

<span class="pl-c"><span class="pl-c">#</span> You should not declare packages using the `package` keyword (unlike Perl).</span>
<span class="pl-c"><span class="pl-c">#</span> Instead, use `class Package::Name::Here;` to declare a class, or if you only</span>
<span class="pl-c"><span class="pl-c">#</span> want to export variables/subs, you can use `module` instead.</span>

<span class="pl-c"><span class="pl-c">#</span> If `Hello` doesn't exist yet, it'll just be a "stub", that can be redeclared</span>
<span class="pl-c"><span class="pl-c">#</span> as something else later.</span>
<span class="pl-k">module</span> <span class="pl-en">Hello::World</span> { <span class="pl-c"><span class="pl-c">#</span> bracketed form</span>
    <span class="pl-c"><span class="pl-c">#</span> declarations here</span>
}

<span class="pl-c"><span class="pl-c">#</span> The file-scoped form which extends until the end of the file. For</span>
<span class="pl-c"><span class="pl-c">#</span> instance, `unit module Parse::Text;` will extend until of the file.</span>

<span class="pl-c"><span class="pl-c">#</span> A grammar is a package, which you could `use`. You will learn more about</span>
<span class="pl-c"><span class="pl-c">#</span> grammars in the regex section.</span>
<span class="pl-k">grammar</span> <span class="pl-en">Parse::Text::Grammar</span> {
}

<span class="pl-c"><span class="pl-c">#</span> As said before, any part of the six model is also a package.</span>
<span class="pl-c"><span class="pl-c">#</span> Since `JSON::Tiny` uses its own `JSON::Tiny::Actions` class, you can use it:</span>
<span class="pl-k">my</span> $actions <span class="pl-k">=</span> JSON::Tiny::Actions<span class="pl-k">.</span><span class="pl-c1">new</span>;

<span class="pl-c"><span class="pl-c">#</span> We'll see how to export variables and subs in the next part.</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 13. Declarators</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> In Raku, you get different behaviors based on how you declare a variable.</span>
<span class="pl-c"><span class="pl-c">#</span> You've already seen `my` and `has`, we'll now explore the others.</span>

<span class="pl-c"><span class="pl-c">#</span> `our` - these declarations happen at `INIT` time -- (see "Phasers" below).</span>
<span class="pl-c"><span class="pl-c">#</span> It's like `my`, but it also creates a package variable. All packagish</span>
<span class="pl-c"><span class="pl-c">#</span> things such as `class`, `role`, etc. are `our` by default.</span>

<span class="pl-k">module</span> <span class="pl-en">Var::Increment</span> {
    <span class="pl-c"><span class="pl-c">#</span> NOTE: `our`-declared variables cannot be typed.</span>
    <span class="pl-k">our</span> $our-var <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">my</span> $my-var <span class="pl-k">=</span> <span class="pl-c1">22</span>;

    <span class="pl-k">our</span> <span class="pl-k">sub</span> Inc {
        <span class="pl-k">our</span> <span class="pl-k">sub</span> available { <span class="pl-c"><span class="pl-c">#</span> If you try to make inner `sub`s `our`...</span>
                            <span class="pl-c"><span class="pl-c">#</span> ... Better know what you're doing (Don't !).</span>
            <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Don't do that. Seriously. You'll get burned.<span class="pl-pds">"</span></span>;
        }

        <span class="pl-k">my</span> <span class="pl-k">sub</span> unavailable { <span class="pl-c"><span class="pl-c">#</span> `sub`s are `my`-declared by default</span>
            <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Can't access me from outside, I'm 'my'!<span class="pl-pds">"</span></span>;
        }
        <span class="pl-c1">say</span> <span class="pl-k">++</span>$our-var; <span class="pl-c"><span class="pl-c">#</span> Increment the package variable and output its value</span>
  }

}

<span class="pl-c1">say</span> $Var::Increment::our-var; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «1␤», this works!</span>
<span class="pl-c1">say</span> $Var::Increment::my-var;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «(Any)␤», this will not work!</span>

<span class="pl-c1">say</span> Var::Increment::Inc;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «2␤»</span>
<span class="pl-c1">say</span> Var::Increment::Inc;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «3␤», notice how the value of $our-var was retained.</span>

<span class="pl-c"><span class="pl-c">#</span> Var::Increment::unavailable;  # OUTPUT: «Could not find symbol '&amp;unavailable'␤»</span>

<span class="pl-c"><span class="pl-c">#</span> `constant` - these declarations happen at `BEGIN` time. You can use</span>
<span class="pl-c"><span class="pl-c">#</span> the `constant` keyword to declare a compile-time variable/symbol:</span>
<span class="pl-k">constant</span> Pi <span class="pl-k">=</span> <span class="pl-c1">3.14</span>;
<span class="pl-k">constant</span> $var <span class="pl-k">=</span> <span class="pl-c1">1</span>;

<span class="pl-c"><span class="pl-c">#</span> And if you're wondering, yes, it can also contain infinite lists.</span>
<span class="pl-k">constant</span> why-not <span class="pl-k">=</span> <span class="pl-c1">5</span>, <span class="pl-c1">15</span> <span class="pl-k">...</span> <span class="pl-k">*</span>;
<span class="pl-c1">say</span> why-not[<span class="pl-k">^</span><span class="pl-c1">5</span>]; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «5 15 25 35 45␤»</span>

<span class="pl-c"><span class="pl-c">#</span> `state` - these declarations happen at run time, but only once. State</span>
<span class="pl-c"><span class="pl-c">#</span> variables are only initialized one time. In other languages such as C</span>
<span class="pl-c"><span class="pl-c">#</span> they exist as `static` variables.</span>
<span class="pl-k">sub</span> fixed-rand {
    <span class="pl-k">state</span> $val <span class="pl-k">=</span> <span class="pl-c1">rand</span>;
    <span class="pl-c1">say</span> $val;
}
fixed-rand <span class="pl-k">for</span> <span class="pl-k">^</span><span class="pl-c1">10</span>; <span class="pl-c"><span class="pl-c">#</span> will print the same number 10 times</span>

<span class="pl-c"><span class="pl-c">#</span> Note, however, that they exist separately in different enclosing contexts.</span>
<span class="pl-c"><span class="pl-c">#</span> If you declare a function with a `state` within a loop, it'll re-create the</span>
<span class="pl-c"><span class="pl-c">#</span> variable for each iteration of the loop. See:</span>
<span class="pl-k">for</span> <span class="pl-k">^</span><span class="pl-c1">5</span> <span class="pl-k">-&gt;</span> $a {
    <span class="pl-k">sub</span> foo {
        <span class="pl-c"><span class="pl-c">#</span> This will be a different value for every value of `$a`</span>
        <span class="pl-k">state</span> $val <span class="pl-k">=</span> <span class="pl-c1">rand</span>;
    }
    <span class="pl-k">for</span> <span class="pl-k">^</span><span class="pl-c1">5</span> <span class="pl-k">-&gt;</span> $b {
        <span class="pl-c"><span class="pl-c">#</span> This will print the same value 5 times, but only 5. Next iteration</span>
        <span class="pl-c"><span class="pl-c">#</span> will re-run `rand`.</span>
        <span class="pl-c1">say</span> foo;
    }
}

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 14. Phasers</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> Phasers in Raku are blocks that happen at determined points of time in</span>
<span class="pl-c"><span class="pl-c">#</span> your program. They are called phasers because they mark a change in the</span>
<span class="pl-c"><span class="pl-c">#</span> phase of a program.  For example, when the program is compiled, a for loop</span>
<span class="pl-c"><span class="pl-c">#</span> runs, you leave a block, or an exception gets thrown (The `CATCH` block is</span>
<span class="pl-c"><span class="pl-c">#</span> actually a phaser!). Some of them can be used for their return values,</span>
<span class="pl-c"><span class="pl-c">#</span> some of them can't (those that can have a "[*]" in the beginning of their</span>
<span class="pl-c"><span class="pl-c">#</span> explanation text). Let's have a look!</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 14.1 Compile-time phasers</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-k">BEGIN</span> { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>[*] Runs at compile time, as soon as possible, only once<span class="pl-pds">"</span></span> }
<span class="pl-k">CHECK</span> { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>[*] Runs at compile time, as late as possible, only once<span class="pl-pds">"</span></span> }

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 14.2 Run-time phasers</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-k">INIT</span> { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>[*] Runs at run time, as soon as possible, only once<span class="pl-pds">"</span></span> }
<span class="pl-k">END</span>  { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Runs at run time, as late as possible, only once<span class="pl-pds">"</span></span> }

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 14.3 Block phasers</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-k">ENTER</span> { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>[*] Runs every time you enter a block, repeats on loop blocks<span class="pl-pds">"</span></span> }
<span class="pl-k">LEAVE</span> {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Runs every time you leave a block, even when an exception</span>
<span class="pl-s">    happened. Repeats on loop blocks.<span class="pl-pds">"</span></span>
}

<span class="pl-k">PRE</span> {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Asserts a precondition at every block entry,</span>
<span class="pl-s">        before ENTER (especially useful for loops)<span class="pl-pds">"</span></span>;
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>If this block doesn't return a truthy value,</span>
<span class="pl-s">        an exception of type X::Phaser::PrePost is thrown.<span class="pl-pds">"</span></span>;
}

<span class="pl-c"><span class="pl-c">#</span> Example (commented out):</span>
<span class="pl-k">for</span> <span class="pl-c1">0</span><span class="pl-k">..</span><span class="pl-c1">2</span> {
    <span class="pl-c"><span class="pl-c">#</span> PRE { $_ &gt; 1 } # OUTPUT: «Precondition '{ $_ &gt; 1 }' failed</span>
}

<span class="pl-k">POST</span> {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Asserts a postcondition at every block exit,</span>
<span class="pl-s">        after LEAVE (especially useful for loops)<span class="pl-pds">"</span></span>;
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>If this block doesn't return a truthy value,</span>
<span class="pl-s">        an exception of type X::Phaser::PrePost is thrown, like PRE.<span class="pl-pds">"</span></span>;
}

<span class="pl-c"><span class="pl-c">#</span> Example (commented out):</span>
<span class="pl-k">for</span> <span class="pl-c1">0</span><span class="pl-k">..</span><span class="pl-c1">2</span> {
    <span class="pl-c"><span class="pl-c">#</span> POST { $_ &lt; 1 } # OUTPUT: «Postcondition '{ $_ &lt; 1 }' failed</span>
}

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 14.4 Block/exceptions phasers</span>
<span class="pl-c"><span class="pl-c">#</span></span>
{
    <span class="pl-k">KEEP</span> { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Runs when you exit a block successfully</span>
<span class="pl-s">                (without throwing an exception)<span class="pl-pds">"</span></span> }
    <span class="pl-k">UNDO</span> { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Runs when you exit a block unsuccessfully</span>
<span class="pl-s">                (by throwing an exception)<span class="pl-pds">"</span></span> }
}

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 14.5 Loop phasers</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-k">for</span> <span class="pl-k">^</span><span class="pl-c1">5</span> {
  <span class="pl-k">FIRST</span> { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>[*] The first time the loop is run, before ENTER<span class="pl-pds">"</span></span> }
  <span class="pl-k">NEXT</span>  { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>At loop continuation time, before LEAVE<span class="pl-pds">"</span></span> }
  <span class="pl-k">LAST</span>  { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>At loop termination time, after LEAVE<span class="pl-pds">"</span></span> }
}

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 14.6 Role/class phasers</span>
<span class="pl-c"><span class="pl-c">#</span></span>
COMPOSE {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>When a role is composed into a class. /!\ NOT YET IMPLEMENTED<span class="pl-pds">"</span></span>
}

<span class="pl-c"><span class="pl-c">#</span> They allow for cute tricks or clever code...:</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>This code took <span class="pl-pds">"</span></span> <span class="pl-k">~</span> (<span class="pl-c1">time</span> <span class="pl-k">-</span> <span class="pl-k">CHECK</span> <span class="pl-c1">time</span>) <span class="pl-k">~</span> <span class="pl-s"><span class="pl-pds">"</span>s to compile<span class="pl-pds">"</span></span>;

<span class="pl-c"><span class="pl-c">#</span> ... or clever organization:</span>
<span class="pl-k">class</span> <span class="pl-en">DB</span> {
    <span class="pl-k">method</span> start-transaction { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Starting transaction!<span class="pl-pds">"</span></span> }
    <span class="pl-k">method</span> commit            { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Committing transaction...<span class="pl-pds">"</span></span> }
    <span class="pl-k">method</span> rollback          { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Something went wrong. Rolling back!<span class="pl-pds">"</span></span> }
}

<span class="pl-k">sub</span> do-db-stuff {
    <span class="pl-k">my</span> DB $db <span class="pl-k">.=</span> <span class="pl-c1">new</span>;
  	$db<span class="pl-k">.</span>start-transaction; <span class="pl-c"><span class="pl-c">#</span> start a new transaction</span>
  	<span class="pl-k">KEEP</span> $db<span class="pl-k">.</span>commit;       <span class="pl-c"><span class="pl-c">#</span> commit the transaction if all went well</span>
  	<span class="pl-k">UNDO</span> $db<span class="pl-k">.</span>rollback;     <span class="pl-c"><span class="pl-c">#</span> or rollback if all hell broke loose</span>
}

do-db-stuff();

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 15. Statement prefixes</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> Those act a bit like phasers: they affect the behavior of the following</span>
<span class="pl-c"><span class="pl-c">#</span> code. Though, they run in-line with the executable code, so they're in</span>
<span class="pl-c"><span class="pl-c">#</span> lowercase. (`try` and `start` are theoretically in that list, but explained</span>
<span class="pl-c"><span class="pl-c">#</span> elsewhere) NOTE: all of these (except start) don't need explicit curly</span>
<span class="pl-c"><span class="pl-c">#</span> braces `{` and `}`.</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 15.1 `do` - It runs a block or a statement as a term.</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Normally you cannot use a statement as a value (or "term"). `do` helps</span>
<span class="pl-c"><span class="pl-c">#</span> us do it. With `do`, an `if`, for example, becomes a term returning a value.</span>
<span class="pl-k">=</span><span class="pl-e">for</span> comment<span class="pl-c"> :reason&lt;this fails since `if` is a statement&gt;</span>
<span class="pl-c">my $value = if True { 1 }</span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">#</span> this works!</span>
<span class="pl-k">my</span> $get-five <span class="pl-k">=</span> <span class="pl-k">do</span> <span class="pl-k">if</span> <span class="pl-c1">True</span> { <span class="pl-c1">5</span> }

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 15.1 `once` - makes sure a piece of code only runs once.</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-k">for</span> <span class="pl-k">^</span><span class="pl-c1">5</span> {
	<span class="pl-c1">once</span> <span class="pl-c1">say</span> <span class="pl-c1">1</span>
};
<span class="pl-c"><span class="pl-c">#</span> OUTPUT: «1␤», only prints ... once</span>

<span class="pl-c"><span class="pl-c">#</span> Similar to `state`, they're cloned per-scope.</span>
<span class="pl-k">for</span> <span class="pl-k">^</span><span class="pl-c1">5</span> {
	sub { <span class="pl-c1">once</span> <span class="pl-c1">say</span> <span class="pl-c1">1</span> }()
};
<span class="pl-c"><span class="pl-c">#</span> OUTPUT: «1 1 1 1 1␤», prints once per lexical scope.</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 15.2 `gather` - co-routine thread.</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> The `gather` constructs allows us to `take` several values from an array/list,</span>
<span class="pl-c"><span class="pl-c">#</span> much like `do`.</span>
<span class="pl-c1">say</span> <span class="pl-k">gather</span> <span class="pl-k">for</span> <span class="pl-k">^</span><span class="pl-c1">5</span> {
    <span class="pl-k">take</span> <span class="pl-k">$_</span> <span class="pl-k">*</span> <span class="pl-c1">3</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    <span class="pl-k">take</span> <span class="pl-k">$_</span> <span class="pl-k">*</span> <span class="pl-c1">3</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>;
}
<span class="pl-c"><span class="pl-c">#</span> OUTPUT: «-1 1 2 4 5 7 8 10 11 13␤»</span>

<span class="pl-c1">say</span> <span class="pl-c1">join</span> <span class="pl-s"><span class="pl-pds">'</span>,<span class="pl-pds">'</span></span>, <span class="pl-k">gather</span> <span class="pl-k">if</span> <span class="pl-c1">False</span> {
    <span class="pl-k">take</span> <span class="pl-c1">1</span>;
    <span class="pl-k">take</span> <span class="pl-c1">2</span>;
    <span class="pl-k">take</span> <span class="pl-c1">3</span>;
}
<span class="pl-c"><span class="pl-c">#</span> Doesn't print anything.</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 15.3 `eager` - evaluates a statement eagerly (forces eager context).</span>

<span class="pl-c"><span class="pl-c">#</span> Don't try this at home. This will probably hang for a while (and might crash)</span>
<span class="pl-c"><span class="pl-c">#</span> so commented out.</span>
<span class="pl-c"><span class="pl-c">#</span> eager 1..*;</span>

<span class="pl-c"><span class="pl-c">#</span> But consider, this version which doesn't print anything</span>
<span class="pl-k">constant</span> thricev0 <span class="pl-k">=</span> <span class="pl-k">gather</span> <span class="pl-k">for</span> <span class="pl-k">^</span><span class="pl-c1">3</span> { <span class="pl-c1">say</span> <span class="pl-k">take</span> <span class="pl-k">$_</span> };
<span class="pl-c"><span class="pl-c">#</span> to:</span>
<span class="pl-k">constant</span> thricev1 <span class="pl-k">=</span> <span class="pl-c1">eager</span> <span class="pl-k">gather</span> <span class="pl-k">for</span> <span class="pl-k">^</span><span class="pl-c1">3</span> { <span class="pl-c1">say</span> <span class="pl-k">take</span> <span class="pl-k">$_</span> }; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «0 1 2␤»</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 16. Iterables</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> Iterables are objects that can be iterated over for things such as</span>
<span class="pl-c"><span class="pl-c">#</span> the `for` construct.</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 16.1 `flat` - flattens iterables.</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c1">say</span> (<span class="pl-c1">1</span>, <span class="pl-c1">10</span>, (<span class="pl-c1">20</span>, <span class="pl-c1">10</span>) );      <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «(1 10 (20 10))␤»,  notice how nested</span>
                             <span class="pl-c"><span class="pl-c">#</span> lists are preserved</span>
<span class="pl-c1">say</span> (<span class="pl-c1">1</span>, <span class="pl-c1">10</span>, (<span class="pl-c1">20</span>, <span class="pl-c1">10</span>) )<span class="pl-k">.</span><span class="pl-c1">flat</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «(1 10 20 10)␤», now the iterable is flat</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 16.2 `lazy` - defers actual evaluation until value is fetched by forcing lazy context.</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-k">my</span> @lazy-array <span class="pl-k">=</span> (<span class="pl-c1">1</span><span class="pl-k">..</span><span class="pl-c1">100</span>)<span class="pl-k">.</span><span class="pl-c1">lazy</span>;
<span class="pl-c1">say</span> @lazy-array<span class="pl-k">.</span><span class="pl-c1">is-lazy</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», check for laziness with the `is-lazy` method.</span>

<span class="pl-c1">say</span> @lazy-array;         <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «[...]␤», List has not been iterated on!</span>

<span class="pl-c"><span class="pl-c">#</span> This works and will only do as much work as is needed.</span>
<span class="pl-k">for</span> @lazy-array { <span class="pl-k">.</span><span class="pl-c1">print</span> };

<span class="pl-c"><span class="pl-c">#</span> (**TODO** explain that gather/take and map are all lazy)</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 16.3 `sink` - an `eager` that discards the results by forcing sink context.</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-k">constant</span> nilthingie <span class="pl-k">=</span> sink <span class="pl-k">for</span> <span class="pl-k">^</span><span class="pl-c1">3</span> { <span class="pl-k">.</span><span class="pl-c1">say</span> } <span class="pl-c"><span class="pl-c">#</span>=&gt; 0 1 2</span>
<span class="pl-c1">say</span> nilthingie<span class="pl-k">.</span><span class="pl-c1">perl</span>;                       <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Nil␤»</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 16.4 `quietly` - suppresses warnings in blocks.</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-k">quietly</span> { <span class="pl-k">warn</span> <span class="pl-s"><span class="pl-pds">'</span>This is a warning!<span class="pl-pds">'</span></span> }; <span class="pl-c"><span class="pl-c">#</span> No output</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 17. More operators thingies!</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> Everybody loves operators! Let's get more of them.</span>

<span class="pl-c"><span class="pl-c">#</span> The precedence list can be found here:</span>
<span class="pl-c"><span class="pl-c">#</span> https://docs.raku.org/language/operators#Operator_Precedence</span>
<span class="pl-c"><span class="pl-c">#</span> But first, we need a little explanation about associativity:</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 17.1 Binary operators</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-k">my</span> ($p, $q, $r) <span class="pl-k">=</span> (<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>);

<span class="pl-c"><span class="pl-c">#</span> Given some binary operator § (not a Raku-supported operator), then:</span>

<span class="pl-c"><span class="pl-c">#</span> $p § $q § $r; # with a left-associative  §, this is ($p § $q) § $r</span>
<span class="pl-c"><span class="pl-c">#</span> $p § $q § $r; # with a right-associative §, this is $p § ($q § $r)</span>
<span class="pl-c"><span class="pl-c">#</span> $p § $q § $r; # with a non-associative   §, this is illegal</span>
<span class="pl-c"><span class="pl-c">#</span> $p § $q § $r; # with a chain-associative §, this is ($p § $q) and ($q § $r)§</span>
<span class="pl-c"><span class="pl-c">#</span> $p § $q § $r; # with a list-associative  §, this is `infix:&lt;&gt;`</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 17.2 Unary operators</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Given some unary operator § (not a Raku-supported operator), then:</span>
<span class="pl-c"><span class="pl-c">#</span> §$p§ # with left-associative  §, this is (§$p)§</span>
<span class="pl-c"><span class="pl-c">#</span> §$p§ # with right-associative §, this is §($p§)</span>
<span class="pl-c"><span class="pl-c">#</span> §$p§ # with non-associative   §, this is illegal</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 17.3 Create your own operators!</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Okay, you've been reading all of that, so you might want to try something</span>
<span class="pl-c"><span class="pl-c">#</span> more exciting?! I'll tell you a little secret (or not-so-secret):</span>
<span class="pl-c"><span class="pl-c">#</span> In Raku, all operators are actually just funny-looking subroutines.</span>

<span class="pl-c"><span class="pl-c">#</span> You can declare an operator just like you declare a sub. In the following</span>
<span class="pl-c"><span class="pl-c">#</span> example, `prefix` refers to the operator categories (prefix, infix, postfix,</span>
<span class="pl-c"><span class="pl-c">#</span> circumfix, and post-circumfix).</span>
<span class="pl-k">sub</span> prefix:&lt;win&gt;( $winner ) {
	<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>$winner Won!<span class="pl-pds">"</span></span>;
}
win <span class="pl-s"><span class="pl-pds">"</span>The King<span class="pl-pds">"</span></span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «The King Won!␤»</span>

<span class="pl-c"><span class="pl-c">#</span> you can still call the sub with its "full name":</span>
<span class="pl-c1">say</span> <span class="pl-c1">prefix</span><span class="pl-k">:</span>&lt;<span class="pl-s">!</span>&gt;(<span class="pl-c1">True</span>);      <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>
<span class="pl-c1">prefix</span><span class="pl-k">:</span>&lt;<span class="pl-s">win</span>&gt;(<span class="pl-s"><span class="pl-pds">"</span>The Queen<span class="pl-pds">"</span></span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «The Queen Won!␤»</span>

<span class="pl-k">sub</span> postfix:&lt;!&gt;( <span class="pl-c1">Int</span> $n ) {
    [<span class="pl-c1">*</span>] <span class="pl-c1">2</span><span class="pl-k">..</span>$n; <span class="pl-c"><span class="pl-c">#</span> using the reduce meta-operator... See below ;-)!</span>
}
<span class="pl-c1">say</span> <span class="pl-c1">5</span><span class="pl-k">!</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «120␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Postfix operators ('after') have to come *directly* after the term.</span>
<span class="pl-c"><span class="pl-c">#</span> No whitespace. You can use parentheses to disambiguate, i.e. `(5!)!`</span>

<span class="pl-k">sub</span> infix:&lt;times&gt;( <span class="pl-c1">Int</span> $n, <span class="pl-c1">Block</span> $r ) { <span class="pl-c"><span class="pl-c">#</span> infix ('between')</span>
    <span class="pl-k">for</span> <span class="pl-k">^</span>$n {
        <span class="pl-c"><span class="pl-c">#</span> You need the explicit parentheses to call the function in `$r`,</span>
        <span class="pl-c"><span class="pl-c">#</span> else you'd be referring at the code object itself, like with `&amp;r`.</span>
        $r();
    }
}
<span class="pl-c1">3</span> <span class="pl-c1">times</span> <span class="pl-k">-&gt;</span> { <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span> }; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «hello␤hello␤hello␤»</span>

<span class="pl-c"><span class="pl-c">#</span> It's recommended to put spaces around your infix operator calls.</span>

<span class="pl-c"><span class="pl-c">#</span> For circumfix and post-circumfix ones</span>
<span class="pl-k">multi</span> circumfix:&lt;[ ]<span class="pl-k">&gt;</span>( <span class="pl-c1">Int</span> $n ) {
    $n <span class="pl-k">**</span> $n
}
<span class="pl-c1">say</span> [<span class="pl-c1">5</span>]; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «3125␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Circumfix means 'around'. Again, no whitespace.</span>

<span class="pl-k">multi</span> postcircumfix:&lt;{ }<span class="pl-k">&gt;</span>( <span class="pl-c1">Str</span> $s, <span class="pl-c1">Int</span> $idx ) {
    $s<span class="pl-k">.</span><span class="pl-c1">substr</span>($idx, <span class="pl-c1">1</span>);
}
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>{<span class="pl-c1">1</span>}; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «b␤», after the term `"abc"`, and around the index (1)</span>

<span class="pl-c"><span class="pl-c">#</span> Post-circumfix is 'after a term, around something'</span>

<span class="pl-c"><span class="pl-c">#</span> This really means a lot -- because everything in Raku uses this.</span>
<span class="pl-c"><span class="pl-c">#</span> For example, to delete a key from a hash, you use the `:delete` adverb</span>
<span class="pl-c"><span class="pl-c">#</span> (a simple named argument underneath). For instance, the following statements</span>
<span class="pl-c"><span class="pl-c">#</span> are equivalent.</span>
<span class="pl-k">my</span> <span class="pl-k">%</span>person-stans <span class="pl-k">=</span>
    <span class="pl-s"><span class="pl-pds">'</span>Giorno Giovanna<span class="pl-pds">'</span></span>  <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>Gold Experience<span class="pl-pds">'</span></span>,
    <span class="pl-s"><span class="pl-pds">'</span>Bruno Bucciarati<span class="pl-pds">'</span></span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>Sticky Fingers<span class="pl-pds">'</span></span>;
<span class="pl-k">my</span> $<span class="pl-c1">key</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>Bruno Bucciarati<span class="pl-pds">'</span></span>;
<span class="pl-k">%</span>person-stans{$<span class="pl-c1">key</span>}<span class="pl-k">:</span>delete;
<span class="pl-c1">postcircumfix</span><span class="pl-k">:</span>&lt;<span class="pl-s">{ }</span>&gt;( <span class="pl-k">%</span>person-stans, <span class="pl-s"><span class="pl-pds">'</span>Giorno Giovanna<span class="pl-pds">'</span></span>, <span class="pl-k">:</span>delete );
<span class="pl-c"><span class="pl-c">#</span> (you can call operators like this)</span>

<span class="pl-c"><span class="pl-c">#</span> It's *all* using the same building blocks! Syntactic categories</span>
<span class="pl-c"><span class="pl-c">#</span> (prefix infix ...), named arguments (adverbs), ..., etc. used to build</span>
<span class="pl-c"><span class="pl-c">#</span> the language - are available to you. Obviously, you're advised against</span>
<span class="pl-c"><span class="pl-c">#</span> making an operator out of *everything* -- with great power comes great</span>
<span class="pl-c"><span class="pl-c">#</span> responsibility.</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 17.4 Meta operators!</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Oh boy, get ready!. Get ready, because we're delving deep into the rabbit's</span>
<span class="pl-c"><span class="pl-c">#</span> hole, and you probably won't want to go back to other languages after</span>
<span class="pl-c"><span class="pl-c">#</span> reading this. (I'm guessing you don't want to go back at this point but</span>
<span class="pl-c"><span class="pl-c">#</span> let's continue, for the journey is long and enjoyable!).</span>

<span class="pl-c"><span class="pl-c">#</span> Meta-operators, as their name suggests, are *composed* operators. Basically,</span>
<span class="pl-c"><span class="pl-c">#</span> they're operators that act on another operators.</span>

<span class="pl-c"><span class="pl-c">#</span> The reduce meta-operator is a prefix meta-operator that takes a binary</span>
<span class="pl-c"><span class="pl-c">#</span> function and one or many lists. If it doesn't get passed any argument,</span>
<span class="pl-c"><span class="pl-c">#</span> it either returns a "default value" for this operator (a meaningless value)</span>
<span class="pl-c"><span class="pl-c">#</span> or `Any` if there's none (examples below). Otherwise, it pops an element</span>
<span class="pl-c"><span class="pl-c">#</span> from the list(s) one at a time, and applies the binary function to the last</span>
<span class="pl-c"><span class="pl-c">#</span> result (or the first element of a list) and the popped element.</span>

<span class="pl-c"><span class="pl-c">#</span> To sum a list, you could use the reduce meta-operator with `+`, i.e.:</span>
<span class="pl-c1">say</span> [<span class="pl-k">+</span>] <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «6␤», equivalent to (1+2)+3.</span>

<span class="pl-c"><span class="pl-c">#</span> To multiply a list</span>
<span class="pl-c1">say</span> [<span class="pl-c1">*</span>] <span class="pl-c1">1</span><span class="pl-k">..</span><span class="pl-c1">5</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «120␤», equivalent to ((((1*2)*3)*4)*5).</span>

<span class="pl-c"><span class="pl-c">#</span> You can reduce with any operator, not just with mathematical ones.</span>
<span class="pl-c"><span class="pl-c">#</span> For example, you could reduce with `//` to get first defined element</span>
<span class="pl-c"><span class="pl-c">#</span> of a list:</span>
<span class="pl-c1">say</span> [//] <span class="pl-c1">Nil</span>, <span class="pl-c1">Any</span>, <span class="pl-c1">False</span>, <span class="pl-c1">1</span>, <span class="pl-c1">5</span>;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>
                                 <span class="pl-c"><span class="pl-c">#</span> (Falsey, but still defined)</span>
<span class="pl-c"><span class="pl-c">#</span> Or with relational operators, i.e., `&gt;` to check elements of a list</span>
<span class="pl-c"><span class="pl-c">#</span> are ordered accordingly:</span>
<span class="pl-c1">say</span> [<span class="pl-k">&gt;</span>] <span class="pl-c1">234</span>, <span class="pl-c1">156</span>, <span class="pl-c1">6</span>, <span class="pl-c1">3</span>, <span class="pl-c1">-20</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Default value examples:</span>
<span class="pl-c1">say</span> [<span class="pl-c1">*</span>] (); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «1␤», empty product</span>
<span class="pl-c1">say</span> [<span class="pl-k">+</span>] (); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «0␤», empty sum</span>
<span class="pl-c1">say</span> [//];   <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «(Any)␤»</span>
            <span class="pl-c"><span class="pl-c">#</span> There's no "default value" for `//`.</span>

<span class="pl-c"><span class="pl-c">#</span> You can also use it with a function you made up,</span>
<span class="pl-c"><span class="pl-c">#</span> You can also surround  using double brackets:</span>
<span class="pl-k">sub</span> add($a, $b) { $a <span class="pl-k">+</span> $b }
<span class="pl-c1">say</span> [[&amp;add]] <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «6␤»</span>

<span class="pl-c"><span class="pl-c">#</span> The zip meta-operator is an infix meta-operator that also can be used as a</span>
<span class="pl-c"><span class="pl-c">#</span> "normal" operator. It takes an optional binary function (by default, it</span>
<span class="pl-c"><span class="pl-c">#</span> just creates a pair), and will pop one value off of each array and call</span>
<span class="pl-c"><span class="pl-c">#</span> its binary function on these until it runs out of elements. It returns an</span>
<span class="pl-c"><span class="pl-c">#</span> array with all of these new elements.</span>
<span class="pl-c1">say</span> (<span class="pl-c1">1</span>, <span class="pl-c1">2</span>) <span class="pl-k">Z</span> (<span class="pl-c1">3</span>, <span class="pl-c1">4</span>); <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «((1, 3), (2, 4))␤»</span>
<span class="pl-c1">say</span> <span class="pl-c1">1</span><span class="pl-k">..</span><span class="pl-c1">3</span> <span class="pl-k">Z</span><span class="pl-k">+</span> <span class="pl-c1">4</span><span class="pl-k">..</span><span class="pl-c1">6</span>;    <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «(5, 7, 9)␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Since `Z` is list-associative (see the list above), you can use it on more</span>
<span class="pl-c"><span class="pl-c">#</span> than one list.</span>
(<span class="pl-c1">True</span>, <span class="pl-c1">False</span>) <span class="pl-k">Z</span><span class="pl-k">||</span> (<span class="pl-c1">False</span>, <span class="pl-c1">False</span>) <span class="pl-k">Z</span><span class="pl-k">||</span> (<span class="pl-c1">False</span>, <span class="pl-c1">False</span>); <span class="pl-c"><span class="pl-c">#</span> (True, False)</span>

<span class="pl-c"><span class="pl-c">#</span> And, as it turns out, you can also use the reduce meta-operator with it:</span>
[<span class="pl-k">Z</span><span class="pl-k">||</span>] (<span class="pl-c1">True</span>, <span class="pl-c1">False</span>), (<span class="pl-c1">False</span>, <span class="pl-c1">False</span>), (<span class="pl-c1">False</span>, <span class="pl-c1">False</span>); <span class="pl-c"><span class="pl-c">#</span> (True, False)</span>

<span class="pl-c"><span class="pl-c">#</span> And to end the operator list:</span>

<span class="pl-c"><span class="pl-c">#</span> The sequence operator (`...`) is one of Raku's most powerful features:</span>
<span class="pl-c"><span class="pl-c">#</span> It's composed by the list (which might include a closure) you want Raku to</span>
<span class="pl-c"><span class="pl-c">#</span> deduce from on the left and a value (or either a predicate or a Whatever Star</span>
<span class="pl-c"><span class="pl-c">#</span> for a lazy infinite list) on the right that states when to stop.</span>

<span class="pl-c"><span class="pl-c">#</span> Basic arithmetic sequence</span>
<span class="pl-k">my</span> @listv0 <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span><span class="pl-k">...</span><span class="pl-c1">10</span>;

<span class="pl-c"><span class="pl-c">#</span> This dies because Raku can't figure out the end</span>
<span class="pl-c"><span class="pl-c">#</span> my @list = 1, 3, 6...10;</span>

<span class="pl-c"><span class="pl-c">#</span> As with ranges, you can exclude the last element (the iteration ends when</span>
<span class="pl-c"><span class="pl-c">#</span> the predicate matches).</span>
<span class="pl-k">my</span> @listv1 <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span><span class="pl-k">...</span><span class="pl-k">^</span><span class="pl-c1">10</span>;

<span class="pl-c"><span class="pl-c">#</span> You can use a predicate (with the Whatever Star).</span>
<span class="pl-k">my</span> @listv2 <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">9</span><span class="pl-k">...</span><span class="pl-k">*</span> <span class="pl-k">&gt;</span> <span class="pl-c1">30</span>;

<span class="pl-c"><span class="pl-c">#</span> Equivalent to the example above but using a block here.</span>
<span class="pl-k">my</span> @listv3 <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">9</span> <span class="pl-k">...</span> { <span class="pl-k">$_</span> <span class="pl-k">&gt;</span> <span class="pl-c1">30</span> };

<span class="pl-c"><span class="pl-c">#</span> Lazy infinite list of fibonacci sequence, computed using a closure!</span>
<span class="pl-k">my</span> @fibv0 <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-k">*+*</span> <span class="pl-k">...</span> <span class="pl-k">*</span>;

<span class="pl-c"><span class="pl-c">#</span> Equivalent to the above example but using a pointy block.</span>
<span class="pl-k">my</span> @fibv1 <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-k">-&gt;</span> $a, $b { $a <span class="pl-k">+</span> $b } <span class="pl-k">...</span> <span class="pl-k">*</span>;

<span class="pl-c"><span class="pl-c">#</span> Equivalent to the above example but using a block with placeholder parameters.</span>
<span class="pl-k">my</span> @fibv2 <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, { $<span class="pl-k">^</span>a <span class="pl-k">+</span> $<span class="pl-k">^</span>b } <span class="pl-k">...</span> <span class="pl-k">*</span>;

<span class="pl-c"><span class="pl-c">#</span> In the examples with explicit parameters (i.e., $a and $b), $a and $b</span>
<span class="pl-c"><span class="pl-c">#</span> will always take the previous values, meaning that for the Fibonacci sequence,</span>
<span class="pl-c"><span class="pl-c">#</span> they'll start with $a = 1 and $b = 1 (values we set by hand), then $a = 1</span>
<span class="pl-c"><span class="pl-c">#</span> and $b = 2 (result from previous $a + $b), and so on.</span>

<span class="pl-c"><span class="pl-c">#</span> In the example we use a range as an index to access the sequence. However,</span>
<span class="pl-c"><span class="pl-c">#</span> it's worth noting that for ranges, once reified, elements aren't re-calculated.</span>
<span class="pl-c"><span class="pl-c">#</span> That's why, for instance, `@primes[^100]` will take a long time the first</span>
<span class="pl-c"><span class="pl-c">#</span> time you print it but then it will be instantaneous.</span>
<span class="pl-c1">say</span> @fibv0[<span class="pl-k">^</span><span class="pl-c1">10</span>]; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «1 1 2 3 5 8 13 21 34 55␤»</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 18. Regular Expressions</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> I'm sure a lot of you have been waiting for this one. Well, now that you know</span>
<span class="pl-c"><span class="pl-c">#</span> a good deal of Raku already, we can get started. First off, you'll have to</span>
<span class="pl-c"><span class="pl-c">#</span> forget about "PCRE regexps" (perl-compatible regexps).</span>

<span class="pl-c"><span class="pl-c">#</span> IMPORTANT: Don't skip them because you know PCRE. They're different. Some</span>
<span class="pl-c"><span class="pl-c">#</span> things are the same (like `?`, `+`, and `*`), but sometimes the semantics</span>
<span class="pl-c"><span class="pl-c">#</span> change (`|`). Make sure you read carefully, because you might trip over a</span>
<span class="pl-c"><span class="pl-c">#</span> new behavior.</span>

<span class="pl-c"><span class="pl-c">#</span> Raku has many features related to RegExps. After all, Rakudo parses itself.</span>
<span class="pl-c"><span class="pl-c">#</span> We're first going to look at the syntax itself, then talk about grammars</span>
<span class="pl-c"><span class="pl-c">#</span> (PEG-like), differences between `token`, `regex` and `rule` declarators,</span>
<span class="pl-c"><span class="pl-c">#</span> and some more. Side note: you still have access to PCRE regexps using the</span>
<span class="pl-c"><span class="pl-c">#</span> `:P5` modifier which we won't be discussing this in this tutorial, though.</span>

<span class="pl-c"><span class="pl-c">#</span> In essence, Raku natively implements PEG ("Parsing Expression Grammars").</span>
<span class="pl-c"><span class="pl-c">#</span> The pecking order for ambiguous parses is determined by a multi-level</span>
<span class="pl-c"><span class="pl-c">#</span> tie-breaking test:</span>
<span class="pl-c"><span class="pl-c">#</span>  - Longest token matching: `foo\s+` beats `foo` (by 2 or more positions)</span>
<span class="pl-c"><span class="pl-c">#</span>  - Longest literal prefix: `food\w*` beats `foo\w*` (by 1)</span>
<span class="pl-c"><span class="pl-c">#</span>  - Declaration from most-derived to less derived grammars</span>
<span class="pl-c"><span class="pl-c">#</span>    (grammars are actually classes)</span>
<span class="pl-c"><span class="pl-c">#</span>  - Earliest declaration wins</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr">a</span>/;   <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», more readable with some spaces!</span>

<span class="pl-c"><span class="pl-c">#</span> In all our examples, we're going to use the smart-matching operator against</span>
<span class="pl-c"><span class="pl-c">#</span> a regexp. We're converting the result using `so` to a Boolean value because,</span>
<span class="pl-c"><span class="pl-c">#</span> in fact, it's returning a `Match` object. They know how to respond to list</span>
<span class="pl-c"><span class="pl-c">#</span> indexing, hash indexing, and return the matched string. The results of the</span>
<span class="pl-c"><span class="pl-c">#</span> match are available in the `$/` variable (implicitly lexically-scoped). You</span>
<span class="pl-c"><span class="pl-c">#</span> can also use the capture variables which start at 0: `$0`, `$1', `$2`...</span>

<span class="pl-c"><span class="pl-c">#</span> You can also note that `~~` does not perform start/end checking, meaning</span>
<span class="pl-c"><span class="pl-c">#</span> the regexp can be matched with just one character of the string. We'll</span>
<span class="pl-c"><span class="pl-c">#</span> explain later how you can do it.</span>

<span class="pl-c"><span class="pl-c">#</span> In Raku, you can have any alphanumeric as a literal, everything else has</span>
<span class="pl-c"><span class="pl-c">#</span> to be escaped by using a backslash or quotes.</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>a|b<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a <span class="pl-s">'|'</span> b </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», it wouldn't mean the same</span>
                             <span class="pl-c"><span class="pl-c">#</span> thing if `|` wasn't escaped.</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>a|b<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a \| b </span>/;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», another way to escape it.</span>

<span class="pl-c"><span class="pl-c">#</span> The whitespace in a regex is actually not significant, unless you use the</span>
<span class="pl-c"><span class="pl-c">#</span> `:s` (`:sigspace`, significant space) adverb.</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>a b c<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b  c </span>/; <span class="pl-c"><span class="pl-c">#</span>=&gt; `False`, space is not significant here!</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>a b c<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"><span class="pl-en">:s</span> a b c </span>/; <span class="pl-c"><span class="pl-c">#</span>=&gt; `True`, we added the modifier `:s` here.</span>

<span class="pl-c"><span class="pl-c">#</span> If we use only one space between strings in a regex, Raku will warn us</span>
<span class="pl-c"><span class="pl-c">#</span> about space being not signicant in the regex:</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>a b c<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a b c </span>/;   <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>a b c<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b  c </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False»</span>

<span class="pl-c"><span class="pl-c">#</span> NOTE: Please use quotes or `:s` (`:sigspace`) modifier (or, to suppress this</span>
<span class="pl-c"><span class="pl-c">#</span> warning, omit the space, or otherwise change the spacing). To fix this and make</span>
<span class="pl-c"><span class="pl-c">#</span> the spaces less ambiguous, either use at least two spaces between strings</span>
<span class="pl-c"><span class="pl-c">#</span> or use the `:s` adverb.</span>

<span class="pl-c"><span class="pl-c">#</span> As we saw before, we can embed the `:s` inside the slash delimiters, but we</span>
<span class="pl-c"><span class="pl-c">#</span> can also put it outside of them if we specify `m` for 'match':</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>a b c<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> <span class="pl-sr">m</span><span class="pl-en">:s</span>/<span class="pl-sr">a  b  c</span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>

<span class="pl-c"><span class="pl-c">#</span> By using `m` to specify 'match', we can also use other delimiters:</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> <span class="pl-sr">m</span>{a  b  c};     <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> <span class="pl-sr">m</span>[<span class="pl-sr">a  b  c</span>];     <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>

<span class="pl-c"><span class="pl-c">#</span> `m/.../` is equivalent to `/.../`:</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>raku<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> <span class="pl-sr">m</span>/<span class="pl-sr">raku</span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>raku<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr">raku</span>/;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Use the `:i` adverb to specify case insensitivity:</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>ABC<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> <span class="pl-sr">m</span><span class="pl-en">:i</span>{a  b  c};   <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>

<span class="pl-c"><span class="pl-c">#</span> However, whitespace is important as for how modifiers are applied</span>
<span class="pl-c"><span class="pl-c">#</span> (which you'll see just below) ...</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 18.1 Quantifiers - `?`, `+`, `*` and `**`.</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> `?` - zero or one match</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>ac<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b  c </span>/;   <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>ac<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">?</span>  c </span>/;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», the "b" matched 0 times.</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">?</span>  c </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», the "b" matched 1 time.</span>

<span class="pl-c"><span class="pl-c">#</span> ... As you read before, whitespace is important because it determines which</span>
<span class="pl-c"><span class="pl-c">#</span> part of the regex is the target of the modifier:</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>def<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b  c<span class="pl-k">?</span> </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤», only the "c" is optional</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>def<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">?</span>  c </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤», whitespace is not significant</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>def<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> <span class="pl-s">'abc'</span><span class="pl-k">?</span> </span>/;   <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»,  the whole "abc" group is optional</span>

<span class="pl-c"><span class="pl-c">#</span> Here (and below) the quantifier applies only to the "b"</span>

<span class="pl-c"><span class="pl-c">#</span> `+` - one or more matches</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>ac<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">+</span>  c </span>/;     <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤», `+` wants at least one 'b'</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">+</span>  c </span>/;    <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», one is enough</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>abbbbc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">+</span>  c </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», matched 4 "b"s</span>

<span class="pl-c"><span class="pl-c">#</span> `*` - zero or more matches</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>ac<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">*</span>  c </span>/;     <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», they're all optional</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">*</span>  c </span>/;    <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>abbbbc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">*</span>  c </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>aec<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">*</span>  c </span>/;    <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤», "b"(s) are optional, not replaceable.</span>

<span class="pl-c"><span class="pl-c">#</span> `**` - (Unbound) Quantifier</span>
<span class="pl-c"><span class="pl-c">#</span> If you squint hard enough, you might understand why exponentiation is used</span>
<span class="pl-c"><span class="pl-c">#</span> for quantity.</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">**</span>1  c </span>/;         <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», exactly one time</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">**</span>1<span class="pl-k">..</span>3  c </span>/;      <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», one to three times</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>abbbc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">**</span>1<span class="pl-k">..</span>3  c </span>/;    <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>abbbbbbc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">**</span>1<span class="pl-k">..</span>3  c </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Fals␤», too much</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>abbbbbbc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a  b<span class="pl-k">**</span>3<span class="pl-k">..</span><span class="pl-smi">*</span>  c </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», infinite ranges are ok</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 18.2 `&lt;[]&gt;` - Character classes</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Character classes are the equivalent of PCRE's `[]` classes, but they use a</span>
<span class="pl-c"><span class="pl-c">#</span> more raku-ish syntax:</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>fooa<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> f &lt;<span class="pl-k">[</span><span class="pl-c1"> o a </span><span class="pl-k">]</span>&gt;<span class="pl-k">+</span> </span>/;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «fooa␤»</span>

<span class="pl-c"><span class="pl-c">#</span> You can use ranges (`..`):</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>aeiou<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a &lt;<span class="pl-k">[</span><span class="pl-c1"> e..w </span><span class="pl-k">]</span>&gt; </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «ae␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Just like in normal regexes, if you want to use a special character, escape</span>
<span class="pl-c"><span class="pl-c">#</span> it (the last one is escaping a space which would be equivalent to using</span>
<span class="pl-c"><span class="pl-c">#</span> ' '):</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>he-he !<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> <span class="pl-s">'he-'</span> &lt;<span class="pl-k">[</span><span class="pl-c1"> a..z \! \  </span><span class="pl-k">]</span>&gt; <span class="pl-k">+</span> </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «he-he !␤»</span>

<span class="pl-c"><span class="pl-c">#</span> You'll get a warning if you put duplicate names (which has the nice effect</span>
<span class="pl-c"><span class="pl-c">#</span> of catching the raw quoting):</span>
<span class="pl-s"><span class="pl-pds">'</span>he he<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> &lt;<span class="pl-k">[</span><span class="pl-c1"> h e ' ' </span><span class="pl-k">]</span>&gt; </span>/;
<span class="pl-c"><span class="pl-c">#</span> Warns "Repeated character (') unexpectedly found in character class"</span>

<span class="pl-c"><span class="pl-c">#</span> You can also negate character classes... (`&lt;-[]&gt;` equivalent to `[^]` in PCRE)</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> &lt;<span class="pl-k">-</span><span class="pl-k">[</span><span class="pl-c1"> f o </span><span class="pl-k">]</span>&gt; <span class="pl-k">+</span> </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>

<span class="pl-c"><span class="pl-c">#</span> ... and compose them:</span>
<span class="pl-c"><span class="pl-c">#</span> any letter except "f" and "o"</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> &lt;<span class="pl-k">[</span><span class="pl-c1"> a..z </span><span class="pl-k">]</span> <span class="pl-k">-</span> <span class="pl-k">[</span><span class="pl-c1"> f o </span><span class="pl-k">]</span>&gt; <span class="pl-k">+</span> </span>/;   <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>

<span class="pl-c"><span class="pl-c">#</span> no letter except "f" and "o"</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> &lt;<span class="pl-k">-</span><span class="pl-k">[</span><span class="pl-c1"> a..z </span><span class="pl-k">]</span> <span class="pl-k">+</span> <span class="pl-k">[</span><span class="pl-c1"> f o </span><span class="pl-k">]</span>&gt; <span class="pl-k">+</span> </span>/;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>

<span class="pl-c"><span class="pl-c">#</span> the + doesn't replace the left part</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>foo!<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> &lt;<span class="pl-k">-</span><span class="pl-k">[</span><span class="pl-c1"> a..z </span><span class="pl-k">]</span> <span class="pl-k">+</span> <span class="pl-k">[</span><span class="pl-c1"> f o </span><span class="pl-k">]</span>&gt; <span class="pl-k">+</span> </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 18.3 Grouping and capturing</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Group: you can group parts of your regexp with `[]`. Unlike PCRE's `(?:)`,</span>
<span class="pl-c"><span class="pl-c">#</span> these groups are *not* captured.</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a [ b ] c </span>/;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», the grouping does nothing</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>foo012012bar<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> foo [ <span class="pl-s">'01'</span> &lt;<span class="pl-k">[</span><span class="pl-c1">0..9</span><span class="pl-k">]</span>&gt; ] <span class="pl-k">+</span> bar </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>

<span class="pl-c"><span class="pl-c">#</span> The previous line returns `True`. The regex matches "012" one or more time</span>
<span class="pl-c"><span class="pl-c">#</span> (achieved by the the `+` applied to the group).</span>

<span class="pl-c"><span class="pl-c">#</span> But this does not go far enough, because we can't actually get back what</span>
<span class="pl-c"><span class="pl-c">#</span> we matched.</span>

<span class="pl-c"><span class="pl-c">#</span> Capture: The results of a regexp can be *captured* by using parentheses.</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>fooABCABCbar<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> foo ( <span class="pl-s">'A'</span> &lt;<span class="pl-k">[</span><span class="pl-c1">A..Z</span><span class="pl-k">]</span>&gt; <span class="pl-s">'C'</span> ) <span class="pl-k">+</span> bar </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>
<span class="pl-c"><span class="pl-c">#</span> (using `so` here, see `$/` below)</span>

<span class="pl-c"><span class="pl-c">#</span> So, starting with the grouping explanations. As we said before, our `Match`</span>
<span class="pl-c"><span class="pl-c">#</span> object is stored inside the `$/` variable:</span>
<span class="pl-c1">say</span> <span class="pl-k">$/</span>;    <span class="pl-c"><span class="pl-c">#</span> Will either print the matched object or `Nil` if nothing matched.</span>

<span class="pl-c"><span class="pl-c">#</span> As we also said before, it has array indexing:</span>
<span class="pl-c1">say</span> <span class="pl-k">$/</span>[<span class="pl-c1">0</span>]; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «｢ABC｣ ｢ABC｣␤»,</span>

<span class="pl-c"><span class="pl-c">#</span> The corner brackets (｢..｣) represent (and are) `Match` objects. In the</span>
<span class="pl-c"><span class="pl-c">#</span> previous example, we have an array of them.</span>

<span class="pl-c1">say</span> <span class="pl-k">$0</span>;    <span class="pl-c"><span class="pl-c">#</span> The same as above.</span>

<span class="pl-c"><span class="pl-c">#</span> Our capture is `$0` because it's the first and only one capture in the</span>
<span class="pl-c"><span class="pl-c">#</span> regexp. You might be wondering why it's an array, and the answer is simple:</span>
<span class="pl-c"><span class="pl-c">#</span> Some captures (indexed using `$0`, `$/[0]` or a named one) will be an array</span>
<span class="pl-c"><span class="pl-c">#</span> if and only if they can have more than one element. Thus any capture with</span>
<span class="pl-c"><span class="pl-c">#</span> `*`, `+` and `**` (whatever the operands), but not with `?`.</span>
<span class="pl-c"><span class="pl-c">#</span> Let's use examples to see that:</span>

<span class="pl-c"><span class="pl-c">#</span> NOTE: We quoted A B C to demonstrate that the whitespace between them isn't</span>
<span class="pl-c"><span class="pl-c">#</span> significant. If we want the whitespace to *be* significant there, we can use the</span>
<span class="pl-c"><span class="pl-c">#</span> `:sigspace` modifier.</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>fooABCbar<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> foo ( <span class="pl-s">"A"</span> <span class="pl-s">"B"</span> <span class="pl-s">"C"</span> )<span class="pl-k">?</span> bar </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>
<span class="pl-c1">say</span> <span class="pl-k">$/</span>[<span class="pl-c1">0</span>];   <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «｢ABC｣␤»</span>
<span class="pl-c1">say</span> <span class="pl-k">$0</span><span class="pl-k">.</span><span class="pl-c1">WHAT</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «(Match)␤»</span>
             <span class="pl-c"><span class="pl-c">#</span> There can't be more than one, so it's only a single match object.</span>

<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>foobar<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> foo ( <span class="pl-s">"A"</span> <span class="pl-s">"B"</span> <span class="pl-s">"C"</span> )<span class="pl-k">?</span> bar </span>/;    <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>
<span class="pl-c1">say</span> <span class="pl-k">$0</span><span class="pl-k">.</span><span class="pl-c1">WHAT</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «(Any)␤», this capture did not match, so it's empty.</span>

<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>foobar<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> foo ( <span class="pl-s">"A"</span> <span class="pl-s">"B"</span> <span class="pl-s">"C"</span> ) <span class="pl-k">**</span> 0<span class="pl-k">..</span>1 bar </span>/; <span class="pl-c"><span class="pl-c">#</span>=&gt; OUTPUT: «True␤»</span>
<span class="pl-c1">say</span> <span class="pl-k">$0</span><span class="pl-k">.</span><span class="pl-c1">WHAT</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «(Array)␤», A specific quantifier will always capture</span>
             <span class="pl-c"><span class="pl-c">#</span> an Array, be a range or a specific value (even 1).</span>

<span class="pl-c"><span class="pl-c">#</span> The captures are indexed per nesting. This means a group in a group will be</span>
<span class="pl-c"><span class="pl-c">#</span> nested under its parent group: `$/[0][0]`, for this code:</span>
<span class="pl-s"><span class="pl-pds">'</span>hello-~-world<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> ( <span class="pl-s">'hello'</span> ( &lt;<span class="pl-k">[</span><span class="pl-c1"> \- \~ </span><span class="pl-k">]</span>&gt; <span class="pl-k">+</span> ) ) <span class="pl-s">'world'</span> </span>/;
<span class="pl-c1">say</span> <span class="pl-k">$/</span>[<span class="pl-c1">0</span>]<span class="pl-k">.</span><span class="pl-c1">Str</span>;    <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «hello~␤»</span>
<span class="pl-c1">say</span> <span class="pl-k">$/</span>[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>]<span class="pl-k">.</span><span class="pl-c1">Str</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «~␤»</span>

<span class="pl-c"><span class="pl-c">#</span> This stems from a very simple fact: `$/` does not contain strings, integers</span>
<span class="pl-c"><span class="pl-c">#</span> or arrays, it only contains `Match` objects. These contain the `.list`, `.hash`</span>
<span class="pl-c"><span class="pl-c">#</span> and `.Str` methods but you can also just use `match&lt;key&gt;` for hash access</span>
<span class="pl-c"><span class="pl-c">#</span> and `match[idx]` for array access.</span>

<span class="pl-c"><span class="pl-c">#</span> In the following example, we can see `$_` is a list of `Match` objects.</span>
<span class="pl-c"><span class="pl-c">#</span> Each of them contain a wealth of information: where the match started/ended,</span>
<span class="pl-c"><span class="pl-c">#</span> the "ast" (see actions later), etc. You'll see named capture below with</span>
<span class="pl-c"><span class="pl-c">#</span> grammars.</span>
<span class="pl-c1">say</span> <span class="pl-k">$/</span>[<span class="pl-c1">0</span>]<span class="pl-k">.</span>list<span class="pl-k">.</span><span class="pl-c1">perl</span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «(Match.new(...),).list␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Alternation - the `or` of regexes</span>
<span class="pl-c"><span class="pl-c">#</span> WARNING: They are DIFFERENT from PCRE regexps.</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a [ b <span class="pl-c1">|</span> y ] c </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», Either "b" or "y".</span>
<span class="pl-c1">say</span> <span class="pl-k">so</span> <span class="pl-s"><span class="pl-pds">'</span>ayc<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> a [ b <span class="pl-c1">|</span> y ] c </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤», Obviously enough...</span>

<span class="pl-c"><span class="pl-c">#</span> The difference between this `|` and the one you're used to is</span>
<span class="pl-c"><span class="pl-c">#</span> LTM ("Longest Token Matching") strategy. This means that the engine will</span>
<span class="pl-c"><span class="pl-c">#</span> always try to match as much as possible in the string.</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> fo <span class="pl-c1">|</span> foo </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «foo», instead of `fo`, because it's longer.</span>

<span class="pl-c"><span class="pl-c">#</span> To decide which part is the "longest", it first splits the regex in two parts:</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span>     * The "declarative prefix" (the part that can be statically analyzed)</span>
<span class="pl-c"><span class="pl-c">#</span>     which includes alternations (`|`), conjunctions (`&amp;`), sub-rule calls (not</span>
<span class="pl-c"><span class="pl-c">#</span>     yet introduced), literals, characters classes and quantifiers.</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span>     * The "procedural part" includes everything else: back-references,</span>
<span class="pl-c"><span class="pl-c">#</span>     code assertions, and other things that can't traditionally be represented</span>
<span class="pl-c"><span class="pl-c">#</span>     by normal regexps.</span>

<span class="pl-c"><span class="pl-c">#</span> Then, all the alternatives are tried at once, and the longest wins.</span>

<span class="pl-c"><span class="pl-c">#</span> Examples:</span>
<span class="pl-c"><span class="pl-c">#</span> DECLARATIVE | PROCEDURAL</span>
/<span class="pl-sr"> <span class="pl-s">'foo'</span> <span class="pl-cce">\d</span><span class="pl-k">+</span>     [ &lt;<span class="pl-smi">subrule1</span>&gt; <span class="pl-c1">||</span> &lt;<span class="pl-smi">subrule2</span>&gt; ] </span>/;

<span class="pl-c"><span class="pl-c">#</span> DECLARATIVE (nested groups are not a problem)</span>
/<span class="pl-sr"> <span class="pl-cce">\s</span><span class="pl-k">*</span> [ <span class="pl-cce">\w</span> &amp; b ] [ c <span class="pl-c1">|</span> d ] </span>/;

<span class="pl-c"><span class="pl-c">#</span> However, closures and recursion (of named regexes) are procedural.</span>
<span class="pl-c"><span class="pl-c">#</span> There are also more complicated rules, like specificity (literals win</span>
<span class="pl-c"><span class="pl-c">#</span> over character classes).</span>

<span class="pl-c"><span class="pl-c">#</span> NOTE: The alternation in which all the branches are tried in order</span>
<span class="pl-c"><span class="pl-c">#</span> until the first one matches still exists, but is now spelled `||`.</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span> <span class="pl-k">~~</span> /<span class="pl-sr"> fo <span class="pl-c1">||</span> foo </span>/; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «fo␤», in this case.</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 19. Extra: the MAIN subroutine</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> The `MAIN` subroutine is called when you run a Raku file directly. It's</span>
<span class="pl-c"><span class="pl-c">#</span> very powerful, because Raku actually parses the arguments and pass them</span>
<span class="pl-c"><span class="pl-c">#</span> as such to the sub. It also handles named argument (`--foo`) and will even</span>
<span class="pl-c"><span class="pl-c">#</span> go as far as to autogenerate a `--help` flag.</span>

<span class="pl-k">sub</span> MAIN($<span class="pl-c1">name</span>) {
    <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>Hello, $name!<span class="pl-pds">"</span></span>;
}
<span class="pl-c"><span class="pl-c">#</span> Supposing the code above is in file named cli.raku, then running in the command</span>
<span class="pl-c"><span class="pl-c">#</span> line (e.g., $ raku cli.raku) produces:</span>
<span class="pl-c"><span class="pl-c">#</span> Usage:</span>
<span class="pl-c"><span class="pl-c">#</span> cli.raku &lt;name&gt;</span>

<span class="pl-c"><span class="pl-c">#</span> And since MAIN is a regular Raku sub, you can have multi-dispatch:</span>
<span class="pl-c"><span class="pl-c">#</span> (using a `Bool` for the named argument so that we can do `--replace`</span>
<span class="pl-c"><span class="pl-c">#</span> instead of `--replace=1`. The presence of `--replace` indicates truthness</span>
<span class="pl-c"><span class="pl-c">#</span> while its absence falseness). For example:</span>

    <span class="pl-c"><span class="pl-c">#</span> convert to IO object to check the file exists</span>
    <span class="pl-k">=</span><span class="pl-k">begin</span> <span class="pl-e">comment</span><span class="pl-c"></span>
<span class="pl-c">    subset File of Str where *.IO.d;</span>
<span class="pl-c"></span>
<span class="pl-c">    multi MAIN('add', $key, $value, Bool :$replace) { ... }</span>
<span class="pl-c">    multi MAIN('remove', $key) { ... }</span>
<span class="pl-c">    multi MAIN('import', File, Str :$as) { ... } # omitting parameter name</span>
<span class="pl-c"></span>    <span class="pl-k">=</span><span class="pl-k">end</span> <span class="pl-e">comment</span>

<span class="pl-c"><span class="pl-c">#</span> Thus $ raku cli.raku produces:</span>
<span class="pl-c"><span class="pl-c">#</span> Usage:</span>
<span class="pl-c"><span class="pl-c">#</span>   cli.raku [--replace] add &lt;key&gt; &lt;value&gt;</span>
<span class="pl-c"><span class="pl-c">#</span>   cli.raku remove &lt;key&gt;</span>
<span class="pl-c"><span class="pl-c">#</span>   cli.raku [--as=&lt;Str&gt;] import &lt;File&gt;</span>

<span class="pl-c"><span class="pl-c">#</span> As you can see, this is *very* powerful. It even went as far as to show inline</span>
<span class="pl-c"><span class="pl-c">#</span> the constants (the type is only displayed if the argument is `$`/is named).</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span> 20. APPENDIX A:</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> It's assumed by now you know the Raku basics. This section is just here to</span>
<span class="pl-c"><span class="pl-c">#</span> list some common operations, but which are not in the "main part" of the</span>
<span class="pl-c"><span class="pl-c">#</span> tutorial to avoid bloating it up.</span>

<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> 20.1 Operators</span>
<span class="pl-c"><span class="pl-c">#</span></span>

<span class="pl-c"><span class="pl-c">#</span> Sort comparison - they return one value of the `Order` enum: `Less`, `Same`</span>
<span class="pl-c"><span class="pl-c">#</span> and `More` (which numerify to -1, 0 or +1 respectively).</span>
<span class="pl-c1">say</span> <span class="pl-c1">1</span> &lt;<span class="pl-s">=</span>&gt; <span class="pl-c1">4</span>;     <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «More␤»,   sort comparison for numerics</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span> <span class="pl-k">leg</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Lessre␤», sort comparison for string</span>
<span class="pl-c1">say</span> <span class="pl-c1">1</span> <span class="pl-k">eqv</span> <span class="pl-c1">1</span>;     <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «Truere␤», sort comparison using eqv semantics</span>
<span class="pl-c1">say</span> <span class="pl-c1">1</span> <span class="pl-k">eqv</span> <span class="pl-c1">1.0</span>;   <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «False␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Generic ordering</span>
<span class="pl-c1">say</span> <span class="pl-c1">3</span> <span class="pl-k">before</span> <span class="pl-c1">4</span>;    <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>
<span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span> <span class="pl-k">after</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Short-circuit default operator - similar to `or` and `||`, but instead</span>
<span class="pl-c"><span class="pl-c">#</span> returns the first *defined* value:</span>
<span class="pl-c1">say</span> <span class="pl-c1">Any</span> <span class="pl-k">//</span> <span class="pl-c1">Nil</span> <span class="pl-k">//</span> <span class="pl-c1">0</span> <span class="pl-k">//</span> <span class="pl-c1">5</span>;        <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «0␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Short-circuit exclusive or (XOR) - returns `True` if one (and only one) of</span>
<span class="pl-c"><span class="pl-c">#</span> its arguments is true</span>
<span class="pl-c1">say</span> <span class="pl-c1">True</span> <span class="pl-k">^^</span> <span class="pl-c1">False</span>;               <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «True␤»</span>

<span class="pl-c"><span class="pl-c">#</span> Flip flops. These operators (`ff` and `fff`, equivalent to P5's `..`</span>
<span class="pl-c"><span class="pl-c">#</span> and `...`) are operators that take two predicates to test: They are `False`</span>
<span class="pl-c"><span class="pl-c">#</span> until their left side returns `True`, then are `True` until their right</span>
<span class="pl-c"><span class="pl-c">#</span> side returns `True`. Similar to ranges, you can exclude the iteration when</span>
<span class="pl-c"><span class="pl-c">#</span> it become `True`/`False` by using `^` on either side. Let's start with an</span>
<span class="pl-c"><span class="pl-c">#</span> example :</span>

<span class="pl-k">for</span> &lt;<span class="pl-s">well met young hero we shall meet later</span>&gt; {
    <span class="pl-c"><span class="pl-c">#</span> by default, `ff`/`fff` smart-match (`~~`) against `$_`:</span>
    <span class="pl-k">if</span> <span class="pl-s"><span class="pl-pds">'</span>met<span class="pl-pds">'</span></span> <span class="pl-k">^</span><span class="pl-k">ff</span> <span class="pl-s"><span class="pl-pds">'</span>meet<span class="pl-pds">'</span></span> { <span class="pl-c"><span class="pl-c">#</span> Won't enter the if for "met"</span>
        <span class="pl-k">.</span><span class="pl-c1">say</span>              <span class="pl-c"><span class="pl-c">#</span> (explained in details below).</span>
    }

    <span class="pl-k">if</span> <span class="pl-c1">rand</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">ff</span> <span class="pl-c1">rand</span> <span class="pl-k">==</span> <span class="pl-c1">1</span> { <span class="pl-c"><span class="pl-c">#</span> compare variables other than `$_`</span>
        <span class="pl-c1">say</span> <span class="pl-s"><span class="pl-pds">"</span>This ... probably will never run ...<span class="pl-pds">"</span></span>;
    }
}

<span class="pl-c"><span class="pl-c">#</span> This will print "young hero we shall meet" (excluding "met"): the flip-flop</span>
<span class="pl-c"><span class="pl-c">#</span> will start returning `True` when it first encounters "met" (but will still</span>
<span class="pl-c"><span class="pl-c">#</span> return `False` for "met" itself, due to the leading `^` on `ff`), until it</span>
<span class="pl-c"><span class="pl-c">#</span> sees "meet", which is when it'll start returning `False`.</span>

<span class="pl-c"><span class="pl-c">#</span> The difference between `ff` (awk-style) and `fff` (sed-style) is that `ff`</span>
<span class="pl-c"><span class="pl-c">#</span> will test its right side right when its left side changes to `True`, and can</span>
<span class="pl-c"><span class="pl-c">#</span> get back to `False` right away (*except* it'll be `True` for the iteration</span>
<span class="pl-c"><span class="pl-c">#</span> that matched) while `fff` will wait for the next iteration to try its right</span>
<span class="pl-c"><span class="pl-c">#</span> side, once its left side changed:</span>

<span class="pl-c"><span class="pl-c">#</span> The output is due to the right-hand-side being tested directly (and returning</span>
<span class="pl-c"><span class="pl-c">#</span> `True`). "B"s are printed since it matched that time (it just went back to</span>
<span class="pl-c"><span class="pl-c">#</span> `False` right away).</span>
<span class="pl-k">.</span><span class="pl-c1">say</span> <span class="pl-k">if</span> <span class="pl-s"><span class="pl-pds">'</span>B<span class="pl-pds">'</span></span> <span class="pl-k">ff</span> <span class="pl-s"><span class="pl-pds">'</span>B<span class="pl-pds">'</span></span> <span class="pl-k">for</span> &lt;<span class="pl-s">A B C B A</span>&gt;; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «B B␤»,</span>

<span class="pl-c"><span class="pl-c">#</span> In this case the right-hand-side wasn't tested until `$_` became "C"</span>
<span class="pl-c"><span class="pl-c">#</span> (and thus did not match instantly).</span>
<span class="pl-k">.</span><span class="pl-c1">say</span> <span class="pl-k">if</span> <span class="pl-s"><span class="pl-pds">'</span>B<span class="pl-pds">'</span></span> <span class="pl-k">fff</span> <span class="pl-s"><span class="pl-pds">'</span>B<span class="pl-pds">'</span></span> <span class="pl-k">for</span> &lt;<span class="pl-s">A B C B A</span>&gt;; <span class="pl-c"><span class="pl-c">#</span>=&gt; «B C B␤»,</span>

<span class="pl-c"><span class="pl-c">#</span> A flip-flop can change state as many times as needed:</span>
<span class="pl-k">for</span> &lt;<span class="pl-s">test start print it stop not printing start print again stop not anymore</span>&gt; {
    <span class="pl-c"><span class="pl-c">#</span> exclude both "start" and "stop",</span>
    <span class="pl-k">.</span><span class="pl-c1">say</span> <span class="pl-k">if</span> <span class="pl-k">$_</span> <span class="pl-k">eq</span> <span class="pl-s"><span class="pl-pds">'</span>start<span class="pl-pds">'</span></span> <span class="pl-k">^</span><span class="pl-k">ff</span><span class="pl-k">^</span> <span class="pl-k">$_</span> <span class="pl-k">eq</span> <span class="pl-s"><span class="pl-pds">'</span>stop<span class="pl-pds">'</span></span>; <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «print it print again␤»</span>
}

<span class="pl-c"><span class="pl-c">#</span> You might also use a Whatever Star, which is equivalent to `True` for the</span>
<span class="pl-c"><span class="pl-c">#</span> left side or `False` for the right, as shown in this example.</span>
<span class="pl-c"><span class="pl-c">#</span> NOTE: the parenthesis are superfluous here (sometimes called "superstitious</span>
<span class="pl-c"><span class="pl-c">#</span> parentheses"). Once the flip-flop reaches a number greater than 50, it'll</span>
<span class="pl-c"><span class="pl-c">#</span> never go back to `False`.</span>
<span class="pl-k">for</span> (<span class="pl-c1">1</span>, <span class="pl-c1">3</span>, <span class="pl-c1">60</span>, <span class="pl-c1">3</span>, <span class="pl-c1">40</span>, <span class="pl-c1">60</span>) {
    <span class="pl-k">.</span><span class="pl-c1">say</span> <span class="pl-k">if</span> <span class="pl-k">$_</span> <span class="pl-k">&gt;</span> <span class="pl-c1">50</span> <span class="pl-k">ff</span> <span class="pl-k">*</span>;  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «60␤3␤40␤60␤»</span>
}

<span class="pl-c"><span class="pl-c">#</span> You can also use this property to create an `if` that'll not go through the</span>
<span class="pl-c"><span class="pl-c">#</span> first time. In this case, the flip-flop is `True` and never goes back to</span>
<span class="pl-c"><span class="pl-c">#</span> `False`, but the `^` makes it *not run* on the first iteration</span>
<span class="pl-k">for</span> &lt;<span class="pl-s">a b c</span>&gt; { <span class="pl-k">.</span><span class="pl-c1">say</span> <span class="pl-k">if</span> <span class="pl-k">*</span> <span class="pl-k">^</span><span class="pl-k">ff</span> <span class="pl-k">*</span>; }  <span class="pl-c"><span class="pl-c">#</span> OUTPUT: «b␤c␤»</span>

<span class="pl-c"><span class="pl-c">#</span> The `===` operator, which uses `.WHICH` on the objects to be compared, is</span>
<span class="pl-c"><span class="pl-c">#</span> the value identity operator whereas the `=:=` operator, which uses `VAR()` on</span>
<span class="pl-c"><span class="pl-c">#</span> the objects to compare them, is the container identity operator.</span></pre></div>
<p>If you want to go further and learn more about Raku, you can:</p>
<ul>
<li>
<p>Read the <a href="https://docs.raku.org/" rel="nofollow">Raku Docs</a>. This is a great<br>
resource on Raku. If you are looking for something, use the search bar.<br>
This will give you a dropdown menu of all the pages referencing your search<br>
term (Much better than using Google to find Raku documents!).</p>
</li>
<li>
<p>Read the <a href="https://rakuadventcalendar.wordpress.com/" rel="nofollow">Raku Advent Calendar</a>. This<br>
is a great source of Raku snippets and explanations. If the docs don't<br>
describe something well enough, you may find more detailed information here.<br>
This information may be a bit older but there are many great examples and<br>
explanations. Posts stopped at the end of 2015 when the language was declared<br>
stable and <code class="notranslate">Raku v6.c</code> was released.</p>
</li>
<li>
<p>Come along on <code class="notranslate">#raku</code> at <a href="https://web.libera.chat/?channel=#raku" rel="nofollow"><code class="notranslate">irc.libera.chat</code></a>. The folks here are<br>
always helpful.</p>
</li>
<li>
<p>Check the <a href="https://github.com/rakudo/rakudo/tree/master/src/core.c">source of Raku's functions and<br>
classes</a>. Rakudo is<br>
mainly written in Raku (with a lot of NQP, "Not Quite Perl", a Raku subset<br>
easier to implement and optimize).</p>
</li>
<li>
<p>Read <a href="https://design.raku.org/" rel="nofollow">the language design documents</a>. They explain<br>
Raku from an implementor point-of-view, but it's still very interesting.</p>
</li>
</ul>
<hr>
<h2>Contributors</h2>
<pre class="notranslate"><code class="notranslate">- ["vendethiel", "http://github.com/vendethiel"]
- ["Samantha McVey", "https://cry.nu"]
</code></pre>