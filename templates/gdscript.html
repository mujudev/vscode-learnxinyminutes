<h1>GDScript</h1>
<p>GDScript is a dynamically typed scripting language made specifically for<br>
free and open source game engine Godot. GDScript's syntax is similar to<br>
Python's. Its main advantages are ease of use and tight integration with<br>
the engine. It's a perfect fit for game development.</p>
<h2>Basics</h2>
<div class="highlight highlight-source-nim"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> Single-line comments are written using hash symbol.</span>
<span class="pl-s">"""</span><span class="pl-s"></span>
<span class="pl-s">  Multi-line</span>
<span class="pl-s">  comments</span>
<span class="pl-s">  are</span>
<span class="pl-s">  written</span>
<span class="pl-s">  using</span>
<span class="pl-s">  docstrings.</span>
<span class="pl-s"></span><span class="pl-s">"""</span>

<span class="pl-c"><span class="pl-c">#</span> Script file is a class in itself and you can optionally define a name for it.</span>
<span class="pl-v">class_name</span> <span class="pl-c1">MyClass</span>

<span class="pl-c"><span class="pl-c">#</span> Inheritance</span>
<span class="pl-v">extends</span> <span class="pl-c1">Node2D</span>

<span class="pl-c"><span class="pl-c">#</span> Member variables</span>
<span class="pl-k">var</span> <span class="pl-smi">x</span> <span class="pl-k">=</span> <span class="pl-c1">8</span> <span class="pl-c"><span class="pl-c">#</span> int</span>
<span class="pl-k">var</span> <span class="pl-smi">y</span> <span class="pl-k">=</span> <span class="pl-c1">1.2</span> <span class="pl-c"><span class="pl-c">#</span> float</span>
<span class="pl-k">var</span> <span class="pl-smi">b</span> <span class="pl-k">=</span> <span class="pl-c1">true</span> <span class="pl-c"><span class="pl-c">#</span> bool</span>
<span class="pl-k">var</span> <span class="pl-smi">s</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Hello World!<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> String</span>
<span class="pl-k">var</span> <span class="pl-smi">a</span> <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">false</span>, <span class="pl-s"><span class="pl-pds">"</span>brown fox<span class="pl-pds">"</span></span>] <span class="pl-c"><span class="pl-c">#</span> Array - similar to list in Python,</span>
                                <span class="pl-c"><span class="pl-c">#</span> it can hold different types</span>
                                <span class="pl-c"><span class="pl-c">#</span> of variables at once.</span>
<span class="pl-k">var</span> <span class="pl-smi">d</span> <span class="pl-k">=</span> {
  <span class="pl-s"><span class="pl-pds">"</span>key<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>value<span class="pl-pds">"</span></span>,
  <span class="pl-c1">42</span> : <span class="pl-c1">true</span>
} <span class="pl-c"><span class="pl-c">#</span> Dictionary holds key-value pairs.</span>
<span class="pl-k">var</span> <span class="pl-smi">p_arr</span> <span class="pl-k">=</span> <span class="pl-v">PoolStringArray</span>([<span class="pl-s"><span class="pl-pds">"</span>Hi<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>there<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>!<span class="pl-pds">"</span></span>]) <span class="pl-c"><span class="pl-c">#</span> Pool arrays can</span>
                                                  <span class="pl-c"><span class="pl-c">#</span> only hold a certain type.</span>

<span class="pl-c"><span class="pl-c">#</span> Built-in vector types:</span>
<span class="pl-k">var</span> <span class="pl-smi">v2</span> <span class="pl-k">=</span> <span class="pl-v">Vector2</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>)
<span class="pl-k">var</span> <span class="pl-smi">v3</span> <span class="pl-k">=</span> <span class="pl-v">Vector3</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)

<span class="pl-c"><span class="pl-c">#</span> Constants</span>
<span class="pl-k">const</span> <span class="pl-c1">ANSWER_TO_EVERYTHING</span> <span class="pl-k">=</span> <span class="pl-c1">42</span>
<span class="pl-k">const</span> <span class="pl-c1">BREAKFAST</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Spam and eggs!<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> Enums</span>
<span class="pl-k">enum</span> { <span class="pl-c1">ZERO</span>, <span class="pl-c1">ONE</span> , <span class="pl-c1">TWO</span>, <span class="pl-c1">THREE</span> }
<span class="pl-k">enum</span> <span class="pl-v">NamedEnum</span> { <span class="pl-c1">ONE</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-c1">TWO</span>, <span class="pl-c1">THREE</span> }

<span class="pl-c"><span class="pl-c">#</span> Exported variables are visible in the inspector.</span>
<span class="pl-k">export</span>(<span class="pl-k">int</span>) <span class="pl-k">var</span> age
<span class="pl-k">export</span>(<span class="pl-k">float</span>) <span class="pl-k">var</span> height
<span class="pl-k">export</span> <span class="pl-k">var</span> person_name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Bob<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> Export type hints are unnecessary</span>
                        <span class="pl-c"><span class="pl-c">#</span> if you set a default value.</span>

<span class="pl-c"><span class="pl-c">#</span> Functions</span>
<span class="pl-k">func</span> <span class="pl-en">foo</span>():
  pass <span class="pl-c"><span class="pl-c">#</span> pass keyword is a placeholder for future code</span>

<span class="pl-k">func</span> <span class="pl-en">add</span>(<span class="pl-v">first</span>, <span class="pl-v">second</span>):
  <span class="pl-k">return</span> first <span class="pl-k">+</span> second

<span class="pl-c"><span class="pl-c">#</span> Printing values</span>
<span class="pl-k">func</span> <span class="pl-en">printing</span>():
  <span class="pl-v">print</span>(<span class="pl-s"><span class="pl-pds">"</span>GDScript <span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>is <span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span> awesome.<span class="pl-pds">"</span></span>)
  <span class="pl-v">prints</span>(<span class="pl-s"><span class="pl-pds">"</span>These<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>words<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>are<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>divided<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>by<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>spaces.<span class="pl-pds">"</span></span>)
  <span class="pl-v">printt</span>(<span class="pl-s"><span class="pl-pds">"</span>These<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>words<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>are<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>divided<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>by<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>tabs.<span class="pl-pds">"</span></span>)
  <span class="pl-v">printraw</span>(<span class="pl-s"><span class="pl-pds">"</span>This gets printed to system console.<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">#</span> Math</span>
<span class="pl-k">func</span> <span class="pl-en">doing_math</span>():
  <span class="pl-k">var</span> <span class="pl-smi">first</span> <span class="pl-k">=</span> <span class="pl-c1">8</span>
  <span class="pl-k">var</span> <span class="pl-smi">second</span> <span class="pl-k">=</span> <span class="pl-c1">4</span>
  <span class="pl-v">print</span>(first <span class="pl-k">+</span> second) <span class="pl-c"><span class="pl-c">#</span> 12</span>
  <span class="pl-v">print</span>(first <span class="pl-k">-</span> second) <span class="pl-c"><span class="pl-c">#</span> 4</span>
  <span class="pl-v">print</span>(first <span class="pl-k">*</span> second) <span class="pl-c"><span class="pl-c">#</span> 32</span>
  <span class="pl-v">print</span>(first <span class="pl-k">/</span> second) <span class="pl-c"><span class="pl-c">#</span> 2</span>
  <span class="pl-v">print</span>(first <span class="pl-k">%</span> second) <span class="pl-c"><span class="pl-c">#</span> 0</span>
  <span class="pl-c"><span class="pl-c">#</span> There are also +=, -=, *=, /=, %= etc.,</span>
  <span class="pl-c"><span class="pl-c">#</span> however no ++ or -- operators.</span>
  <span class="pl-v">print</span>(<span class="pl-v">pow</span>(first, <span class="pl-c1">2</span>)) <span class="pl-c"><span class="pl-c">#</span> 64</span>
  <span class="pl-v">print</span>(<span class="pl-v">sqrt</span>(second)) <span class="pl-c"><span class="pl-c">#</span> 2</span>
  <span class="pl-v">printt</span>(<span class="pl-c1">PI</span>, <span class="pl-c1">TAU</span>, <span class="pl-c1">INF</span>, <span class="pl-c1">NAN</span>) <span class="pl-c"><span class="pl-c">#</span> built-in constants</span>

<span class="pl-c"><span class="pl-c">#</span> Control flow</span>
<span class="pl-k">func</span> <span class="pl-en">control_flow</span>():
  x <span class="pl-k">=</span> <span class="pl-c1">8</span>
  y <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-c"><span class="pl-c">#</span> y was originally a float,</span>
        <span class="pl-c"><span class="pl-c">#</span> but we can change its type to int</span>
        <span class="pl-c"><span class="pl-c">#</span> using the power of dynamic typing!</span>
  
  <span class="pl-k">if</span> x <span class="pl-k">&lt;</span> y:
    <span class="pl-v">print</span>(<span class="pl-s"><span class="pl-pds">"</span>x is smaller than y<span class="pl-pds">"</span></span>)
  <span class="pl-k">elif</span> x <span class="pl-k">&gt;</span> y:
    <span class="pl-v">print</span>(<span class="pl-s"><span class="pl-pds">"</span>x is bigger than y<span class="pl-pds">"</span></span>)
  <span class="pl-k">else</span>:
    <span class="pl-v">print</span>(<span class="pl-s"><span class="pl-pds">"</span>x and y are equal<span class="pl-pds">"</span></span>)
  
  <span class="pl-k">var</span> <span class="pl-smi">a</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>
  <span class="pl-k">var</span> <span class="pl-smi">b</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>
  <span class="pl-k">var</span> <span class="pl-smi">c</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>
  <span class="pl-k">if</span> a <span class="pl-k">and</span> b <span class="pl-k">or</span> <span class="pl-k">not</span> c: <span class="pl-c"><span class="pl-c">#</span> alternatively you can use &amp;&amp;, || and !</span>
    <span class="pl-v">print</span>(<span class="pl-s"><span class="pl-pds">"</span>This is true!<span class="pl-pds">"</span></span>)

  <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-v"><span class="pl-k">range</span></span>(<span class="pl-c1">20</span>): <span class="pl-c"><span class="pl-c">#</span> GDScript's range is similar to Python's</span>
    <span class="pl-v">print</span>(i) <span class="pl-c"><span class="pl-c">#</span> so this will print numbers from 0 to 19</span>

  <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">20</span>: <span class="pl-c"><span class="pl-c">#</span> unlike Python, you can loop over an int directly</span>
    <span class="pl-v">print</span>(i) <span class="pl-c"><span class="pl-c">#</span> so this will also print numbers from 0 to 19</span>

  <span class="pl-k">for</span> i <span class="pl-k">in</span> [<span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>, <span class="pl-c1">3</span>, <span class="pl-c1">1.0</span>]: <span class="pl-c"><span class="pl-c">#</span> iterating over an array</span>
    <span class="pl-v">print</span>(i)
  
  <span class="pl-k">while</span> x <span class="pl-k">&gt;</span> y:
    <span class="pl-v">printt</span>(x, y)
    y <span class="pl-k">+=</span> <span class="pl-c1">1</span>

  x <span class="pl-k">=</span> <span class="pl-c1">2</span>
  y <span class="pl-k">=</span> <span class="pl-c1">10</span>
  <span class="pl-k">while</span> x <span class="pl-k">&lt;</span> y:
    x <span class="pl-k">+=</span> <span class="pl-c1">1</span>
    <span class="pl-k">if</span> x <span class="pl-k">==</span> <span class="pl-c1">6</span>:
      <span class="pl-k">continue</span> <span class="pl-c"><span class="pl-c">#</span> 6 won't get printed because of continue statement</span>
    <span class="pl-v">prints</span>(<span class="pl-s"><span class="pl-pds">"</span>x is equal to:<span class="pl-pds">"</span></span>, x)
    <span class="pl-k">if</span> x <span class="pl-k">==</span> <span class="pl-c1">7</span>:
      <span class="pl-k">break</span> <span class="pl-c"><span class="pl-c">#</span> loop will break on 7, so 8, 9 and 10 won't get printed</span>

  <span class="pl-v">match</span> x:
    <span class="pl-c1">1</span>:
      <span class="pl-v">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Match is similar to switch.<span class="pl-pds">"</span></span>)
    <span class="pl-c1">2</span>:
      <span class="pl-v">print</span>(<span class="pl-s"><span class="pl-pds">"</span>However you don't need to put cases before each value.<span class="pl-pds">"</span></span>)
    <span class="pl-c1">3</span>:
      <span class="pl-v">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Furthermore each case breaks on default.<span class="pl-pds">"</span></span>)
      <span class="pl-k">break</span> <span class="pl-c"><span class="pl-c">#</span> ERROR! Break statement is unnecessary!</span>
    <span class="pl-c1">4</span>:
      <span class="pl-v">print</span>(<span class="pl-s"><span class="pl-pds">"</span>If you need fallthrough use continue.<span class="pl-pds">"</span></span>)
      <span class="pl-k">continue</span>
    _:
      <span class="pl-v">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Underscore is a default case.<span class="pl-pds">"</span></span>)
  
  <span class="pl-c"><span class="pl-c">#</span> ternary operator (one line if-else statement)</span>
  <span class="pl-v">prints</span>(<span class="pl-s"><span class="pl-pds">"</span>x is<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>positive<span class="pl-pds">"</span></span> <span class="pl-k">if</span> x <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-k">else</span> <span class="pl-s"><span class="pl-pds">"</span>negative<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">#</span> Casting</span>
<span class="pl-k">func</span> <span class="pl-en">casting_examples</span>():
  <span class="pl-k">var</span> <span class="pl-smi">i</span> <span class="pl-k">=</span> <span class="pl-c1">42</span>
  <span class="pl-k">var</span> <span class="pl-smi">f</span> <span class="pl-k">=</span> <span class="pl-v"><span class="pl-k">float</span></span>(<span class="pl-c1">42</span>) <span class="pl-c"><span class="pl-c">#</span> cast using variables constructor</span>
  <span class="pl-k">var</span> <span class="pl-smi">b</span> <span class="pl-k">=</span> i <span class="pl-k">as</span> <span class="pl-k">bool</span> <span class="pl-c"><span class="pl-c">#</span> or using "as" keyword</span>

<span class="pl-c"><span class="pl-c">#</span> Override functions</span>
<span class="pl-c"><span class="pl-c">#</span> By a convention built-in overridable functions start with an underscore,</span>
<span class="pl-c"><span class="pl-c">#</span> but in practice you can override virtually any function.</span>

<span class="pl-c"><span class="pl-c">#</span> _init is called when object gets initialized</span>
<span class="pl-c"><span class="pl-c">#</span> This is the object's constructor.</span>
<span class="pl-k">func</span> <span class="pl-en">_</span><span class="pl-v">init</span>():
  <span class="pl-c"><span class="pl-c">#</span> Initialize object's internal stuff here.</span>
  pass

<span class="pl-c"><span class="pl-c">#</span> _ready gets called when script's node and</span>
<span class="pl-c"><span class="pl-c">#</span> its children have entered the scene tree.</span>
<span class="pl-k">func</span> <span class="pl-en">_</span><span class="pl-v">ready</span>():
  pass

<span class="pl-c"><span class="pl-c">#</span> _process gets called on every frame.</span>
<span class="pl-k">func</span> <span class="pl-en">_</span><span class="pl-v">process</span>(delta):
  <span class="pl-c"><span class="pl-c">#</span> The delta argument passed to this function is a number of seconds,</span>
  <span class="pl-c"><span class="pl-c">#</span> which passed between the last frame and the current one.</span>
  <span class="pl-v">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Delta time equals: <span class="pl-pds">"</span></span>, delta)

<span class="pl-c"><span class="pl-c">#</span> _physics_process gets called on every physics frame.</span>
<span class="pl-c"><span class="pl-c">#</span> That means delta should be constant.</span>
<span class="pl-k">func</span> <span class="pl-en">_</span><span class="pl-v">physics_process</span>(delta):
  <span class="pl-c"><span class="pl-c">#</span> Simple movement using vector addition and multiplication.</span>
  <span class="pl-k">var</span> <span class="pl-smi">direction</span> <span class="pl-k">=</span> <span class="pl-v">Vector2</span>(<span class="pl-c1">1</span>, <span class="pl-c1">0</span>) <span class="pl-c"><span class="pl-c">#</span> or Vector2.RIGHT</span>
  <span class="pl-k">var</span> <span class="pl-smi">speed</span> <span class="pl-k">=</span> <span class="pl-c1">100.0</span>
  self.global_position <span class="pl-k">+=</span> direction <span class="pl-k">*</span> speed <span class="pl-k">*</span> delta
  <span class="pl-c"><span class="pl-c">#</span> self refers to current class instance</span>

<span class="pl-c"><span class="pl-c">#</span> When overriding you can call parent's function using the dot operator</span>
<span class="pl-c"><span class="pl-c">#</span> like here:</span>
<span class="pl-k">func</span> <span class="pl-en">get_children</span>():
  <span class="pl-c"><span class="pl-c">#</span> Do some additional things here.</span>
  <span class="pl-k">var</span> <span class="pl-smi">r</span> <span class="pl-k">=</span> .<span class="pl-v">get_children</span>() <span class="pl-c"><span class="pl-c">#</span> call parent's implementation</span>
  <span class="pl-k">return</span> r

<span class="pl-c"><span class="pl-c">#</span> Inner class</span>
<span class="pl-v">class</span> <span class="pl-c1">InnerClass</span>:
  <span class="pl-v">extends</span> <span class="pl-c1">Object</span>

  <span class="pl-k">func</span> <span class="pl-en">hello</span>():
    <span class="pl-v">print</span>(<span class="pl-s"><span class="pl-pds">"</span>Hello from inner class!<span class="pl-pds">"</span></span>)

<span class="pl-k">func</span> <span class="pl-en">use_inner_class</span>():
  <span class="pl-k">var</span> <span class="pl-smi">ic</span> <span class="pl-k">=</span> <span class="pl-c1">InnerClass</span>.<span class="pl-v"><span class="pl-c1">new</span></span>()
  ic.<span class="pl-v">hello</span>()
  ic.<span class="pl-v">free</span>() <span class="pl-c"><span class="pl-c">#</span> use free for memory cleanup</span></pre></div>
<h2>Accessing other nodes in the scene tree</h2>
<div class="highlight highlight-source-nim"><pre class="notranslate"><span class="pl-v">extends</span> <span class="pl-c1">Node2D</span>

<span class="pl-k">var</span> <span class="pl-smi">sprite</span> <span class="pl-c"><span class="pl-c">#</span> This variable will hold the reference.</span>

<span class="pl-c"><span class="pl-c">#</span> You can get references to other nodes in _ready.</span>
<span class="pl-smi">func</span> <span class="pl-smi">_ready</span>() <span class="pl-k">-&gt;</span> <span class="pl-k">void</span>:
  <span class="pl-c"><span class="pl-c">#</span> NodePath is useful for accessing nodes.</span>
  <span class="pl-c"><span class="pl-c">#</span> Create NodePath by passing String to its constructor:</span>
  <span class="pl-k">var</span> <span class="pl-smi">path1</span> <span class="pl-k">=</span> <span class="pl-v">NodePath</span>(<span class="pl-s"><span class="pl-pds">"</span>path/to/something<span class="pl-pds">"</span></span>)
  <span class="pl-c"><span class="pl-c">#</span> Or by using NodePath literal:</span>
  <span class="pl-k">var</span> <span class="pl-smi">path2</span> <span class="pl-k">=</span> <span class="pl-k">@</span><span class="pl-s"><span class="pl-pds">"</span>path/to/something<span class="pl-pds">"</span></span>
  <span class="pl-c"><span class="pl-c">#</span> NodePath examples:</span>
  <span class="pl-k">var</span> <span class="pl-smi">path3</span> <span class="pl-k">=</span> <span class="pl-k">@</span><span class="pl-s"><span class="pl-pds">"</span>Sprite<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> relative path, immediate child of the current node</span>
  <span class="pl-k">var</span> <span class="pl-smi">path4</span> <span class="pl-k">=</span> <span class="pl-k">@</span><span class="pl-s"><span class="pl-pds">"</span>Timers/Firerate<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> relative path, child of the child</span>
  <span class="pl-k">var</span> <span class="pl-smi">path5</span> <span class="pl-k">=</span> <span class="pl-k">@</span><span class="pl-s"><span class="pl-pds">"</span>..<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> current node's parent</span>
  <span class="pl-k">var</span> <span class="pl-smi">path6</span> <span class="pl-k">=</span> <span class="pl-k">@</span><span class="pl-s"><span class="pl-pds">"</span>../Enemy<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> current node's sibling</span>
  <span class="pl-k">var</span> <span class="pl-smi">path7</span> <span class="pl-k">=</span> <span class="pl-k">@</span><span class="pl-s"><span class="pl-pds">"</span>/root<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> absolute path, equivalent to get_tree().get_root()</span>
  <span class="pl-k">var</span> <span class="pl-smi">path8</span> <span class="pl-k">=</span> <span class="pl-k">@</span><span class="pl-s"><span class="pl-pds">"</span>/root/Main/Player/Sprite<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> absolute path to Player's Sprite</span>
  <span class="pl-k">var</span> <span class="pl-smi">path9</span> <span class="pl-k">=</span> <span class="pl-k">@</span><span class="pl-s"><span class="pl-pds">"</span>Timers/Firerate:wait_time<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> accessing properties</span>
  <span class="pl-k">var</span> <span class="pl-smi">path10</span> <span class="pl-k">=</span> <span class="pl-k">@</span><span class="pl-s"><span class="pl-pds">"</span>Player:position:x<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> accessing subproperties</span>

  <span class="pl-c"><span class="pl-c">#</span> Finally, to get a reference use one of these:</span>
  sprite <span class="pl-k">=</span> <span class="pl-v">get_node</span>(<span class="pl-k">@</span><span class="pl-s"><span class="pl-pds">"</span>Sprite<span class="pl-pds">"</span></span>) <span class="pl-k">as</span> <span class="pl-c1">Sprite</span> <span class="pl-c"><span class="pl-c">#</span> always cast to the type you expect</span>
  sprite <span class="pl-k">=</span> <span class="pl-v">get_node</span>(<span class="pl-s"><span class="pl-pds">"</span>Sprite<span class="pl-pds">"</span></span>) <span class="pl-k">as</span> <span class="pl-c1">Sprite</span> <span class="pl-c"><span class="pl-c">#</span> here String gets</span>
                                        <span class="pl-c"><span class="pl-c">#</span> implicitly casted to NodePath</span>
  sprite <span class="pl-k">=</span> <span class="pl-v">get_node</span>(path3) <span class="pl-k">as</span> <span class="pl-c1">Sprite</span>
  sprite <span class="pl-k">=</span> <span class="pl-v">get_node_or_null</span>(<span class="pl-s"><span class="pl-pds">"</span>Sprite<span class="pl-pds">"</span></span>) <span class="pl-k">as</span> <span class="pl-c1">Sprite</span>
  sprite <span class="pl-k">=</span> <span class="pl-k">$</span><span class="pl-c1">Sprite</span> <span class="pl-k">as</span> <span class="pl-c1">Sprite</span>

<span class="pl-k">func</span> <span class="pl-en">_</span><span class="pl-v">process</span>(delta):
  <span class="pl-c"><span class="pl-c">#</span> Now we can reuse the reference in other places.</span>
  <span class="pl-v">prints</span>(<span class="pl-s"><span class="pl-pds">"</span>Sprite has global_position of<span class="pl-pds">"</span></span>, sprite.global_position)

<span class="pl-c"><span class="pl-c">#</span> Use onready keyword to assign a value to</span>
<span class="pl-c"><span class="pl-c">#</span> a variable just before _ready executes.</span>
<span class="pl-c"><span class="pl-c">#</span> This is a commonly used syntax sugar.</span>
<span class="pl-v">onready</span> <span class="pl-k">var</span> tween <span class="pl-k">=</span> <span class="pl-k">$</span><span class="pl-c1">Tween</span> <span class="pl-k">as</span> <span class="pl-c1">Tween</span>

<span class="pl-c"><span class="pl-c">#</span> You can export NodePath, so you can assign it within the inspector.</span>
<span class="pl-k">export</span> <span class="pl-k">var</span> nodepath <span class="pl-k">=</span> <span class="pl-k">@</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>
<span class="pl-v">onready</span> <span class="pl-k">var</span> reference <span class="pl-k">=</span> <span class="pl-v">get_node</span>(nodepath) <span class="pl-k">as</span> <span class="pl-c1">Node</span></pre></div>
<h2>Signals</h2>
<p>Signal system is Godot's implementation of the observer programming<br>
pattern. Here's an example:</p>
<div class="highlight highlight-source-nim"><pre class="notranslate"><span class="pl-v">class_name</span> <span class="pl-v">Player</span> <span class="pl-v">extends</span> <span class="pl-c1">Node2D</span>

<span class="pl-k">var</span> <span class="pl-smi">hp</span> <span class="pl-k">=</span> <span class="pl-c1">10</span>

<span class="pl-v">signal</span> <span class="pl-v">died</span>() <span class="pl-c"><span class="pl-c">#</span> define signal</span>
<span class="pl-v">signal</span> <span class="pl-v">hurt</span>(hp_old, hp_new) <span class="pl-c"><span class="pl-c">#</span> signals can take arguments</span>

<span class="pl-k">func</span> <span class="pl-en">apply_damage</span>(<span class="pl-v">dmg</span>):
  <span class="pl-k">var</span> <span class="pl-smi">hp_old</span> <span class="pl-k">=</span> hp
  hp <span class="pl-k">-=</span> dmg
  <span class="pl-v">emit_signal</span>(<span class="pl-s"><span class="pl-pds">"</span>hurt<span class="pl-pds">"</span></span>, hp_old, hp) <span class="pl-c"><span class="pl-c">#</span> emit signal and pass arguments</span>
  <span class="pl-k">if</span> hp <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>:
    <span class="pl-v">emit_signal</span>(<span class="pl-s"><span class="pl-pds">"</span>died<span class="pl-pds">"</span></span>)

<span class="pl-k">func</span> <span class="pl-en">_</span><span class="pl-v">ready</span>():
  <span class="pl-c"><span class="pl-c">#</span> connect signal "died" to function "_on_death" defined in self</span>
  self.<span class="pl-v">connect</span>(<span class="pl-s"><span class="pl-pds">"</span>died<span class="pl-pds">"</span></span>, self, <span class="pl-s"><span class="pl-pds">"</span>_on_death<span class="pl-pds">"</span></span>)

<span class="pl-k">func</span> <span class="pl-en">_</span><span class="pl-v">on_death</span>():
  self.<span class="pl-v">queue_free</span>() <span class="pl-c"><span class="pl-c">#</span> destroy Player on death</span></pre></div>
<h2>Type hints</h2>
<p>GDScript can optionally use static typing.</p>
<div class="highlight highlight-source-nim"><pre class="notranslate"><span class="pl-v">extends</span> <span class="pl-c1">Node</span>

<span class="pl-k">var</span> <span class="pl-smi">x</span>: <span class="pl-k">int</span> <span class="pl-c"><span class="pl-c">#</span> define typed variable</span>
<span class="pl-k">var</span> <span class="pl-smi">y</span>: <span class="pl-k">float</span> <span class="pl-k">=</span> <span class="pl-c1">4.2</span>
<span class="pl-k">var</span> <span class="pl-smi">z</span> :<span class="pl-k">=</span> <span class="pl-c1">1.0</span> <span class="pl-c"><span class="pl-c">#</span> infer type based on default value using := operator</span>

<span class="pl-v">onready</span> <span class="pl-k">var</span> node_ref_typed :<span class="pl-k">=</span> <span class="pl-k">$</span><span class="pl-c1">Child</span> <span class="pl-k">as</span> <span class="pl-c1">Node</span>

<span class="pl-k">export</span> <span class="pl-k">var</span> speed :<span class="pl-k">=</span> <span class="pl-c1">50.0</span>

<span class="pl-k">const</span> <span class="pl-c1">CONSTANT</span> :<span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Typed constant.<span class="pl-pds">"</span></span>

<span class="pl-k">func</span> <span class="pl-en">_</span><span class="pl-v">ready</span>() <span class="pl-k">-&gt;</span> <span class="pl-k">void</span>:
  <span class="pl-c"><span class="pl-c">#</span> function returns nothing</span>
  x <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> ERROR! Type can't be changed!</span>
  <span class="pl-k">return</span>

<span class="pl-k">func</span> <span class="pl-en">join</span>(<span class="pl-v">arg1</span>: <span class="pl-c1">String</span>, <span class="pl-v">arg2</span>: <span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span>:
  <span class="pl-c"><span class="pl-c">#</span> function takes two Strings and returns a String</span>
  <span class="pl-k">return</span> arg1 <span class="pl-k">+</span> arg2

<span class="pl-k">func</span> <span class="pl-en">get_child_at</span>(<span class="pl-v">index</span>: <span class="pl-k">int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Node</span>:
  <span class="pl-c"><span class="pl-c">#</span> function takes an int and returns a Node</span>
  <span class="pl-k">return</span> <span class="pl-v">get_children</span>()[index]

<span class="pl-v">signal</span> <span class="pl-v">example</span>(<span class="pl-v">arg</span>: <span class="pl-k">int</span>) <span class="pl-c"><span class="pl-c">#</span> ERROR! Signals can't take typed arguments!</span></pre></div>
<h2>Further Reading</h2>
<ul>
<li><a href="https://godotengine.org/" rel="nofollow">Godot's Website</a></li>
<li><a href="https://docs.godotengine.org/en/stable/" rel="nofollow">Godot Docs</a></li>
<li><a href="https://docs.godotengine.org/en/stable/getting_started/scripting/gdscript/index.html" rel="nofollow">Getting started with GDScript</a></li>
<li><a href="https://docs.godotengine.org/en/stable/classes/class_nodepath.html" rel="nofollow">NodePath</a></li>
<li><a href="https://docs.godotengine.org/en/stable/getting_started/step_by_step/signals.html" rel="nofollow">Signals</a></li>
<li><a href="https://www.gdquest.com/" rel="nofollow">GDQuest</a></li>
<li><a href="https://gdscript.com/" rel="nofollow">GDScript.com</a></li>
</ul>
<hr>
<h2>Contributors</h2>
<pre class="notranslate"><code class="notranslate">- ["Wichamir", "https://github.com/Wichamir/"]
</code></pre>