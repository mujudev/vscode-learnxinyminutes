<h1>Julia</h1>
<p>Julia is a new homoiconic functional language focused on technical computing.<br>
While having the full power of homoiconic macros, first-class functions,<br>
and low-level control, Julia is as easy to learn and use as Python.</p>
<p>This is based on Julia version 1.0.0.</p>
<div class="highlight highlight-source-julia"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> Single line comments start with a hash (pound) symbol.</span>
<span class="pl-c"><span class="pl-c">#=</span> Multiline comments can be written</span>
<span class="pl-c">   by putting '<span class="pl-c"><span class="pl-c">#=</span>' before the text  and '<span class="pl-c">=#</span></span>'</span>
<span class="pl-c">   after the text. They can also be nested.</span>
<span class="pl-c"><span class="pl-c">=#</span></span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span># 1. Primitive Datatypes and Operators</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> Everything in Julia is an expression.</span>

<span class="pl-c"><span class="pl-c">#</span> There are several basic types of numbers.</span>
<span class="pl-c1">typeof</span>(<span class="pl-c1">3</span>)       <span class="pl-c"><span class="pl-c">#</span> =&gt; Int64</span>
<span class="pl-c1">typeof</span>(<span class="pl-c1">3.2</span>)     <span class="pl-c"><span class="pl-c">#</span> =&gt; Float64</span>
<span class="pl-c1">typeof</span>(<span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">1im</span>) <span class="pl-c"><span class="pl-c">#</span> =&gt; Complex{Int64}</span>
<span class="pl-c1">typeof</span>(<span class="pl-c1">2</span> <span class="pl-k">//</span> <span class="pl-c1">3</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; Rational{Int64}</span>

<span class="pl-c"><span class="pl-c">#</span> All of the normal infix operators are available.</span>
<span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>      <span class="pl-c"><span class="pl-c">#</span> =&gt; 2</span>
<span class="pl-c1">8</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>      <span class="pl-c"><span class="pl-c">#</span> =&gt; 7</span>
<span class="pl-c1">10</span> <span class="pl-k">*</span> <span class="pl-c1">2</span>     <span class="pl-c"><span class="pl-c">#</span> =&gt; 20</span>
<span class="pl-c1">35</span> <span class="pl-k">/</span> <span class="pl-c1">5</span>     <span class="pl-c"><span class="pl-c">#</span> =&gt; 7.0</span>
<span class="pl-c1">10</span> <span class="pl-k">/</span> <span class="pl-c1">2</span>     <span class="pl-c"><span class="pl-c">#</span> =&gt; 5.0  # dividing integers always results in a Float64</span>
<span class="pl-c1">div</span>(<span class="pl-c1">5</span>, <span class="pl-c1">2</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; 2    # for a truncated result, use div</span>
<span class="pl-c1">5</span> <span class="pl-k">\</span> <span class="pl-c1">35</span>     <span class="pl-c"><span class="pl-c">#</span> =&gt; 7.0</span>
<span class="pl-c1">2</span><span class="pl-k">^</span><span class="pl-c1">2</span>        <span class="pl-c"><span class="pl-c">#</span> =&gt; 4    # power, not bitwise xor</span>
<span class="pl-c1">12</span> <span class="pl-k">%</span> <span class="pl-c1">10</span>    <span class="pl-c"><span class="pl-c">#</span> =&gt; 2</span>

<span class="pl-c"><span class="pl-c">#</span> Enforce precedence with parentheses</span>
(<span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">3</span>) <span class="pl-k">*</span> <span class="pl-c1">2</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; 8</span>

<span class="pl-c"><span class="pl-c">#</span> Julia (unlike Python for instance) has integer under/overflow</span>
<span class="pl-c1">10</span><span class="pl-k">^</span><span class="pl-c1">19</span>      <span class="pl-c"><span class="pl-c">#</span> =&gt; -8446744073709551616</span>
<span class="pl-c"><span class="pl-c">#</span> use bigint or floating point to avoid this</span>
<span class="pl-c1">big</span>(<span class="pl-c1">10</span>)<span class="pl-k">^</span><span class="pl-c1">19</span> <span class="pl-c"><span class="pl-c">#</span> =&gt; 10000000000000000000</span>
<span class="pl-c1">1e19</span>       <span class="pl-c"><span class="pl-c">#</span> =&gt; 1.0e19</span>
<span class="pl-c1">10.0</span><span class="pl-k">^</span><span class="pl-c1">19</span>    <span class="pl-c"><span class="pl-c">#</span> =&gt; 1.0e19</span>

<span class="pl-c"><span class="pl-c">#</span> Bitwise Operators</span>
<span class="pl-k">~</span><span class="pl-c1">2</span>         <span class="pl-c"><span class="pl-c">#</span> =&gt; -3 # bitwise not</span>
<span class="pl-c1">3</span> <span class="pl-k">&amp;</span> <span class="pl-c1">5</span>      <span class="pl-c"><span class="pl-c">#</span> =&gt; 1  # bitwise and</span>
<span class="pl-c1">2</span> <span class="pl-k">|</span> <span class="pl-c1">4</span>      <span class="pl-c"><span class="pl-c">#</span> =&gt; 6  # bitwise or</span>
<span class="pl-c1">xor</span>(<span class="pl-c1">2</span>, <span class="pl-c1">4</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; 6  # bitwise xor</span>
<span class="pl-c1">2</span> <span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-c1">1</span>    <span class="pl-c"><span class="pl-c">#</span> =&gt; 1  # logical shift right</span>
<span class="pl-c1">2</span> <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">1</span>     <span class="pl-c"><span class="pl-c">#</span> =&gt; 1  # arithmetic shift right</span>
<span class="pl-c1">2</span> <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">1</span>     <span class="pl-c"><span class="pl-c">#</span> =&gt; 4  # logical/arithmetic shift left</span>

<span class="pl-c"><span class="pl-c">#</span> Use the bitstring function to see the binary representation of a number.</span>
<span class="pl-c1">bitstring</span>(<span class="pl-c1">12345</span>)
<span class="pl-c"><span class="pl-c">#</span> =&gt; "0000000000000000000000000000000000000000000000000011000000111001"</span>
<span class="pl-c1">bitstring</span>(<span class="pl-c1">12345.0</span>)
<span class="pl-c"><span class="pl-c">#</span> =&gt; "0100000011001000000111001000000000000000000000000000000000000000"</span>

<span class="pl-c"><span class="pl-c">#</span> Boolean values are primitives</span>
<span class="pl-c1">true</span>
<span class="pl-c1">false</span>

<span class="pl-c"><span class="pl-c">#</span> Boolean operators</span>
<span class="pl-k">!</span><span class="pl-c1">true</span>   <span class="pl-c"><span class="pl-c">#</span> =&gt; false</span>
<span class="pl-k">!</span><span class="pl-c1">false</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-c1">1</span> <span class="pl-k">==</span> <span class="pl-c1">1</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">1</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; false</span>
<span class="pl-c1">1</span> <span class="pl-k">!=</span> <span class="pl-c1">1</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; false</span>
<span class="pl-c1">2</span> <span class="pl-k">!=</span> <span class="pl-c1">1</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-c1">1</span> <span class="pl-k">&lt;</span> <span class="pl-c1">10</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-c1">1</span> <span class="pl-k">&gt;</span> <span class="pl-c1">10</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; false</span>
<span class="pl-c1">2</span> <span class="pl-k">&lt;=</span> <span class="pl-c1">2</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-c1">2</span> <span class="pl-k">&gt;=</span> <span class="pl-c1">2</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-c"><span class="pl-c">#</span> Comparisons can be chained, like in Python but unlike many other languages</span>
<span class="pl-c1">1</span> <span class="pl-k">&lt;</span> <span class="pl-c1">2</span> <span class="pl-k">&lt;</span> <span class="pl-c1">3</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-c1">2</span> <span class="pl-k">&lt;</span> <span class="pl-c1">3</span> <span class="pl-k">&lt;</span> <span class="pl-c1">2</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; false</span>

<span class="pl-c"><span class="pl-c">#</span> Strings are created with "</span>
<span class="pl-s"><span class="pl-pds">"</span>This is a string.<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> Character literals are written with '</span>
<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>

<span class="pl-c"><span class="pl-c">#</span> Strings are UTF8 encoded, so strings like "π" or "☃" are not directly equivalent</span>
<span class="pl-c"><span class="pl-c">#</span> to an array of single characters.</span>
<span class="pl-c"><span class="pl-c">#</span> Only if they contain only ASCII characters can they be safely indexed.</span>
<span class="pl-c1">ascii</span>(<span class="pl-s"><span class="pl-pds">"</span>This is a string<span class="pl-pds">"</span></span>)[<span class="pl-c1">1</span>]    <span class="pl-c"><span class="pl-c">#</span> =&gt; 'T'</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; 'T': ASCII/Unicode U+0054 (category Lu: Letter, uppercase)</span>
<span class="pl-c"><span class="pl-c">#</span> Beware, Julia indexes everything from 1 (like MATLAB), not 0 (like most languages).</span>
<span class="pl-c"><span class="pl-c">#</span> Otherwise, iterating over strings is recommended (map, for loops, etc).</span>

<span class="pl-c"><span class="pl-c">#</span> String can be compared lexicographically, in dictionnary order:</span>
<span class="pl-s"><span class="pl-pds">"</span>good<span class="pl-pds">"</span></span> <span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>bye<span class="pl-pds">"</span></span>   <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-s"><span class="pl-pds">"</span>good<span class="pl-pds">"</span></span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>good<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-s"><span class="pl-pds">"</span>1 + 2 = 3<span class="pl-pds">"</span></span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>1 + 2 = <span class="pl-v">$(<span class="pl-c1">1</span> <span class="pl-k">+</span> <span class="pl-c1">2</span>)</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>

<span class="pl-c"><span class="pl-c">#</span> $(..) can be used for string interpolation:</span>
<span class="pl-s"><span class="pl-pds">"</span>2 + 2 = <span class="pl-v">$(<span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">2</span>)</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> =&gt; "2 + 2 = 4"</span>
<span class="pl-c"><span class="pl-c">#</span> You can put any Julia expression inside the parentheses.</span>

<span class="pl-c"><span class="pl-c">#</span> Printing is easy</span>
<span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>I'm Julia. Nice to meet you!<span class="pl-pds">"</span></span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; I'm Julia. Nice to meet you!</span>

<span class="pl-c"><span class="pl-c">#</span> Another way to format strings is the printf macro from the stdlib Printf.</span>
<span class="pl-k">using</span> Printf   <span class="pl-c"><span class="pl-c">#</span> this is how you load (or import) a module</span>
<span class="pl-c1">@printf</span> <span class="pl-s"><span class="pl-pds">"</span>%d is less than %f<span class="pl-cce">\n</span><span class="pl-pds">"</span></span> <span class="pl-c1">4.5</span> <span class="pl-c1">5.3</span>   <span class="pl-c"><span class="pl-c">#</span> =&gt; 5 is less than 5.300000</span>


<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span># 2. Variables and Collections</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> You don't declare variables before assigning to them.</span>
someVar <span class="pl-k">=</span> <span class="pl-c1">5</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; 5</span>
someVar      <span class="pl-c"><span class="pl-c">#</span> =&gt; 5</span>

<span class="pl-c"><span class="pl-c">#</span> Accessing a previously unassigned variable is an error</span>
<span class="pl-k">try</span>
    someOtherVar  <span class="pl-c"><span class="pl-c">#</span> =&gt; ERROR: UndefVarError: someOtherVar not defined</span>
<span class="pl-k">catch</span> e
    <span class="pl-c1">println</span>(e)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Variable names start with a letter or underscore.</span>
<span class="pl-c"><span class="pl-c">#</span> After that, you can use letters, digits, underscores, and exclamation points.</span>
SomeOtherVar123! <span class="pl-k">=</span> <span class="pl-c1">6</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; 6</span>

<span class="pl-c"><span class="pl-c">#</span> You can also use certain unicode characters</span>
<span class="pl-c"><span class="pl-c">#</span> here ☃ is a Unicode 'snowman' characters, see http://emojipedia.org/%E2%98%83%EF%B8%8F if it displays wrongly here</span>
☃ <span class="pl-k">=</span> <span class="pl-c1">8</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; 8</span>
<span class="pl-c"><span class="pl-c">#</span> These are especially handy for mathematical notation, like the constant π</span>
<span class="pl-c1">2</span> <span class="pl-k">*</span> π  <span class="pl-c"><span class="pl-c">#</span> =&gt; 6.283185307179586</span>

<span class="pl-c"><span class="pl-c">#</span> A note on naming conventions in Julia:</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> * Word separation can be indicated by underscores ('_'), but use of</span>
<span class="pl-c"><span class="pl-c">#</span>   underscores is discouraged unless the name would be hard to read</span>
<span class="pl-c"><span class="pl-c">#</span>   otherwise.</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> * Names of Types begin with a capital letter and word separation is shown</span>
<span class="pl-c"><span class="pl-c">#</span>   with CamelCase instead of underscores.</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> * Names of functions and macros are in lower case, without underscores.</span>
<span class="pl-c"><span class="pl-c">#</span></span>
<span class="pl-c"><span class="pl-c">#</span> * Functions that modify their inputs have names that end in !. These</span>
<span class="pl-c"><span class="pl-c">#</span>   functions are sometimes called mutating functions or in-place functions.</span>

<span class="pl-c"><span class="pl-c">#</span> Arrays store a sequence of values indexed by integers 1 through n:</span>
a <span class="pl-k">=</span> Int64[] <span class="pl-c"><span class="pl-c">#</span> =&gt; 0-element Array{Int64,1}</span>

<span class="pl-c"><span class="pl-c">#</span> 1-dimensional array literals can be written with comma-separated values.</span>
b <span class="pl-k">=</span> [<span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>] <span class="pl-c"><span class="pl-c">#</span> =&gt; 3-element Array{Int64,1}: [4, 5, 6]</span>
b <span class="pl-k">=</span> [<span class="pl-c1">4</span>; <span class="pl-c1">5</span>; <span class="pl-c1">6</span>] <span class="pl-c"><span class="pl-c">#</span> =&gt; 3-element Array{Int64,1}: [4, 5, 6]</span>
b[<span class="pl-c1">1</span>]    <span class="pl-c"><span class="pl-c">#</span> =&gt; 4</span>
b[<span class="pl-c1">end</span>]  <span class="pl-c"><span class="pl-c">#</span> =&gt; 6</span>

<span class="pl-c"><span class="pl-c">#</span> 2-dimensional arrays use space-separated values and semicolon-separated rows.</span>
matrix <span class="pl-k">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span>; <span class="pl-c1">3</span> <span class="pl-c1">4</span>] <span class="pl-c"><span class="pl-c">#</span> =&gt; 2×2 Array{Int64,2}: [1 2; 3 4]</span>

<span class="pl-c"><span class="pl-c">#</span> Arrays of a particular type</span>
b <span class="pl-k">=</span> Int8[<span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>] <span class="pl-c"><span class="pl-c">#</span> =&gt; 3-element Array{Int8,1}: [4, 5, 6]</span>

<span class="pl-c"><span class="pl-c">#</span> Add stuff to the end of a list with push! and append!</span>
<span class="pl-c"><span class="pl-c">#</span> By convention, the exclamation mark '!' is appended to names of functions</span>
<span class="pl-c"><span class="pl-c">#</span> that modify their arguments</span>
<span class="pl-c1">push!</span>(a, <span class="pl-c1">1</span>)    <span class="pl-c"><span class="pl-c">#</span> =&gt; [1]</span>
<span class="pl-c1">push!</span>(a, <span class="pl-c1">2</span>)    <span class="pl-c"><span class="pl-c">#</span> =&gt; [1,2]</span>
<span class="pl-c1">push!</span>(a, <span class="pl-c1">4</span>)    <span class="pl-c"><span class="pl-c">#</span> =&gt; [1,2,4]</span>
<span class="pl-c1">push!</span>(a, <span class="pl-c1">3</span>)    <span class="pl-c"><span class="pl-c">#</span> =&gt; [1,2,4,3]</span>
<span class="pl-c1">append!</span>(a, b)  <span class="pl-c"><span class="pl-c">#</span> =&gt; [1,2,4,3,4,5,6]</span>

<span class="pl-c"><span class="pl-c">#</span> Remove from the end with pop</span>
<span class="pl-c1">pop!</span>(b)  <span class="pl-c"><span class="pl-c">#</span> =&gt; 6</span>
b <span class="pl-c"><span class="pl-c">#</span> =&gt; [4,5]</span>

<span class="pl-c"><span class="pl-c">#</span> Let's put it back</span>
<span class="pl-c1">push!</span>(b, <span class="pl-c1">6</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; [4,5,6]</span>
b <span class="pl-c"><span class="pl-c">#</span> =&gt; [4,5,6]</span>

a[<span class="pl-c1">1</span>]  <span class="pl-c"><span class="pl-c">#</span> =&gt; 1  # remember that Julia indexes from 1, not 0!</span>

<span class="pl-c"><span class="pl-c">#</span> end is a shorthand for the last index. It can be used in any</span>
<span class="pl-c"><span class="pl-c">#</span> indexing expression</span>
a[<span class="pl-c1">end</span>]  <span class="pl-c"><span class="pl-c">#</span> =&gt; 6</span>

<span class="pl-c"><span class="pl-c">#</span> we also have popfirst! and pushfirst!</span>
<span class="pl-c1">popfirst!</span>(a)  <span class="pl-c"><span class="pl-c">#</span> =&gt; 1 </span>
a <span class="pl-c"><span class="pl-c">#</span> =&gt; [2,4,3,4,5,6]</span>
<span class="pl-c1">pushfirst!</span>(a, <span class="pl-c1">7</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; [7,2,4,3,4,5,6]</span>
a <span class="pl-c"><span class="pl-c">#</span> =&gt; [7,2,4,3,4,5,6]</span>

<span class="pl-c"><span class="pl-c">#</span> Function names that end in exclamations points indicate that they modify</span>
<span class="pl-c"><span class="pl-c">#</span> their argument.</span>
arr <span class="pl-k">=</span> [<span class="pl-c1">5</span>,<span class="pl-c1">4</span>,<span class="pl-c1">6</span>]  <span class="pl-c"><span class="pl-c">#</span> =&gt; 3-element Array{Int64,1}: [5,4,6]</span>
<span class="pl-c1">sort</span>(arr)      <span class="pl-c"><span class="pl-c">#</span> =&gt; [4,5,6]</span>
arr            <span class="pl-c"><span class="pl-c">#</span> =&gt; [5,4,6]</span>
<span class="pl-c1">sort!</span>(arr)     <span class="pl-c"><span class="pl-c">#</span> =&gt; [4,5,6]</span>
arr            <span class="pl-c"><span class="pl-c">#</span> =&gt; [4,5,6]</span>

<span class="pl-c"><span class="pl-c">#</span> Looking out of bounds is a BoundsError</span>
<span class="pl-k">try</span>
    a[<span class="pl-c1">0</span>] 
    <span class="pl-c"><span class="pl-c">#</span> =&gt; ERROR: BoundsError: attempt to access 7-element Array{Int64,1} at </span>
    <span class="pl-c"><span class="pl-c">#</span> index [0]</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt; Stacktrace:</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt;  [1] getindex(::Array{Int64,1}, ::Int64) at .\array.jl:731</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt;  [2] top-level scope at none:0</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt;  [3] ...</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt; in expression starting at ...\LearnJulia.jl:180</span>
    a[<span class="pl-c1">end</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>] 
    <span class="pl-c"><span class="pl-c">#</span> =&gt; ERROR: BoundsError: attempt to access 7-element Array{Int64,1} at </span>
    <span class="pl-c"><span class="pl-c">#</span> index [8]</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt; Stacktrace:</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt;  [1] getindex(::Array{Int64,1}, ::Int64) at .\array.jl:731</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt;  [2] top-level scope at none:0</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt;  [3] ...</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt; in expression starting at ...\LearnJulia.jl:188</span>
<span class="pl-k">catch</span> e
    <span class="pl-c1">println</span>(e)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Errors list the line and file they came from, even if it's in the standard</span>
<span class="pl-c"><span class="pl-c">#</span> library. You can look in the folder share/julia inside the julia folder to</span>
<span class="pl-c"><span class="pl-c">#</span> find these files.</span>

<span class="pl-c"><span class="pl-c">#</span> You can initialize arrays from ranges</span>
a <span class="pl-k">=</span> [<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>;]  <span class="pl-c"><span class="pl-c">#</span> =&gt; 5-element Array{Int64,1}: [1,2,3,4,5]</span>
a2 <span class="pl-k">=</span> [<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">5</span>]  <span class="pl-c"><span class="pl-c">#</span> =&gt; 1-element Array{UnitRange{Int64},1}: [1:5]</span>

<span class="pl-c"><span class="pl-c">#</span> You can look at ranges with slice syntax.</span>
a[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">3</span>]    <span class="pl-c"><span class="pl-c">#</span> =&gt; [1, 2, 3]</span>
a[<span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">end</span>]  <span class="pl-c"><span class="pl-c">#</span> =&gt; [2, 3, 4, 5]</span>

<span class="pl-c"><span class="pl-c">#</span> Remove elements from an array by index with splice!</span>
arr <span class="pl-k">=</span> [<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>]
<span class="pl-c1">splice!</span>(arr, <span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">#</span> =&gt; 4 </span>
arr <span class="pl-c"><span class="pl-c">#</span> =&gt; [3,5]</span>

<span class="pl-c"><span class="pl-c">#</span> Concatenate lists with append!</span>
b <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]
<span class="pl-c1">append!</span>(a, b) <span class="pl-c"><span class="pl-c">#</span> =&gt; [1, 2, 3, 4, 5, 1, 2, 3]</span>
a <span class="pl-c"><span class="pl-c">#</span> =&gt; [1, 2, 3, 4, 5, 1, 2, 3]</span>

<span class="pl-c"><span class="pl-c">#</span> Check for existence in a list with in</span>
<span class="pl-c1">in</span>(<span class="pl-c1">1</span>, a)  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>

<span class="pl-c"><span class="pl-c">#</span> Examine the length with length</span>
<span class="pl-c1">length</span>(a)  <span class="pl-c"><span class="pl-c">#</span> =&gt; 8</span>

<span class="pl-c"><span class="pl-c">#</span> Tuples are immutable.</span>
tup <span class="pl-k">=</span> (<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; (1,2,3)</span>
<span class="pl-c1">typeof</span>(tup) <span class="pl-c"><span class="pl-c">#</span> =&gt; Tuple{Int64,Int64,Int64}</span>
tup[<span class="pl-c1">1</span>] <span class="pl-c"><span class="pl-c">#</span> =&gt; 1</span>
<span class="pl-k">try</span>
    tup[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">3</span>  
    <span class="pl-c"><span class="pl-c">#</span> =&gt; ERROR: MethodError: no method matching </span>
    <span class="pl-c"><span class="pl-c">#</span> setindex!(::Tuple{Int64,Int64,Int64}, ::Int64, ::Int64)</span>
<span class="pl-k">catch</span> e
    <span class="pl-c1">println</span>(e)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Many array functions also work on tuples</span>
<span class="pl-c1">length</span>(tup) <span class="pl-c"><span class="pl-c">#</span> =&gt; 3</span>
tup[<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>]    <span class="pl-c"><span class="pl-c">#</span> =&gt; (1,2)</span>
<span class="pl-c1">in</span>(<span class="pl-c1">2</span>, tup)  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>

<span class="pl-c"><span class="pl-c">#</span> You can unpack tuples into variables</span>
a, b, c <span class="pl-k">=</span> (<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; (1,2,3)  </span>
a  <span class="pl-c"><span class="pl-c">#</span> =&gt; 1</span>
b  <span class="pl-c"><span class="pl-c">#</span> =&gt; 2</span>
c  <span class="pl-c"><span class="pl-c">#</span> =&gt; 3</span>

<span class="pl-c"><span class="pl-c">#</span> Tuples are created even if you leave out the parentheses</span>
d, e, f <span class="pl-k">=</span> <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; (4,5,6)</span>
d  <span class="pl-c"><span class="pl-c">#</span> =&gt; 4</span>
e  <span class="pl-c"><span class="pl-c">#</span> =&gt; 5</span>
f  <span class="pl-c"><span class="pl-c">#</span> =&gt; 6</span>

<span class="pl-c"><span class="pl-c">#</span> A 1-element tuple is distinct from the value it contains</span>
(<span class="pl-c1">1</span>,) <span class="pl-k">==</span> <span class="pl-c1">1</span> <span class="pl-c"><span class="pl-c">#</span> =&gt; false</span>
(<span class="pl-c1">1</span>) <span class="pl-k">==</span> <span class="pl-c1">1</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>

<span class="pl-c"><span class="pl-c">#</span> Look how easy it is to swap two values</span>
e, d <span class="pl-k">=</span> d, e  <span class="pl-c"><span class="pl-c">#</span> =&gt; (5,4) </span>
d  <span class="pl-c"><span class="pl-c">#</span> =&gt; 5</span>
e  <span class="pl-c"><span class="pl-c">#</span> =&gt; 4</span>

<span class="pl-c"><span class="pl-c">#</span> Dictionaries store mappings</span>
emptyDict <span class="pl-k">=</span> <span class="pl-c1">Dict</span>()  <span class="pl-c"><span class="pl-c">#</span> =&gt; Dict{Any,Any} with 0 entries</span>

<span class="pl-c"><span class="pl-c">#</span> You can create a dictionary using a literal</span>
filledDict <span class="pl-k">=</span> <span class="pl-c1">Dict</span>(<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">2</span>, <span class="pl-s"><span class="pl-pds">"</span>three<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">3</span>)
<span class="pl-c"><span class="pl-c">#</span> =&gt; Dict{String,Int64} with 3 entries:</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt;  "two" =&gt; 2, "one" =&gt; 1, "three" =&gt; 3</span>

<span class="pl-c"><span class="pl-c">#</span> Look up values with []</span>
filledDict[<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>]  <span class="pl-c"><span class="pl-c">#</span> =&gt; 1</span>

<span class="pl-c"><span class="pl-c">#</span> Get all keys</span>
<span class="pl-c1">keys</span>(filledDict)
<span class="pl-c"><span class="pl-c">#</span> =&gt; Base.KeySet for a Dict{String,Int64} with 3 entries. Keys:</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt;  "two", "one", "three"</span>
<span class="pl-c"><span class="pl-c">#</span> Note - dictionary keys are not sorted or in the order you inserted them.</span>

<span class="pl-c"><span class="pl-c">#</span> Get all values</span>
<span class="pl-c1">values</span>(filledDict)
<span class="pl-c"><span class="pl-c">#</span> =&gt; Base.ValueIterator for a Dict{String,Int64} with 3 entries. Values: </span>
<span class="pl-c"><span class="pl-c">#</span> =&gt;  2, 1, 3</span>
<span class="pl-c"><span class="pl-c">#</span> Note - Same as above regarding key ordering.</span>

<span class="pl-c"><span class="pl-c">#</span> Check for existence of keys in a dictionary with in, haskey</span>
<span class="pl-c1">in</span>((<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">1</span>), filledDict)  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-c1">in</span>((<span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-c1">3</span>), filledDict)  <span class="pl-c"><span class="pl-c">#</span> =&gt; false</span>
<span class="pl-c1">haskey</span>(filledDict, <span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>)     <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-c1">haskey</span>(filledDict, <span class="pl-c1">1</span>)         <span class="pl-c"><span class="pl-c">#</span> =&gt; false</span>

<span class="pl-c"><span class="pl-c">#</span> Trying to look up a non-existent key will raise an error</span>
<span class="pl-k">try</span>
    filledDict[<span class="pl-s"><span class="pl-pds">"</span>four<span class="pl-pds">"</span></span>]  <span class="pl-c"><span class="pl-c">#</span> =&gt; ERROR: KeyError: key "four" not found</span>
<span class="pl-k">catch</span> e
    <span class="pl-c1">println</span>(e)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Use the get method to avoid that error by providing a default value</span>
<span class="pl-c"><span class="pl-c">#</span> get(dictionary, key, defaultValue)</span>
<span class="pl-c1">get</span>(filledDict, <span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>, <span class="pl-c1">4</span>)   <span class="pl-c"><span class="pl-c">#</span> =&gt; 1</span>
<span class="pl-c1">get</span>(filledDict, <span class="pl-s"><span class="pl-pds">"</span>four<span class="pl-pds">"</span></span>, <span class="pl-c1">4</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; 4</span>

<span class="pl-c"><span class="pl-c">#</span> Use Sets to represent collections of unordered, unique values</span>
emptySet <span class="pl-k">=</span> <span class="pl-c1">Set</span>()  <span class="pl-c"><span class="pl-c">#</span> =&gt; Set(Any[])</span>
<span class="pl-c"><span class="pl-c">#</span> Initialize a set with values</span>
filledSet <span class="pl-k">=</span> <span class="pl-c1">Set</span>([<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>])  <span class="pl-c"><span class="pl-c">#</span> =&gt; Set([4, 2, 3, 1])</span>

<span class="pl-c"><span class="pl-c">#</span> Add more values to a set</span>
<span class="pl-c1">push!</span>(filledSet, <span class="pl-c1">5</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; Set([4, 2, 3, 5, 1])</span>

<span class="pl-c"><span class="pl-c">#</span> Check if the values are in the set</span>
<span class="pl-c1">in</span>(<span class="pl-c1">2</span>, filledSet)   <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
<span class="pl-c1">in</span>(<span class="pl-c1">10</span>, filledSet)  <span class="pl-c"><span class="pl-c">#</span> =&gt; false</span>

<span class="pl-c"><span class="pl-c">#</span> There are functions for set intersection, union, and difference.</span>
otherSet <span class="pl-k">=</span> <span class="pl-c1">Set</span>([<span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>])         <span class="pl-c"><span class="pl-c">#</span> =&gt; Set([4, 3, 5, 6])</span>
<span class="pl-c1">intersect</span>(filledSet, otherSet)      <span class="pl-c"><span class="pl-c">#</span> =&gt; Set([4, 3, 5])</span>
<span class="pl-c1">union</span>(filledSet, otherSet)          <span class="pl-c"><span class="pl-c">#</span> =&gt; Set([4, 2, 3, 5, 6, 1])</span>
<span class="pl-c1">setdiff</span>(<span class="pl-c1">Set</span>([<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>]), <span class="pl-c1">Set</span>([<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">5</span>])) <span class="pl-c"><span class="pl-c">#</span> =&gt; Set([4, 1])</span>

<span class="pl-c"><span class="pl-c">#</span> Assignment with `=` attaches a new label to the same value without copying</span>
a <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>]
b <span class="pl-k">=</span> a
<span class="pl-c"><span class="pl-c">#</span> Now `b` and `a` point to the same value, so changing one affects the other:</span>
a[<span class="pl-c1">3</span>] <span class="pl-k">=</span> <span class="pl-c1">5</span>
b[<span class="pl-c1">3</span>]  <span class="pl-c"><span class="pl-c">#</span> =&gt; 5</span>

<span class="pl-c"><span class="pl-c">#</span> The `copy()` function can create a shallow copy of an array, dictionary,</span>
<span class="pl-c"><span class="pl-c">#</span> or other container</span>
a <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>]
c <span class="pl-k">=</span> <span class="pl-c1">copy</span>(a)
a[<span class="pl-c1">3</span>] <span class="pl-k">=</span> <span class="pl-c1">5</span>
c[<span class="pl-c1">3</span>] <span class="pl-c"><span class="pl-c">#</span> =&gt; 3</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span># 3. Control Flow</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> Let's make a variable</span>
someVar <span class="pl-k">=</span> <span class="pl-c1">5</span>

<span class="pl-c"><span class="pl-c">#</span> Here is an if statement. Indentation is not meaningful in Julia.</span>
<span class="pl-k">if</span> someVar <span class="pl-k">&gt;</span> <span class="pl-c1">10</span>
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>someVar is totally bigger than 10.<span class="pl-pds">"</span></span>)
<span class="pl-k">elseif</span> someVar <span class="pl-k">&lt;</span> <span class="pl-c1">10</span>    <span class="pl-c"><span class="pl-c">#</span> This elseif clause is optional.</span>
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>someVar is smaller than 10.<span class="pl-pds">"</span></span>)
<span class="pl-k">else</span>                    <span class="pl-c"><span class="pl-c">#</span> The else clause is optional too.</span>
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>someVar is indeed 10.<span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; prints "some var is smaller than 10"</span>

<span class="pl-c"><span class="pl-c">#</span> For loops iterate over iterables.</span>
<span class="pl-c"><span class="pl-c">#</span> Iterable types include Range, Array, Set, Dict, and AbstractString.</span>
<span class="pl-k">for</span> animal <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>dog<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>cat<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>mouse<span class="pl-pds">"</span></span>]
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$animal</span> is a mammal<span class="pl-pds">"</span></span>)
    <span class="pl-c"><span class="pl-c">#</span> You can use $ to interpolate variables or expression into strings.</span>
    <span class="pl-c"><span class="pl-c">#</span> In this special case, no need for parenthesis: $animal and $(animal) give the same</span>
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; dog is a mammal</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; cat is a mammal</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; mouse is a mammal</span>

<span class="pl-c"><span class="pl-c">#</span> You can use 'in' instead of '='.</span>
<span class="pl-k">for</span> animal <span class="pl-k">in</span> [<span class="pl-s"><span class="pl-pds">"</span>dog<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>cat<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>mouse<span class="pl-pds">"</span></span>]
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$animal</span> is a mammal<span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; dog is a mammal</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; cat is a mammal</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; mouse is a mammal</span>

<span class="pl-k">for</span> pair <span class="pl-k">in</span> <span class="pl-c1">Dict</span>(<span class="pl-s"><span class="pl-pds">"</span>dog<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>mammal<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>cat<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>mammal<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>mouse<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>mammal<span class="pl-pds">"</span></span>)
    from, to <span class="pl-k">=</span> pair
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$from</span> is a <span class="pl-v">$to</span><span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; mouse is a mammal</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; cat is a mammal</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; dog is a mammal</span>

<span class="pl-k">for</span> (k, v) <span class="pl-k">in</span> <span class="pl-c1">Dict</span>(<span class="pl-s"><span class="pl-pds">"</span>dog<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>mammal<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>cat<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>mammal<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>mouse<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>mammal<span class="pl-pds">"</span></span>)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$k</span> is a <span class="pl-v">$v</span><span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; mouse is a mammal</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; cat is a mammal</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; dog is a mammal</span>

<span class="pl-c"><span class="pl-c">#</span> While loops loop while a condition is true</span>
<span class="pl-k">let</span> x <span class="pl-k">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">while</span> x <span class="pl-k">&lt;</span> <span class="pl-c1">4</span>
        <span class="pl-c1">println</span>(x)
        x <span class="pl-k">+=</span> <span class="pl-c1">1</span>  <span class="pl-c"><span class="pl-c">#</span> Shorthand for in place increment: x = x + 1</span>
    <span class="pl-k">end</span>
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; 0</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; 1</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; 2</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; 3</span>

<span class="pl-c"><span class="pl-c">#</span> Handle exceptions with a try/catch block</span>
<span class="pl-k">try</span>
    <span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>help<span class="pl-pds">"</span></span>)
<span class="pl-k">catch</span> e
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>caught it <span class="pl-v">$e</span><span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; caught it ErrorException("help")</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span># 4. Functions</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> The keyword 'function' creates new functions</span>
<span class="pl-c"><span class="pl-c">#</span> function name(arglist)</span>
<span class="pl-c"><span class="pl-c">#</span>   body...</span>
<span class="pl-c"><span class="pl-c">#</span> end</span>
<span class="pl-k">function</span> <span class="pl-en">add</span>(x, y)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>x is <span class="pl-v">$x</span> and y is <span class="pl-v">$y</span><span class="pl-pds">"</span></span>)

    <span class="pl-c"><span class="pl-c">#</span> Functions return the value of their last statement</span>
    x <span class="pl-k">+</span> y
<span class="pl-k">end</span>

<span class="pl-c1">add</span>(<span class="pl-c1">5</span>, <span class="pl-c1">6</span>)
<span class="pl-c"><span class="pl-c">#</span> =&gt; x is 5 and y is 6</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; 11</span>

<span class="pl-c"><span class="pl-c">#</span> Compact assignment of functions</span>
<span class="pl-en">f_add</span>(x, y) <span class="pl-k">=</span> x <span class="pl-k">+</span> y  <span class="pl-c"><span class="pl-c">#</span> =&gt; f_add (generic function with 1 method)</span>
<span class="pl-c1">f_add</span>(<span class="pl-c1">3</span>, <span class="pl-c1">4</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; 7</span>

<span class="pl-c"><span class="pl-c">#</span> Function can also return multiple values as tuple</span>
<span class="pl-en">fn</span>(x, y) <span class="pl-k">=</span> x <span class="pl-k">+</span> y, x <span class="pl-k">-</span> y <span class="pl-c"><span class="pl-c">#</span> =&gt; fn (generic function with 1 method)</span>
<span class="pl-c1">fn</span>(<span class="pl-c1">3</span>, <span class="pl-c1">4</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; (7, -1)</span>

<span class="pl-c"><span class="pl-c">#</span> You can define functions that take a variable number of</span>
<span class="pl-c"><span class="pl-c">#</span> positional arguments</span>
<span class="pl-k">function</span> <span class="pl-en">varargs</span>(args<span class="pl-k">...</span>)
    <span class="pl-k">return</span> args
    <span class="pl-c"><span class="pl-c">#</span> use the keyword return to return anywhere in the function</span>
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; varargs (generic function with 1 method)</span>

<span class="pl-c1">varargs</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; (1,2,3)</span>

<span class="pl-c"><span class="pl-c">#</span> The ... is called a splat.</span>
<span class="pl-c"><span class="pl-c">#</span> We just used it in a function definition.</span>
<span class="pl-c"><span class="pl-c">#</span> It can also be used in a function call,</span>
<span class="pl-c"><span class="pl-c">#</span> where it will splat an Array or Tuple's contents into the argument list.</span>
<span class="pl-c1">add</span>([<span class="pl-c1">5</span>,<span class="pl-c1">6</span>]<span class="pl-k">.</span><span class="pl-k">..</span>)  <span class="pl-c"><span class="pl-c">#</span> this is equivalent to add(5,6)</span>

x <span class="pl-k">=</span> (<span class="pl-c1">5</span>, <span class="pl-c1">6</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; (5,6)</span>
<span class="pl-c1">add</span>(x<span class="pl-k">...</span>)  <span class="pl-c"><span class="pl-c">#</span> this is equivalent to add(5,6)</span>


<span class="pl-c"><span class="pl-c">#</span> You can define functions with optional positional arguments</span>
<span class="pl-k">function</span> <span class="pl-en">defaults</span>(a, b, x<span class="pl-k">=</span><span class="pl-c1">5</span>, y<span class="pl-k">=</span><span class="pl-c1">6</span>)
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-v">$a</span> <span class="pl-v">$b</span> and <span class="pl-v">$x</span> <span class="pl-v">$y</span><span class="pl-pds">"</span></span>
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; defaults (generic function with 3 methods)</span>

<span class="pl-c1">defaults</span>(<span class="pl-s"><span class="pl-pds">'</span>h<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>g<span class="pl-pds">'</span></span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; "h g and 5 6"</span>
<span class="pl-c1">defaults</span>(<span class="pl-s"><span class="pl-pds">'</span>h<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>g<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>j<span class="pl-pds">'</span></span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; "h g and j 6"</span>
<span class="pl-c1">defaults</span>(<span class="pl-s"><span class="pl-pds">'</span>h<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>g<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>j<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>k<span class="pl-pds">'</span></span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; "h g and j k"</span>
<span class="pl-k">try</span>
    <span class="pl-c1">defaults</span>(<span class="pl-s"><span class="pl-pds">'</span>h<span class="pl-pds">'</span></span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; ERROR: MethodError: no method matching defaults(::Char)</span>
    <span class="pl-c1">defaults</span>()  <span class="pl-c"><span class="pl-c">#</span> =&gt; ERROR: MethodError: no method matching defaults()</span>
<span class="pl-k">catch</span> e
    <span class="pl-c1">println</span>(e)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> You can define functions that take keyword arguments</span>
<span class="pl-k">function</span> <span class="pl-en">keyword_args</span>(;k1<span class="pl-k">=</span><span class="pl-c1">4</span>, name2<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>)  <span class="pl-c"><span class="pl-c">#</span> note the ;</span>
    <span class="pl-k">return</span> <span class="pl-c1">Dict</span>(<span class="pl-s"><span class="pl-pds">"</span>k1<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> k1, <span class="pl-s"><span class="pl-pds">"</span>name2<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> name2)
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; keyword_args (generic function with 1 method)</span>

<span class="pl-c1">keyword_args</span>(name2<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>ness<span class="pl-pds">"</span></span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; ["name2"=&gt;"ness", "k1"=&gt;4]</span>
<span class="pl-c1">keyword_args</span>(k1<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>mine<span class="pl-pds">"</span></span>)     <span class="pl-c"><span class="pl-c">#</span> =&gt; ["name2"=&gt;"hello", "k1"=&gt;"mine"]</span>
<span class="pl-c1">keyword_args</span>()              <span class="pl-c"><span class="pl-c">#</span> =&gt; ["name2"=&gt;"hello", "k1"=&gt;4]</span>

<span class="pl-c"><span class="pl-c">#</span> You can combine all kinds of arguments in the same function</span>
<span class="pl-k">function</span> <span class="pl-en">all_the_args</span>(normalArg, optionalPositionalArg<span class="pl-k">=</span><span class="pl-c1">2</span>; keywordArg<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>normal arg: <span class="pl-v">$normalArg</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>optional arg: <span class="pl-v">$optionalPositionalArg</span><span class="pl-pds">"</span></span>)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>keyword arg: <span class="pl-v">$keywordArg</span><span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; all_the_args (generic function with 2 methods)</span>

<span class="pl-c1">all_the_args</span>(<span class="pl-c1">1</span>, <span class="pl-c1">3</span>, keywordArg<span class="pl-k">=</span><span class="pl-c1">4</span>)
<span class="pl-c"><span class="pl-c">#</span> =&gt; normal arg: 1</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; optional arg: 3</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; keyword arg: 4</span>

<span class="pl-c"><span class="pl-c">#</span> Julia has first class functions</span>
<span class="pl-k">function</span> <span class="pl-en">create_adder</span>(x)
    adder <span class="pl-k">=</span> <span class="pl-k">function</span> (y)
        <span class="pl-k">return</span> x <span class="pl-k">+</span> y
    <span class="pl-k">end</span>
    <span class="pl-k">return</span> adder
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; create_adder (generic function with 1 method)</span>

<span class="pl-c"><span class="pl-c">#</span> This is "stabby lambda syntax" for creating anonymous functions</span>
(x <span class="pl-k">-&gt;</span> x <span class="pl-k">&gt;</span> <span class="pl-c1">2</span>)(<span class="pl-c1">3</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>

<span class="pl-c"><span class="pl-c">#</span> This function is identical to create_adder implementation above.</span>
<span class="pl-k">function</span> <span class="pl-en">create_adder</span>(x)
    y <span class="pl-k">-&gt;</span> x <span class="pl-k">+</span> y
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; create_adder (generic function with 1 method)</span>

<span class="pl-c"><span class="pl-c">#</span> You can also name the internal function, if you want</span>
<span class="pl-k">function</span> <span class="pl-en">create_adder</span>(x)
    <span class="pl-k">function</span> <span class="pl-en">adder</span>(y)
        x <span class="pl-k">+</span> y
    <span class="pl-k">end</span>
    adder
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; create_adder (generic function with 1 method)</span>

add_10 <span class="pl-k">=</span> <span class="pl-c1">create_adder</span>(<span class="pl-c1">10</span>) <span class="pl-c"><span class="pl-c">#</span> =&gt; (::getfield(Main, Symbol("#adder#11")){Int64}) </span>
                          <span class="pl-c"><span class="pl-c">#</span> (generic function with 1 method)</span>
<span class="pl-c1">add_10</span>(<span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">#</span> =&gt; 13</span>


<span class="pl-c"><span class="pl-c">#</span> There are built-in higher order functions</span>
<span class="pl-c1">map</span>(add_10, [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>])  <span class="pl-c"><span class="pl-c">#</span> =&gt; [11, 12, 13]</span>
<span class="pl-c1">filter</span>(x <span class="pl-k">-&gt;</span> x <span class="pl-k">&gt;</span> <span class="pl-c1">5</span>, [<span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>])  <span class="pl-c"><span class="pl-c">#</span> =&gt; [6, 7]</span>

<span class="pl-c"><span class="pl-c">#</span> We can use list comprehensions</span>
[<span class="pl-c1">add_10</span>(i) <span class="pl-k">for</span> i <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>]]   <span class="pl-c"><span class="pl-c">#</span> =&gt; [11, 12, 13]</span>
[<span class="pl-c1">add_10</span>(i) <span class="pl-k">for</span> i <span class="pl-k">in</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>]]  <span class="pl-c"><span class="pl-c">#</span> =&gt; [11, 12, 13]</span>
[x <span class="pl-k">for</span> x <span class="pl-k">in</span> [<span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>] <span class="pl-k">if</span> x <span class="pl-k">&gt;</span> <span class="pl-c1">5</span>] <span class="pl-c"><span class="pl-c">#</span> =&gt; [6, 7]</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span># 5. Types</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> Julia has a type system.</span>
<span class="pl-c"><span class="pl-c">#</span> Every value has a type; variables do not have types themselves.</span>
<span class="pl-c"><span class="pl-c">#</span> You can use the `typeof` function to get the type of a value.</span>
<span class="pl-c1">typeof</span>(<span class="pl-c1">5</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; Int64</span>

<span class="pl-c"><span class="pl-c">#</span> Types are first-class values</span>
<span class="pl-c1">typeof</span>(Int64)     <span class="pl-c"><span class="pl-c">#</span> =&gt; DataType</span>
<span class="pl-c1">typeof</span>(DataType)  <span class="pl-c"><span class="pl-c">#</span> =&gt; DataType</span>
<span class="pl-c"><span class="pl-c">#</span> DataType is the type that represents types, including itself.</span>

<span class="pl-c"><span class="pl-c">#</span> Types are used for documentation, optimizations, and dispatch.</span>
<span class="pl-c"><span class="pl-c">#</span> They are not statically checked.</span>

<span class="pl-c"><span class="pl-c">#</span> Users can define types</span>
<span class="pl-c"><span class="pl-c">#</span> They are like records or structs in other languages.</span>
<span class="pl-c"><span class="pl-c">#</span> New types are defined using the `struct` keyword.</span>

<span class="pl-c"><span class="pl-c">#</span> struct Name</span>
<span class="pl-c"><span class="pl-c">#</span>   field::OptionalType</span>
<span class="pl-c"><span class="pl-c">#</span>   ...</span>
<span class="pl-c"><span class="pl-c">#</span> end</span>
<span class="pl-k">struct</span> Tiger
    taillength<span class="pl-k">::</span><span class="pl-c1">Float64</span>
    coatcolor  <span class="pl-c"><span class="pl-c">#</span> not including a type annotation is the same as `::Any`</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> The default constructor's arguments are the properties</span>
<span class="pl-c"><span class="pl-c">#</span> of the type, in the order they are listed in the definition</span>
tigger <span class="pl-k">=</span> <span class="pl-c1">Tiger</span>(<span class="pl-c1">3.5</span>, <span class="pl-s"><span class="pl-pds">"</span>orange<span class="pl-pds">"</span></span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; Tiger(3.5,"orange")</span>

<span class="pl-c"><span class="pl-c">#</span> The type doubles as the constructor function for values of that type</span>
sherekhan <span class="pl-k">=</span> <span class="pl-c1">typeof</span>(tigger)(<span class="pl-c1">5.6</span>, <span class="pl-s"><span class="pl-pds">"</span>fire<span class="pl-pds">"</span></span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; Tiger(5.6,"fire")</span>

<span class="pl-c"><span class="pl-c">#</span> These struct-style types are called concrete types</span>
<span class="pl-c"><span class="pl-c">#</span> They can be instantiated, but cannot have subtypes.</span>
<span class="pl-c"><span class="pl-c">#</span> The other kind of types is abstract types.</span>

<span class="pl-c"><span class="pl-c">#</span> abstract Name</span>
<span class="pl-k">abstract type</span> Cat <span class="pl-k">end</span>  <span class="pl-c"><span class="pl-c">#</span> just a name and point in the type hierarchy</span>

<span class="pl-c"><span class="pl-c">#</span> Abstract types cannot be instantiated, but can have subtypes.</span>
<span class="pl-c"><span class="pl-c">#</span> For example, Number is an abstract type</span>
<span class="pl-c1">subtypes</span>(Number)  <span class="pl-c"><span class="pl-c">#</span> =&gt; 2-element Array{Any,1}:</span>
                  <span class="pl-c"><span class="pl-c">#</span> =&gt;  Complex</span>
                  <span class="pl-c"><span class="pl-c">#</span> =&gt;  Real</span>
<span class="pl-c1">subtypes</span>(Cat)  <span class="pl-c"><span class="pl-c">#</span> =&gt; 0-element Array{Any,1}</span>

<span class="pl-c"><span class="pl-c">#</span> AbstractString, as the name implies, is also an abstract type</span>
<span class="pl-c1">subtypes</span>(AbstractString)  <span class="pl-c"><span class="pl-c">#</span> =&gt; 4-element Array{Any,1}:</span>
                          <span class="pl-c"><span class="pl-c">#</span> =&gt;  String</span>
                          <span class="pl-c"><span class="pl-c">#</span> =&gt;  SubString</span>
                          <span class="pl-c"><span class="pl-c">#</span> =&gt;  SubstitutionString</span>
                          <span class="pl-c"><span class="pl-c">#</span> =&gt;  Test.GenericString</span>

<span class="pl-c"><span class="pl-c">#</span> Every type has a super type; use the `supertype` function to get it.</span>
<span class="pl-c1">typeof</span>(<span class="pl-c1">5</span>) <span class="pl-c"><span class="pl-c">#</span> =&gt; Int64</span>
<span class="pl-c1">supertype</span>(Int64)    <span class="pl-c"><span class="pl-c">#</span> =&gt; Signed</span>
<span class="pl-c1">supertype</span>(Signed)   <span class="pl-c"><span class="pl-c">#</span> =&gt; Integer</span>
<span class="pl-c1">supertype</span>(Integer)  <span class="pl-c"><span class="pl-c">#</span> =&gt; Real</span>
<span class="pl-c1">supertype</span>(Real)     <span class="pl-c"><span class="pl-c">#</span> =&gt; Number</span>
<span class="pl-c1">supertype</span>(Number)   <span class="pl-c"><span class="pl-c">#</span> =&gt; Any</span>
<span class="pl-c1">supertype</span>(<span class="pl-c1">supertype</span>(Signed))  <span class="pl-c"><span class="pl-c">#</span> =&gt; Real</span>
<span class="pl-c1">supertype</span>(Any)      <span class="pl-c"><span class="pl-c">#</span> =&gt; Any</span>
<span class="pl-c"><span class="pl-c">#</span> All of these type, except for Int64, are abstract.</span>
<span class="pl-c1">typeof</span>(<span class="pl-s"><span class="pl-pds">"</span>fire<span class="pl-pds">"</span></span>)      <span class="pl-c"><span class="pl-c">#</span> =&gt; String</span>
<span class="pl-c1">supertype</span>(String)   <span class="pl-c"><span class="pl-c">#</span> =&gt; AbstractString</span>
<span class="pl-c"><span class="pl-c">#</span> Likewise here with String</span>
<span class="pl-c1">supertype</span>(SubString)  <span class="pl-c"><span class="pl-c">#</span> =&gt; AbstractString</span>

<span class="pl-c"><span class="pl-c">#</span> &lt;: is the subtyping operator</span>
<span class="pl-k">struct</span> Lion <span class="pl-k">&lt;:</span> <span class="pl-c1">Cat</span>  <span class="pl-c"><span class="pl-c">#</span> Lion is a subtype of Cat</span>
    maneColor
    roar<span class="pl-k">::</span><span class="pl-c1">AbstractString</span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> You can define more constructors for your type</span>
<span class="pl-c"><span class="pl-c">#</span> Just define a function of the same name as the type</span>
<span class="pl-c"><span class="pl-c">#</span> and call an existing constructor to get a value of the correct type</span>
<span class="pl-en">Lion</span>(roar<span class="pl-k">::</span><span class="pl-c1">AbstractString</span>) <span class="pl-k">=</span> <span class="pl-c1">Lion</span>(<span class="pl-s"><span class="pl-pds">"</span>green<span class="pl-pds">"</span></span>, roar)
<span class="pl-c"><span class="pl-c">#</span> This is an outer constructor because it's outside the type definition</span>

<span class="pl-k">struct</span> Panther <span class="pl-k">&lt;:</span> <span class="pl-c1">Cat</span>  <span class="pl-c"><span class="pl-c">#</span> Panther is also a subtype of Cat</span>
    eyeColor
    <span class="pl-en">Panther</span>() <span class="pl-k">=</span> <span class="pl-c1">new</span>(<span class="pl-s"><span class="pl-pds">"</span>green<span class="pl-pds">"</span></span>)
    <span class="pl-c"><span class="pl-c">#</span> Panthers will only have this constructor, and no default constructor.</span>
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> Using inner constructors, like Panther does, gives you control</span>
<span class="pl-c"><span class="pl-c">#</span> over how values of the type can be created.</span>
<span class="pl-c"><span class="pl-c">#</span> When possible, you should use outer constructors rather than inner ones.</span>

<span class="pl-c"><span class="pl-c">#</span>###################################################</span>
<span class="pl-c"><span class="pl-c">#</span># 6. Multiple-Dispatch</span>
<span class="pl-c"><span class="pl-c">#</span>###################################################</span>

<span class="pl-c"><span class="pl-c">#</span> In Julia, all named functions are generic functions</span>
<span class="pl-c"><span class="pl-c">#</span> This means that they are built up from many small methods</span>
<span class="pl-c"><span class="pl-c">#</span> Each constructor for Lion is a method of the generic function Lion.</span>

<span class="pl-c"><span class="pl-c">#</span> For a non-constructor example, let's make a function meow:</span>

<span class="pl-c"><span class="pl-c">#</span> Definitions for Lion, Panther, Tiger</span>
<span class="pl-k">function</span> <span class="pl-en">meow</span>(animal<span class="pl-k">::</span><span class="pl-c1">Lion</span>)
    animal<span class="pl-k">.</span>roar  <span class="pl-c"><span class="pl-c">#</span> access type properties using dot notation</span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">meow</span>(animal<span class="pl-k">::</span><span class="pl-c1">Panther</span>)
    <span class="pl-s"><span class="pl-pds">"</span>grrr<span class="pl-pds">"</span></span>
<span class="pl-k">end</span>

<span class="pl-k">function</span> <span class="pl-en">meow</span>(animal<span class="pl-k">::</span><span class="pl-c1">Tiger</span>)
    <span class="pl-s"><span class="pl-pds">"</span>rawwwr<span class="pl-pds">"</span></span>
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Testing the meow function</span>
<span class="pl-c1">meow</span>(tigger)  <span class="pl-c"><span class="pl-c">#</span> =&gt; "rawwwr"</span>
<span class="pl-c1">meow</span>(<span class="pl-c1">Lion</span>(<span class="pl-s"><span class="pl-pds">"</span>brown<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>ROAAR<span class="pl-pds">"</span></span>))  <span class="pl-c"><span class="pl-c">#</span> =&gt; "ROAAR"</span>
<span class="pl-c1">meow</span>(<span class="pl-c1">Panther</span>()) <span class="pl-c"><span class="pl-c">#</span> =&gt; "grrr"</span>

<span class="pl-c"><span class="pl-c">#</span> Review the local type hierarchy</span>
Tiger   <span class="pl-k">&lt;:</span> <span class="pl-c1">Cat</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; false</span>
Lion    <span class="pl-k">&lt;:</span> <span class="pl-c1">Cat</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>
Panther <span class="pl-k">&lt;:</span> <span class="pl-c1">Cat</span>  <span class="pl-c"><span class="pl-c">#</span> =&gt; true</span>

<span class="pl-c"><span class="pl-c">#</span> Defining a function that takes Cats</span>
<span class="pl-k">function</span> <span class="pl-en">pet_cat</span>(cat<span class="pl-k">::</span><span class="pl-c1">Cat</span>)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>The cat says <span class="pl-v">$(<span class="pl-c1">meow</span>(cat))</span><span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; pet_cat (generic function with 1 method)</span>

<span class="pl-c1">pet_cat</span>(<span class="pl-c1">Lion</span>(<span class="pl-s"><span class="pl-pds">"</span>42<span class="pl-pds">"</span></span>)) <span class="pl-c"><span class="pl-c">#</span> =&gt; The cat says 42</span>
<span class="pl-k">try</span>
    <span class="pl-c1">pet_cat</span>(tigger) <span class="pl-c"><span class="pl-c">#</span> =&gt; ERROR: MethodError: no method matching pet_cat(::Tiger)</span>
<span class="pl-k">catch</span> e
    <span class="pl-c1">println</span>(e)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> In OO languages, single dispatch is common;</span>
<span class="pl-c"><span class="pl-c">#</span> this means that the method is picked based on the type of the first argument.</span>
<span class="pl-c"><span class="pl-c">#</span> In Julia, all of the argument types contribute to selecting the best method.</span>

<span class="pl-c"><span class="pl-c">#</span> Let's define a function with more arguments, so we can see the difference</span>
<span class="pl-k">function</span> <span class="pl-en">fight</span>(t<span class="pl-k">::</span><span class="pl-c1">Tiger</span>, c<span class="pl-k">::</span><span class="pl-c1">Cat</span>)
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>The <span class="pl-v">$(t<span class="pl-k">.</span>coatcolor)</span> tiger wins!<span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> =&gt; fight (generic function with 1 method)</span>

<span class="pl-c1">fight</span>(tigger, <span class="pl-c1">Panther</span>())  <span class="pl-c"><span class="pl-c">#</span> =&gt; The orange tiger wins!</span>
<span class="pl-c1">fight</span>(tigger, <span class="pl-c1">Lion</span>(<span class="pl-s"><span class="pl-pds">"</span>ROAR<span class="pl-pds">"</span></span>)) <span class="pl-c"><span class="pl-c">#</span> =&gt; The orange tiger wins!</span>

<span class="pl-c"><span class="pl-c">#</span> Let's change the behavior when the Cat is specifically a Lion</span>
<span class="pl-en">fight</span>(t<span class="pl-k">::</span><span class="pl-c1">Tiger</span>, l<span class="pl-k">::</span><span class="pl-c1">Lion</span>) <span class="pl-k">=</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>The <span class="pl-v">$(l<span class="pl-k">.</span>maneColor)</span>-maned lion wins!<span class="pl-pds">"</span></span>)
<span class="pl-c"><span class="pl-c">#</span> =&gt; fight (generic function with 2 methods)</span>

<span class="pl-c1">fight</span>(tigger, <span class="pl-c1">Panther</span>())  <span class="pl-c"><span class="pl-c">#</span> =&gt; The orange tiger wins!</span>
<span class="pl-c1">fight</span>(tigger, <span class="pl-c1">Lion</span>(<span class="pl-s"><span class="pl-pds">"</span>ROAR<span class="pl-pds">"</span></span>)) <span class="pl-c"><span class="pl-c">#</span> =&gt; The green-maned lion wins!</span>

<span class="pl-c"><span class="pl-c">#</span> We don't need a Tiger in order to fight</span>
<span class="pl-en">fight</span>(l<span class="pl-k">::</span><span class="pl-c1">Lion</span>, c<span class="pl-k">::</span><span class="pl-c1">Cat</span>) <span class="pl-k">=</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>The victorious cat says <span class="pl-v">$(<span class="pl-c1">meow</span>(c))</span><span class="pl-pds">"</span></span>)
<span class="pl-c"><span class="pl-c">#</span> =&gt; fight (generic function with 3 methods)</span>

<span class="pl-c1">fight</span>(<span class="pl-c1">Lion</span>(<span class="pl-s"><span class="pl-pds">"</span>balooga!<span class="pl-pds">"</span></span>), <span class="pl-c1">Panther</span>())  <span class="pl-c"><span class="pl-c">#</span> =&gt; The victorious cat says grrr</span>
<span class="pl-k">try</span>
    <span class="pl-c1">fight</span>(<span class="pl-c1">Panther</span>(), <span class="pl-c1">Lion</span>(<span class="pl-s"><span class="pl-pds">"</span>RAWR<span class="pl-pds">"</span></span>))  
    <span class="pl-c"><span class="pl-c">#</span> =&gt; ERROR: MethodError: no method matching fight(::Panther, ::Lion)</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt; Closest candidates are:</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt;   fight(::Tiger, ::Lion) at ...</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt;   fight(::Tiger, ::Cat) at ...</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt;   fight(::Lion, ::Cat) at ...</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt; ...</span>
<span class="pl-k">catch</span> e
    <span class="pl-c1">println</span>(e)
<span class="pl-k">end</span>

<span class="pl-c"><span class="pl-c">#</span> Also let the cat go first</span>
<span class="pl-en">fight</span>(c<span class="pl-k">::</span><span class="pl-c1">Cat</span>, l<span class="pl-k">::</span><span class="pl-c1">Lion</span>) <span class="pl-k">=</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>The cat beats the Lion<span class="pl-pds">"</span></span>)
<span class="pl-c"><span class="pl-c">#</span> =&gt; fight (generic function with 4 methods)</span>

<span class="pl-c"><span class="pl-c">#</span> This warning is because it's unclear which fight will be called in:</span>
<span class="pl-k">try</span>
    <span class="pl-c1">fight</span>(<span class="pl-c1">Lion</span>(<span class="pl-s"><span class="pl-pds">"</span>RAR<span class="pl-pds">"</span></span>), <span class="pl-c1">Lion</span>(<span class="pl-s"><span class="pl-pds">"</span>brown<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>rarrr<span class="pl-pds">"</span></span>))
    <span class="pl-c"><span class="pl-c">#</span> =&gt; ERROR: MethodError: fight(::Lion, ::Lion) is ambiguous. Candidates:</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt;   fight(c::Cat, l::Lion) in Main at ...</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt;   fight(l::Lion, c::Cat) in Main at ...</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt; Possible fix, define</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt;   fight(::Lion, ::Lion)</span>
    <span class="pl-c"><span class="pl-c">#</span> =&gt; ...</span>
<span class="pl-k">catch</span> e
    <span class="pl-c1">println</span>(e)
<span class="pl-k">end</span>
<span class="pl-c"><span class="pl-c">#</span> The result may be different in other versions of Julia</span>

<span class="pl-en">fight</span>(l<span class="pl-k">::</span><span class="pl-c1">Lion</span>, l2<span class="pl-k">::</span><span class="pl-c1">Lion</span>) <span class="pl-k">=</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>The lions come to a tie<span class="pl-pds">"</span></span>) 
<span class="pl-c"><span class="pl-c">#</span> =&gt; fight (generic function with 5 methods)</span>
<span class="pl-c1">fight</span>(<span class="pl-c1">Lion</span>(<span class="pl-s"><span class="pl-pds">"</span>RAR<span class="pl-pds">"</span></span>), <span class="pl-c1">Lion</span>(<span class="pl-s"><span class="pl-pds">"</span>brown<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>rarrr<span class="pl-pds">"</span></span>))  <span class="pl-c"><span class="pl-c">#</span> =&gt; The lions come to a tie</span>


<span class="pl-c"><span class="pl-c">#</span> Under the hood</span>
<span class="pl-c"><span class="pl-c">#</span> You can take a look at the llvm  and the assembly code generated.</span>

<span class="pl-en">square_area</span>(l) <span class="pl-k">=</span> l <span class="pl-k">*</span> l  <span class="pl-c"><span class="pl-c">#</span> square_area (generic function with 1 method)</span>

<span class="pl-c1">square_area</span>(<span class="pl-c1">5</span>)  <span class="pl-c"><span class="pl-c">#</span> =&gt; 25</span>

<span class="pl-c"><span class="pl-c">#</span> What happens when we feed square_area an integer?</span>
<span class="pl-c1">code_native</span>(square_area, (Int32,), syntax <span class="pl-k">=</span> <span class="pl-c1">:intel</span>)
	<span class="pl-c"><span class="pl-c">#</span>         .text</span>
	<span class="pl-c"><span class="pl-c">#</span> ; Function square_area {</span>
	<span class="pl-c"><span class="pl-c">#</span> ; Location: REPL[116]:1       # Prologue</span>
	<span class="pl-c"><span class="pl-c">#</span>         push    rbp</span>
	<span class="pl-c"><span class="pl-c">#</span>         mov     rbp, rsp</span>
	<span class="pl-c"><span class="pl-c">#</span> ; Function *; {</span>
	<span class="pl-c"><span class="pl-c">#</span> ; Location: int.jl:54</span>
	<span class="pl-c"><span class="pl-c">#</span>         imul    ecx, ecx      # Square l and store the result in ECX</span>
	<span class="pl-c"><span class="pl-c">#</span> ;}</span>
	<span class="pl-c"><span class="pl-c">#</span>         mov     eax, ecx</span>
	<span class="pl-c"><span class="pl-c">#</span>         pop     rbp           # Restore old base pointer</span>
	<span class="pl-c"><span class="pl-c">#</span>         ret                   # Result will still be in EAX</span>
	<span class="pl-c"><span class="pl-c">#</span>         nop     dword ptr [rax + rax]</span>
	<span class="pl-c"><span class="pl-c">#</span> ;}</span>

<span class="pl-c1">code_native</span>(square_area, (Float32,), syntax <span class="pl-k">=</span> <span class="pl-c1">:intel</span>)
    <span class="pl-c"><span class="pl-c">#</span>         .text</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function square_area {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: REPL[116]:1</span>
    <span class="pl-c"><span class="pl-c">#</span>         push    rbp</span>
    <span class="pl-c"><span class="pl-c">#</span>         mov     rbp, rsp</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function *; {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: float.jl:398</span>
    <span class="pl-c"><span class="pl-c">#</span>         vmulss  xmm0, xmm0, xmm0  # Scalar single precision multiply (AVX)</span>
    <span class="pl-c"><span class="pl-c">#</span> ;}</span>
    <span class="pl-c"><span class="pl-c">#</span>         pop     rbp</span>
    <span class="pl-c"><span class="pl-c">#</span>         ret</span>
    <span class="pl-c"><span class="pl-c">#</span>         nop     word ptr [rax + rax]</span>
    <span class="pl-c"><span class="pl-c">#</span> ;}</span>

<span class="pl-c1">code_native</span>(square_area, (Float64,), syntax <span class="pl-k">=</span> <span class="pl-c1">:intel</span>)
    <span class="pl-c"><span class="pl-c">#</span>         .text</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function square_area {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: REPL[116]:1</span>
    <span class="pl-c"><span class="pl-c">#</span>         push    rbp</span>
    <span class="pl-c"><span class="pl-c">#</span>         mov     rbp, rsp</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function *; {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: float.jl:399</span>
    <span class="pl-c"><span class="pl-c">#</span>         vmulsd  xmm0, xmm0, xmm0  # Scalar double precision multiply (AVX)</span>
    <span class="pl-c"><span class="pl-c">#</span> ;}</span>
    <span class="pl-c"><span class="pl-c">#</span>         pop     rbp</span>
    <span class="pl-c"><span class="pl-c">#</span>         ret</span>
    <span class="pl-c"><span class="pl-c">#</span>         nop     word ptr [rax + rax]</span>
    <span class="pl-c"><span class="pl-c">#</span> ;}</span>

<span class="pl-c"><span class="pl-c">#</span> Note that julia will use floating point instructions if any of the</span>
<span class="pl-c"><span class="pl-c">#</span> arguments are floats.</span>
<span class="pl-c"><span class="pl-c">#</span> Let's calculate the area of a circle</span>
<span class="pl-en">circle_area</span>(r) <span class="pl-k">=</span> <span class="pl-c1">pi</span> <span class="pl-k">*</span> r <span class="pl-k">*</span> r     <span class="pl-c"><span class="pl-c">#</span> circle_area (generic function with 1 method)</span>
<span class="pl-c1">circle_area</span>(<span class="pl-c1">5</span>)  <span class="pl-c"><span class="pl-c">#</span> 78.53981633974483</span>

<span class="pl-c1">code_native</span>(circle_area, (Int32,), syntax <span class="pl-k">=</span> <span class="pl-c1">:intel</span>)
    <span class="pl-c"><span class="pl-c">#</span>         .text</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function circle_area {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: REPL[121]:1</span>
    <span class="pl-c"><span class="pl-c">#</span>         push    rbp</span>
    <span class="pl-c"><span class="pl-c">#</span>         mov     rbp, rsp</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function *; {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: operators.jl:502</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function *; {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: promotion.jl:314</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function promote; {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: promotion.jl:284</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function _promote; {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: promotion.jl:261</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function convert; {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: number.jl:7</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function Type; {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: float.jl:60</span>
    <span class="pl-c"><span class="pl-c">#</span>         vcvtsi2sd       xmm0, xmm0, ecx     # Load integer (r) from memory</span>
    <span class="pl-c"><span class="pl-c">#</span>         movabs  rax, 497710928              # Load pi</span>
    <span class="pl-c"><span class="pl-c">#</span> ;}}}}}</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function *; {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: float.jl:399</span>
    <span class="pl-c"><span class="pl-c">#</span>         vmulsd  xmm1, xmm0, qword ptr [rax] # pi * r</span>
    <span class="pl-c"><span class="pl-c">#</span>         vmulsd  xmm0, xmm1, xmm0            # (pi * r) * r</span>
    <span class="pl-c"><span class="pl-c">#</span> ;}}</span>
    <span class="pl-c"><span class="pl-c">#</span>         pop     rbp</span>
    <span class="pl-c"><span class="pl-c">#</span>         ret</span>
    <span class="pl-c"><span class="pl-c">#</span>         nop     dword ptr [rax]</span>
    <span class="pl-c"><span class="pl-c">#</span> ;}</span>

<span class="pl-c1">code_native</span>(circle_area, (Float64,), syntax <span class="pl-k">=</span> <span class="pl-c1">:intel</span>)
    <span class="pl-c"><span class="pl-c">#</span>         .text</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function circle_area {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: REPL[121]:1</span>
    <span class="pl-c"><span class="pl-c">#</span>         push    rbp</span>
    <span class="pl-c"><span class="pl-c">#</span>         mov     rbp, rsp</span>
    <span class="pl-c"><span class="pl-c">#</span>         movabs  rax, 497711048</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function *; {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: operators.jl:502</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function *; {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: promotion.jl:314</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function *; {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: float.jl:399</span>
    <span class="pl-c"><span class="pl-c">#</span>         vmulsd  xmm1, xmm0, qword ptr [rax]</span>
    <span class="pl-c"><span class="pl-c">#</span> ;}}}</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Function *; {</span>
    <span class="pl-c"><span class="pl-c">#</span> ; Location: float.jl:399</span>
    <span class="pl-c"><span class="pl-c">#</span>         vmulsd  xmm0, xmm1, xmm0</span>
    <span class="pl-c"><span class="pl-c">#</span> ;}</span>
    <span class="pl-c"><span class="pl-c">#</span>         pop     rbp</span>
    <span class="pl-c"><span class="pl-c">#</span>         ret</span>
    <span class="pl-c"><span class="pl-c">#</span>         nop     dword ptr [rax + rax]</span>
    <span class="pl-c"><span class="pl-c">#</span> ;}</span></pre></div>
<h2>Further Reading</h2>
<p>You can get a lot more detail from the <a href="https://docs.julialang.org/" rel="nofollow">Julia Documentation</a></p>
<p>The best place to get help with Julia is the (very friendly) <a href="https://discourse.julialang.org/" rel="nofollow">Discourse forum</a>.</p>
<hr>
<h2>Contributors</h2>
<pre class="notranslate"><code class="notranslate">- ["Leah Hanson", "http://leahhanson.us"]
- ["Pranit Bauva", "https://github.com/pranitbauva1997"]
- ["Daniel YC Lin", "https://github.com/dlintw"]
</code></pre>