<h1>Kotlin</h1>
<p>Kotlin is a statically typed programming language for the JVM, Android and the<br>
browser. It is 100% interoperable with Java.<br>
<a href="https://kotlinlang.org/" rel="nofollow">Read more here.</a></p>
<div class="highlight highlight-source-kotlin"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span> Single-line comments start with //</span>
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">Multi-line comments look like this.</span>
<span class="pl-c"><span class="pl-c">*/</span></span>

<span class="pl-c"><span class="pl-c">//</span> The "package" keyword works in the same way as in Java.</span>
<span class="pl-k">package</span> <span class="pl-en">com.learnxinyminutes.kotlin</span>

<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">The entry point to a Kotlin program is a function named "main".</span>
<span class="pl-c">The function is passed an array containing any command-line arguments.</span>
<span class="pl-c">Since Kotlin 1.3 the "main" function can also be defined without</span>
<span class="pl-c">any parameters.</span>
<span class="pl-c"><span class="pl-c">*/</span></span>
<span class="pl-k">fun</span> <span class="pl-en">main</span>(<span class="pl-smi">args</span><span class="pl-k">:</span> <span class="pl-c1">Array</span>&lt;<span class="pl-en">String</span>&gt;) {
    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    Declaring values is done using either "var" or "val".</span>
<span class="pl-c">    "val" declarations cannot be reassigned, whereas "vars" can.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">val</span> fooVal <span class="pl-k">=</span> <span class="pl-c1">10</span> <span class="pl-c"><span class="pl-c">//</span> we cannot later reassign fooVal to something else</span>
    <span class="pl-k">var</span> fooVar <span class="pl-k">=</span> <span class="pl-c1">10</span>
    fooVar <span class="pl-k">=</span> <span class="pl-c1">20</span> <span class="pl-c"><span class="pl-c">//</span> fooVar can be reassigned</span>

    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    In most cases, Kotlin can determine what the type of a variable is,</span>
<span class="pl-c">    so we don't have to explicitly specify it every time.</span>
<span class="pl-c">    We can explicitly declare the type of a variable like so:</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">val</span> foo<span class="pl-k">:</span> <span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">7</span>

    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    Strings can be represented in a similar way as in Java.</span>
<span class="pl-c">    Escaping is done with a backslash.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">val</span> fooString <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>My String Is Here!<span class="pl-pds">"</span></span>
    <span class="pl-k">val</span> barString <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Printing on a new line?<span class="pl-cce">\n</span>No Problem!<span class="pl-pds">"</span></span>
    <span class="pl-k">val</span> bazString <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Do you want to add a tab?<span class="pl-cce">\t</span>No Problem!<span class="pl-pds">"</span></span>
    <span class="pl-c1">println</span>(fooString)
    <span class="pl-c1">println</span>(barString)
    <span class="pl-c1">println</span>(bazString)

    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    A raw string is delimited by a triple quote (""").</span>
<span class="pl-c">    Raw strings can contain newlines and any other characters.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">val</span> fooRawString <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">fun helloWorld(val name : String) {</span>
<span class="pl-s">   println("Hello, world!")</span>
<span class="pl-s">}</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
    <span class="pl-c1">println</span>(fooRawString)

    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    Strings can contain template expressions.</span>
<span class="pl-c">    A template expression starts with a dollar sign ($).</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">val</span> fooTemplateString <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-e">$fooString</span> has <span class="pl-e">${fooString.length}</span> characters<span class="pl-pds">"</span></span>
    <span class="pl-c1">println</span>(fooTemplateString) <span class="pl-c"><span class="pl-c">//</span> =&gt; My String Is Here! has 18 characters</span>

    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    For a variable to hold null it must be explicitly specified as nullable.</span>
<span class="pl-c">    A variable can be specified as nullable by appending a ? to its type.</span>
<span class="pl-c">    We can access a nullable variable by using the ?. operator.</span>
<span class="pl-c">    We can use the ?: operator to specify an alternative value to use</span>
<span class="pl-c">    if a variable is null.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">var</span> fooNullable<span class="pl-k">:</span> <span class="pl-c1">String?</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>
    <span class="pl-c1">println</span>(fooNullable?.length) <span class="pl-c"><span class="pl-c">//</span> =&gt; 3</span>
    <span class="pl-c1">println</span>(fooNullable?.length <span class="pl-k">?</span><span class="pl-k">:</span> <span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">//</span> =&gt; 3</span>
    fooNullable <span class="pl-k">=</span> <span class="pl-c1">null</span>
    <span class="pl-c1">println</span>(fooNullable?.length) <span class="pl-c"><span class="pl-c">//</span> =&gt; null</span>
    <span class="pl-c1">println</span>(fooNullable?.length <span class="pl-k">?</span><span class="pl-k">:</span> <span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">//</span> =&gt; -1</span>

    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    Functions can be declared using the "fun" keyword.</span>
<span class="pl-c">    Function arguments are specified in brackets after the function name.</span>
<span class="pl-c">    Function arguments can optionally have a default value.</span>
<span class="pl-c">    The function return type, if required, is specified after the arguments.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">fun</span> <span class="pl-en">hello</span>(<span class="pl-smi">name</span><span class="pl-k">:</span> <span class="pl-c1">String</span> = "world"): <span class="pl-c1">String</span> {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Hello, <span class="pl-e">$name</span>!<span class="pl-pds">"</span></span>
    }
    <span class="pl-c1">println</span>(hello(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; Hello, foo!</span>
    <span class="pl-c1">println</span>(hello(name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; Hello, bar!</span>
    <span class="pl-c1">println</span>(hello()) <span class="pl-c"><span class="pl-c">//</span> =&gt; Hello, world!</span>

    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    A function parameter may be marked with the "vararg" keyword</span>
<span class="pl-c">    to allow a variable number of arguments to be passed to the function.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">fun</span> <span class="pl-en">varargExample</span>(<span class="pl-k">vararg</span> <span class="pl-smi">names</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>) {
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Argument has <span class="pl-e">${names.size}</span> elements<span class="pl-pds">"</span></span>)
    }
    varargExample() <span class="pl-c"><span class="pl-c">//</span> =&gt; Argument has 0 elements</span>
    varargExample(<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">//</span> =&gt; Argument has 1 elements</span>
    varargExample(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">//</span> =&gt; Argument has 3 elements</span>

    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    When a function consists of a single expression then the curly brackets can</span>
<span class="pl-c">    be omitted. The body is specified after the = symbol.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">fun</span> <span class="pl-en">odd</span>(<span class="pl-smi">x</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>): <span class="pl-c1">Boolean</span> <span class="pl-k">=</span> x <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">1</span>
    <span class="pl-c1">println</span>(odd(<span class="pl-c1">6</span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; false</span>
    <span class="pl-c1">println</span>(odd(<span class="pl-c1">7</span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; true</span>

    <span class="pl-c"><span class="pl-c">//</span> If the return type can be inferred then we don't need to specify it.</span>
    <span class="pl-k">fun</span> <span class="pl-en">even</span>(<span class="pl-smi">x</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>) <span class="pl-k">=</span> x <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
    <span class="pl-c1">println</span>(even(<span class="pl-c1">6</span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; true</span>
    <span class="pl-c1">println</span>(even(<span class="pl-c1">7</span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; false</span>

    <span class="pl-c"><span class="pl-c">//</span> Functions can take functions as arguments and return functions.</span>
    <span class="pl-k">fun</span> <span class="pl-en">not</span>(<span class="pl-smi">f</span><span class="pl-k">:</span> (<span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Boolean</span>): (<span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Boolean</span> {
        <span class="pl-k">return</span> {n <span class="pl-k">-&gt;</span> <span class="pl-k">!</span>f.invoke(n)}
    }
    <span class="pl-c"><span class="pl-c">//</span> Named functions can be specified as arguments using the :: operator.</span>
    <span class="pl-k">val</span> notOdd <span class="pl-k">=</span> <span class="pl-k">not</span>(::odd)
    <span class="pl-k">val</span> notEven <span class="pl-k">=</span> <span class="pl-k">not</span>(::even)
    <span class="pl-c"><span class="pl-c">//</span> Lambda expressions can be specified as arguments.</span>
    <span class="pl-k">val</span> notZero <span class="pl-k">=</span> <span class="pl-k">not</span> {n <span class="pl-k">-&gt;</span> n <span class="pl-k">==</span> <span class="pl-c1">0</span>}
    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    If a lambda has only one parameter</span>
<span class="pl-c">    then its declaration can be omitted (along with the -&gt;).</span>
<span class="pl-c">    The name of the single parameter will be "it".</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">val</span> notPositive <span class="pl-k">=</span> <span class="pl-k">not</span> {it <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>}
    <span class="pl-k">for</span> (i <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">..</span><span class="pl-c1">4</span>) {
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-e">${notOdd(i)}</span> <span class="pl-e">${notEven(i)}</span> <span class="pl-e">${notZero(i)}</span> <span class="pl-e">${notPositive(i)}</span><span class="pl-pds">"</span></span>)
    }

    <span class="pl-c"><span class="pl-c">//</span> The "class" keyword is used to declare classes.</span>
    <span class="pl-k">class</span> <span class="pl-en">ExampleClass</span>(<span class="pl-k">val</span> <span class="pl-smi">x</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>) {
        <span class="pl-k">fun</span> <span class="pl-en">memberFunction</span>(<span class="pl-smi">y</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>): <span class="pl-c1">Int</span> {
            <span class="pl-k">return</span> x <span class="pl-k">+</span> y
        }

        <span class="pl-k">infix</span> <span class="pl-k">fun</span> <span class="pl-en">infixMemberFunction</span>(<span class="pl-smi">y</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>): <span class="pl-c1">Int</span> {
            <span class="pl-k">return</span> x <span class="pl-k">*</span> y
        }
    }
    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    To create a new instance we call the constructor.</span>
<span class="pl-c">    Note that Kotlin does not have a "new" keyword.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">val</span> fooExampleClass <span class="pl-k">=</span> <span class="pl-en">ExampleClass</span>(<span class="pl-c1">7</span>)
    <span class="pl-c"><span class="pl-c">//</span> Member functions can be called using dot notation.</span>
    <span class="pl-c1">println</span>(fooExampleClass.memberFunction(<span class="pl-c1">4</span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; 11</span>
    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    If a function has been marked with the "infix" keyword then it can be</span>
<span class="pl-c">    called using infix notation.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-c1">println</span>(fooExampleClass infixMemberFunction <span class="pl-c1">4</span>) <span class="pl-c"><span class="pl-c">//</span> =&gt; 28</span>

    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    Data classes are a concise way to create classes that just hold data.</span>
<span class="pl-c">    The "hashCode"/"equals" and "toString" methods are automatically generated.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">data class</span> <span class="pl-en">DataClassExample</span> (<span class="pl-k">val</span> <span class="pl-smi">x</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>, <span class="pl-k">val</span> <span class="pl-smi">y</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>, <span class="pl-k">val</span> <span class="pl-smi">z</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>)
    <span class="pl-k">val</span> fooData <span class="pl-k">=</span> <span class="pl-en">DataClassExample</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">4</span>)
    <span class="pl-c1">println</span>(fooData) <span class="pl-c"><span class="pl-c">//</span> =&gt; DataClassExample(x=1, y=2, z=4)</span>

    <span class="pl-c"><span class="pl-c">//</span> Data classes have a "copy" function.</span>
    <span class="pl-k">val</span> fooCopy <span class="pl-k">=</span> fooData.copy(y <span class="pl-k">=</span> <span class="pl-c1">100</span>)
    <span class="pl-c1">println</span>(fooCopy) <span class="pl-c"><span class="pl-c">//</span> =&gt; DataClassExample(x=1, y=100, z=4)</span>

    <span class="pl-c"><span class="pl-c">//</span> Objects can be destructured into multiple variables.</span>
    <span class="pl-k">val</span> (a, b, c) <span class="pl-k">=</span> fooCopy
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-e">$a</span> <span class="pl-e">$b</span> <span class="pl-e">$c</span><span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> =&gt; 1 100 4</span>

    <span class="pl-c"><span class="pl-c">//</span> destructuring in "for" loop</span>
    <span class="pl-k">for</span> ((a, b, c) <span class="pl-k">in</span> <span class="pl-c1">listOf</span>(fooData)) {
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-e">$a</span> <span class="pl-e">$b</span> <span class="pl-e">$c</span><span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> =&gt; 1 2 4</span>
    }

    <span class="pl-k">val</span> mapData <span class="pl-k">=</span> <span class="pl-c1">mapOf</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> to <span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> to <span class="pl-c1">2</span>)
    <span class="pl-c"><span class="pl-c">//</span> Map.Entry is destructurable as well</span>
    <span class="pl-k">for</span> ((key, value) <span class="pl-k">in</span> mapData) {
        <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-e">$key</span> -&gt; <span class="pl-e">$value</span><span class="pl-pds">"</span></span>)
    }

    <span class="pl-c"><span class="pl-c">//</span> The "with" function is similar to the JavaScript "with" statement.</span>
    <span class="pl-k">data class</span> <span class="pl-en">MutableDataClassExample</span> (<span class="pl-k">var</span> <span class="pl-smi">x</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>, <span class="pl-k">var</span> <span class="pl-smi">y</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>, <span class="pl-k">var</span> <span class="pl-smi">z</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>)
    <span class="pl-k">val</span> fooMutableData <span class="pl-k">=</span> <span class="pl-en">MutableDataClassExample</span>(<span class="pl-c1">7</span>, <span class="pl-c1">4</span>, <span class="pl-c1">9</span>)
    <span class="pl-c1">with</span> (fooMutableData) {
        x <span class="pl-k">-</span><span class="pl-k">=</span> <span class="pl-c1">2</span>
        y <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">2</span>
        z<span class="pl-k">--</span>
    }
    <span class="pl-c1">println</span>(fooMutableData) <span class="pl-c"><span class="pl-c">//</span> =&gt; MutableDataClassExample(x=5, y=6, z=8)</span>

    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    We can create a list using the "listOf" function.</span>
<span class="pl-c">    The list will be immutable - elements cannot be added or removed.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">val</span> fooList <span class="pl-k">=</span> <span class="pl-c1">listOf</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>)
    <span class="pl-c1">println</span>(fooList.size) <span class="pl-c"><span class="pl-c">//</span> =&gt; 3</span>
    <span class="pl-c1">println</span>(fooList.first()) <span class="pl-c"><span class="pl-c">//</span> =&gt; a</span>
    <span class="pl-c1">println</span>(fooList.last()) <span class="pl-c"><span class="pl-c">//</span> =&gt; c</span>
    <span class="pl-c"><span class="pl-c">//</span> Elements of a list can be accessed by their index.</span>
    <span class="pl-c1">println</span>(fooList[<span class="pl-c1">1</span>]) <span class="pl-c"><span class="pl-c">//</span> =&gt; b</span>

    <span class="pl-c"><span class="pl-c">//</span> A mutable list can be created using the "mutableListOf" function.</span>
    <span class="pl-k">val</span> fooMutableList <span class="pl-k">=</span> <span class="pl-c1">mutableListOf</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>)
    fooMutableList.add(<span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>)
    <span class="pl-c1">println</span>(fooMutableList.last()) <span class="pl-c"><span class="pl-c">//</span> =&gt; d</span>
    <span class="pl-c1">println</span>(fooMutableList.size) <span class="pl-c"><span class="pl-c">//</span> =&gt; 4</span>

    <span class="pl-c"><span class="pl-c">//</span> We can create a set using the "setOf" function.</span>
    <span class="pl-k">val</span> fooSet <span class="pl-k">=</span> <span class="pl-c1">setOf</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>)
    <span class="pl-c1">println</span>(fooSet.contains(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; true</span>
    <span class="pl-c1">println</span>(fooSet.contains(<span class="pl-s"><span class="pl-pds">"</span>z<span class="pl-pds">"</span></span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; false</span>

    <span class="pl-c"><span class="pl-c">//</span> We can create a map using the "mapOf" function.</span>
    <span class="pl-k">val</span> fooMap <span class="pl-k">=</span> <span class="pl-c1">mapOf</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> to <span class="pl-c1">8</span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> to <span class="pl-c1">7</span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> to <span class="pl-c1">9</span>)
    <span class="pl-c"><span class="pl-c">//</span> Map values can be accessed by their key.</span>
    <span class="pl-c1">println</span>(fooMap[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>]) <span class="pl-c"><span class="pl-c">//</span> =&gt; 8</span>

    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    Sequences represent lazily-evaluated collections.</span>
<span class="pl-c">    We can create a sequence using the "generateSequence" function.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">val</span> fooSequence <span class="pl-k">=</span> generateSequence(<span class="pl-c1">1</span>, { it <span class="pl-k">+</span> <span class="pl-c1">1</span> })
    <span class="pl-k">val</span> x <span class="pl-k">=</span> fooSequence.take(<span class="pl-c1">10</span>).toList()
    <span class="pl-c1">println</span>(x) <span class="pl-c"><span class="pl-c">//</span> =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>

    <span class="pl-c"><span class="pl-c">//</span> An example of using a sequence to generate Fibonacci numbers:</span>
    <span class="pl-k">fun</span> <span class="pl-en">fibonacciSequence</span>(): <span class="pl-en">Sequence</span>&lt;<span class="pl-en">Long</span>&gt; {
        <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">0L</span>
        <span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">1L</span>

        <span class="pl-k">fun</span> <span class="pl-en">next</span>(): <span class="pl-c1">Long</span> {
            <span class="pl-k">val</span> result <span class="pl-k">=</span> a <span class="pl-k">+</span> b
            a <span class="pl-k">=</span> b
            b <span class="pl-k">=</span> result
            <span class="pl-k">return</span> a
        }

        <span class="pl-k">return</span> generateSequence(::next)
    }
    <span class="pl-k">val</span> y <span class="pl-k">=</span> fibonacciSequence().take(<span class="pl-c1">10</span>).toList()
    <span class="pl-c1">println</span>(y) <span class="pl-c"><span class="pl-c">//</span> =&gt; [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span>

    <span class="pl-c"><span class="pl-c">//</span> Kotlin provides higher-order functions for working with collections.</span>
    <span class="pl-k">val</span> z <span class="pl-k">=</span> (<span class="pl-c1">1</span><span class="pl-k">..</span><span class="pl-c1">9</span>).map {it <span class="pl-k">*</span> <span class="pl-c1">3</span>}
                  .filter {it <span class="pl-k">&lt;</span> <span class="pl-c1">20</span>}
                  .groupBy {it <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>}
                  .mapKeys {<span class="pl-k">if</span> (it.key) <span class="pl-s"><span class="pl-pds">"</span>even<span class="pl-pds">"</span></span> <span class="pl-k">else</span> <span class="pl-s"><span class="pl-pds">"</span>odd<span class="pl-pds">"</span></span>}
    <span class="pl-c1">println</span>(z) <span class="pl-c"><span class="pl-c">//</span> =&gt; {odd=[3, 9, 15], even=[6, 12, 18]}</span>

    <span class="pl-c"><span class="pl-c">//</span> A "for" loop can be used with anything that provides an iterator.</span>
    <span class="pl-k">for</span> (c <span class="pl-k">in</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) {
        <span class="pl-c1">println</span>(c)
    }

    <span class="pl-c"><span class="pl-c">//</span> "while" loops work in the same way as other languages.</span>
    <span class="pl-k">var</span> ctr <span class="pl-k">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">while</span> (ctr <span class="pl-k">&lt;</span> <span class="pl-c1">5</span>) {
        <span class="pl-c1">println</span>(ctr)
        ctr<span class="pl-k">++</span>
    }
    <span class="pl-k">do</span> {
        <span class="pl-c1">println</span>(ctr)
        ctr<span class="pl-k">++</span>
    } <span class="pl-k">while</span> (ctr <span class="pl-k">&lt;</span> <span class="pl-c1">10</span>)

    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    "if" can be used as an expression that returns a value.</span>
<span class="pl-c">    For this reason the ternary ?: operator is not needed in Kotlin.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">val</span> num <span class="pl-k">=</span> <span class="pl-c1">5</span>
    <span class="pl-k">val</span> message <span class="pl-k">=</span> <span class="pl-k">if</span> (num <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-s"><span class="pl-pds">"</span>even<span class="pl-pds">"</span></span> <span class="pl-k">else</span> <span class="pl-s"><span class="pl-pds">"</span>odd<span class="pl-pds">"</span></span>
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-e">$num</span> is <span class="pl-e">$message</span><span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> =&gt; 5 is odd</span>

    <span class="pl-c"><span class="pl-c">//</span> "when" can be used as an alternative to "if-else if" chains.</span>
    <span class="pl-k">val</span> i <span class="pl-k">=</span> <span class="pl-c1">10</span>
    <span class="pl-k">when</span> {
        i <span class="pl-k">&lt;</span> <span class="pl-c1">7</span> <span class="pl-k">-&gt;</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>first block<span class="pl-pds">"</span></span>)
        fooString.startsWith(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>second block<span class="pl-pds">"</span></span>)
        <span class="pl-k">else</span> <span class="pl-k">-&gt;</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>else block<span class="pl-pds">"</span></span>)
    }

    <span class="pl-c"><span class="pl-c">//</span> "when" can be used with an argument.</span>
    <span class="pl-k">when</span> (i) {
        <span class="pl-c1">0</span>, <span class="pl-c1">21</span> <span class="pl-k">-&gt;</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>0 or 21<span class="pl-pds">"</span></span>)
        <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">..</span><span class="pl-c1">20</span> <span class="pl-k">-&gt;</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>in the range 1 to 20<span class="pl-pds">"</span></span>)
        <span class="pl-k">else</span> <span class="pl-k">-&gt;</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>none of the above<span class="pl-pds">"</span></span>)
    }

    <span class="pl-c"><span class="pl-c">//</span> "when" can be used as a function that returns a value.</span>
    <span class="pl-k">var</span> result <span class="pl-k">=</span> <span class="pl-k">when</span> (i) {
        <span class="pl-c1">0</span>, <span class="pl-c1">21</span> <span class="pl-k">-&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>0 or 21<span class="pl-pds">"</span></span>
        <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">..</span><span class="pl-c1">20</span> <span class="pl-k">-&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>in the range 1 to 20<span class="pl-pds">"</span></span>
        <span class="pl-k">else</span> <span class="pl-k">-&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>none of the above<span class="pl-pds">"</span></span>
    }
    <span class="pl-c1">println</span>(result)

    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    We can check if an object is of a particular type by using the "is" operator.</span>
<span class="pl-c">    If an object passes a type check then it can be used as that type without</span>
<span class="pl-c">    explicitly casting it.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">fun</span> <span class="pl-en">smartCastExample</span>(<span class="pl-smi">x</span><span class="pl-k">:</span> <span class="pl-c1">Any</span>) : <span class="pl-c1">Boolean</span> {
        <span class="pl-k">if</span> (x <span class="pl-k">is</span> <span class="pl-c1">Boolean</span>) {
            <span class="pl-c"><span class="pl-c">//</span> x is automatically cast to Boolean</span>
            <span class="pl-k">return</span> x
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (x <span class="pl-k">is</span> <span class="pl-c1">Int</span>) {
            <span class="pl-c"><span class="pl-c">//</span> x is automatically cast to Int</span>
            <span class="pl-k">return</span> x <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (x <span class="pl-k">is</span> <span class="pl-c1">String</span>) {
            <span class="pl-c"><span class="pl-c">//</span> x is automatically cast to String</span>
            <span class="pl-k">return</span> x.isNotEmpty()
        } <span class="pl-k">else</span> {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>
        }
    }
    <span class="pl-c1">println</span>(smartCastExample(<span class="pl-s"><span class="pl-pds">"</span>Hello, world!<span class="pl-pds">"</span></span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; true</span>
    <span class="pl-c1">println</span>(smartCastExample(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; false</span>
    <span class="pl-c1">println</span>(smartCastExample(<span class="pl-c1">5</span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; true</span>
    <span class="pl-c1">println</span>(smartCastExample(<span class="pl-c1">0</span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; false</span>
    <span class="pl-c1">println</span>(smartCastExample(<span class="pl-c1">true</span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; true</span>

    <span class="pl-c"><span class="pl-c">//</span> Smartcast also works with when block</span>
    <span class="pl-k">fun</span> <span class="pl-en">smartCastWhenExample</span>(<span class="pl-smi">x</span><span class="pl-k">:</span> <span class="pl-c1">Any</span>) <span class="pl-k">=</span> <span class="pl-k">when</span> (x) {
        <span class="pl-k">is</span> <span class="pl-c1">Boolean</span> <span class="pl-k">-&gt;</span> x
        <span class="pl-k">is</span> <span class="pl-c1">Int</span> <span class="pl-k">-&gt;</span> x <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>
        <span class="pl-k">is</span> <span class="pl-c1">String</span> <span class="pl-k">-&gt;</span> x.isNotEmpty()
        <span class="pl-k">else</span> <span class="pl-k">-&gt;</span> <span class="pl-c1">false</span>
    }

    <span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">    Extensions are a way to add new functionality to a class.</span>
<span class="pl-c">    This is similar to C# extension methods.</span>
<span class="pl-c">    <span class="pl-c">*/</span></span>
    <span class="pl-k">fun</span> String.<span class="pl-en">remove</span>(<span class="pl-smi">c</span><span class="pl-k">:</span> <span class="pl-c1">Char</span>): <span class="pl-c1">String</span> {
        <span class="pl-k">return</span> <span class="pl-c1">this</span>.filter {it <span class="pl-k">!=</span> c}
    }
    <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>Hello, world!<span class="pl-pds">"</span></span>.remove(<span class="pl-s"><span class="pl-pds">'</span>l<span class="pl-pds">'</span></span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; Heo, word!</span>
}

<span class="pl-c"><span class="pl-c">//</span> Enum classes are similar to Java enum types.</span>
<span class="pl-k">enum</span> <span class="pl-k">class</span> <span class="pl-en">EnumExample</span> {
    <span class="pl-en">A</span>, <span class="pl-en">B</span>, <span class="pl-en">C</span> <span class="pl-c"><span class="pl-c">//</span> Enum constants are separated with commas.</span>
}
<span class="pl-k">fun</span> <span class="pl-en">printEnum</span>() <span class="pl-k">=</span> <span class="pl-c1">println</span>(<span class="pl-en">EnumExample</span>.<span class="pl-en">A</span>) <span class="pl-c"><span class="pl-c">//</span> =&gt; A</span>

<span class="pl-c"><span class="pl-c">//</span> Since each enum is an instance of the enum class, they can be initialized as:</span>
<span class="pl-k">enum</span> <span class="pl-k">class</span> <span class="pl-en">EnumExample</span>(<span class="pl-k">val</span> <span class="pl-smi">value</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>) {
    <span class="pl-en">A</span>(value <span class="pl-k">=</span> <span class="pl-c1">1</span>),
    <span class="pl-en">B</span>(value <span class="pl-k">=</span> <span class="pl-c1">2</span>),
    <span class="pl-en">C</span>(value <span class="pl-k">=</span> <span class="pl-c1">3</span>)
}
<span class="pl-k">fun</span> <span class="pl-en">printProperty</span>() <span class="pl-k">=</span> <span class="pl-c1">println</span>(<span class="pl-en">EnumExample</span>.<span class="pl-en">A</span>.value) <span class="pl-c"><span class="pl-c">//</span> =&gt; 1</span>

<span class="pl-c"><span class="pl-c">//</span> Every enum has properties to obtain its name and ordinal(position) in the enum class declaration:</span>
<span class="pl-k">fun</span> <span class="pl-en">printName</span>() <span class="pl-k">=</span> <span class="pl-c1">println</span>(<span class="pl-en">EnumExample</span>.<span class="pl-en">A</span>.name) <span class="pl-c"><span class="pl-c">//</span> =&gt; A</span>
<span class="pl-k">fun</span> <span class="pl-en">printPosition</span>() <span class="pl-k">=</span> <span class="pl-c1">println</span>(<span class="pl-en">EnumExample</span>.<span class="pl-en">A</span>.ordinal) <span class="pl-c"><span class="pl-c">//</span> =&gt; 0</span>

<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">The "object" keyword can be used to create singleton objects.</span>
<span class="pl-c">We cannot instantiate it but we can refer to its unique instance by its name.</span>
<span class="pl-c">This is similar to Scala singleton objects.</span>
<span class="pl-c"><span class="pl-c">*/</span></span>
<span class="pl-k">object</span> <span class="pl-en">ObjectExample</span> {
    <span class="pl-k">fun</span> <span class="pl-en">hello</span>(): <span class="pl-c1">String</span> {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>
    }

    <span class="pl-k">override</span> <span class="pl-k">fun</span> <span class="pl-en">toString</span>(): <span class="pl-c1">String</span> {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Hello, it's me, <span class="pl-e">${<span class="pl-en">ObjectExample</span>::<span class="pl-c1">class</span>.simpleName}</span><span class="pl-pds">"</span></span>
    }
}


<span class="pl-k">fun</span> <span class="pl-en">useSingletonObject</span>() {
    <span class="pl-c1">println</span>(<span class="pl-en">ObjectExample</span>.hello()) <span class="pl-c"><span class="pl-c">//</span> =&gt; hello</span>
    <span class="pl-c"><span class="pl-c">//</span> In Kotlin, "Any" is the root of the class hierarchy, just like "Object" is in Java</span>
    <span class="pl-k">val</span> someRef<span class="pl-k">:</span> <span class="pl-c1">Any</span> <span class="pl-k">=</span> <span class="pl-en">ObjectExample</span>
    <span class="pl-c1">println</span>(someRef) <span class="pl-c"><span class="pl-c">//</span> =&gt; Hello, it's me, ObjectExample</span>
}


<span class="pl-c"><span class="pl-c">/*</span> The not-null assertion operator (!!) converts any value to a non-null type and</span>
<span class="pl-c">throws an exception if the value is null.</span>
<span class="pl-c"><span class="pl-c">*/</span></span>
<span class="pl-k">var</span> b<span class="pl-k">:</span> <span class="pl-c1">String?</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>
<span class="pl-k">val</span> l <span class="pl-k">=</span> b<span class="pl-k">!!</span>.length

<span class="pl-k">data class</span> <span class="pl-en">Counter</span>(<span class="pl-k">var</span> <span class="pl-smi">value</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>) {
    <span class="pl-c"><span class="pl-c">//</span> overload Counter += Int</span>
    <span class="pl-k">operator</span> <span class="pl-k">fun</span> <span class="pl-en">plusAssign</span>(<span class="pl-smi">increment</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>) {
        <span class="pl-c1">this</span>.value <span class="pl-k">+</span><span class="pl-k">=</span> increment
    }

    <span class="pl-c"><span class="pl-c">//</span> overload Counter++ and ++Counter</span>
    <span class="pl-k">operator</span> <span class="pl-k">fun</span> <span class="pl-en">inc</span>() <span class="pl-k">=</span> <span class="pl-en">Counter</span>(value <span class="pl-k">+</span> <span class="pl-c1">1</span>)

    <span class="pl-c"><span class="pl-c">//</span> overload Counter + Counter</span>
    <span class="pl-k">operator</span> <span class="pl-k">fun</span> <span class="pl-en">plus</span>(<span class="pl-smi">other</span><span class="pl-k">:</span> <span class="pl-en">Counter</span>) <span class="pl-k">=</span> <span class="pl-en">Counter</span>(<span class="pl-c1">this</span>.value <span class="pl-k">+</span> other.value)

    <span class="pl-c"><span class="pl-c">//</span> overload Counter * Counter</span>
    <span class="pl-k">operator</span> <span class="pl-k">fun</span> <span class="pl-en">times</span>(<span class="pl-smi">other</span><span class="pl-k">:</span> <span class="pl-en">Counter</span>) <span class="pl-k">=</span> <span class="pl-en">Counter</span>(<span class="pl-c1">this</span>.value <span class="pl-k">*</span> other.value)

    <span class="pl-c"><span class="pl-c">//</span> overload Counter * Int</span>
    <span class="pl-k">operator</span> <span class="pl-k">fun</span> <span class="pl-en">times</span>(<span class="pl-smi">value</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>) <span class="pl-k">=</span> <span class="pl-en">Counter</span>(<span class="pl-c1">this</span>.value <span class="pl-k">*</span> value)

    <span class="pl-c"><span class="pl-c">//</span> overload Counter in Counter</span>
    <span class="pl-k">operator</span> <span class="pl-k">fun</span> <span class="pl-en">contains</span>(<span class="pl-smi">other</span><span class="pl-k">:</span> <span class="pl-en">Counter</span>) <span class="pl-k">=</span> other.value <span class="pl-k">==</span> <span class="pl-c1">this</span>.value

    <span class="pl-c"><span class="pl-c">//</span> overload Counter[Int] = Int</span>
    <span class="pl-k">operator</span> <span class="pl-k">fun</span> <span class="pl-en">set</span>(<span class="pl-smi">index</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>, <span class="pl-smi">value</span><span class="pl-k">:</span> <span class="pl-c1">Int</span>) {
        <span class="pl-c1">this</span>.value <span class="pl-k">=</span> index <span class="pl-k">+</span> value
    }

    <span class="pl-c"><span class="pl-c">//</span> overload Counter instance invocation</span>
    <span class="pl-k">operator</span> <span class="pl-k">fun</span> <span class="pl-en">invoke</span>() <span class="pl-k">=</span> <span class="pl-c1">println</span>(<span class="pl-s"><span class="pl-pds">"</span>The value of the counter is <span class="pl-e">$value</span><span class="pl-pds">"</span></span>)

}
<span class="pl-c"><span class="pl-c">/*</span> You can also overload operators through extension methods <span class="pl-c">*/</span></span>
<span class="pl-c"><span class="pl-c">//</span> overload -Counter</span>
<span class="pl-k">operator</span> <span class="pl-k">fun</span> Counter.<span class="pl-en">unaryMinus</span>() <span class="pl-k">=</span> <span class="pl-en">Counter</span>(<span class="pl-k">-</span><span class="pl-c1">this</span>.value)

<span class="pl-k">fun</span> <span class="pl-en">operatorOverloadingDemo</span>() {
    <span class="pl-k">var</span> counter1 <span class="pl-k">=</span> <span class="pl-en">Counter</span>(<span class="pl-c1">0</span>)
    <span class="pl-k">var</span> counter2 <span class="pl-k">=</span> <span class="pl-en">Counter</span>(<span class="pl-c1">5</span>)
    counter1 <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">7</span>
    <span class="pl-c1">println</span>(counter1) <span class="pl-c"><span class="pl-c">//</span> =&gt; Counter(value=7)</span>
    <span class="pl-c1">println</span>(counter1 <span class="pl-k">+</span> counter2) <span class="pl-c"><span class="pl-c">//</span> =&gt; Counter(value=12)</span>
    <span class="pl-c1">println</span>(counter1 <span class="pl-k">*</span> counter2) <span class="pl-c"><span class="pl-c">//</span> =&gt; Counter(value=35)</span>
    <span class="pl-c1">println</span>(counter2 <span class="pl-k">*</span> <span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">//</span> =&gt; Counter(value=10)</span>
    <span class="pl-c1">println</span>(counter1 <span class="pl-k">in</span> <span class="pl-en">Counter</span>(<span class="pl-c1">5</span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; false</span>
    <span class="pl-c1">println</span>(counter1 <span class="pl-k">in</span> <span class="pl-en">Counter</span>(<span class="pl-c1">7</span>)) <span class="pl-c"><span class="pl-c">//</span> =&gt; true</span>
    counter1[<span class="pl-c1">26</span>] <span class="pl-k">=</span> <span class="pl-c1">10</span>
    <span class="pl-c1">println</span>(counter1) <span class="pl-c"><span class="pl-c">//</span> =&gt; Counter(value=36)</span>
    counter1() <span class="pl-c"><span class="pl-c">//</span> =&gt; The value of the counter is 36</span>
    <span class="pl-c1">println</span>(<span class="pl-k">-</span>counter2) <span class="pl-c"><span class="pl-c">//</span> =&gt; Counter(value=-5)</span>
}</pre></div>
<h3>Further Reading</h3>
<ul>
<li><a href="https://kotlinlang.org/docs/tutorials/" rel="nofollow">Kotlin tutorials</a></li>
<li><a href="https://play.kotlinlang.org/" rel="nofollow">Try Kotlin in your browser</a></li>
<li><a href="http://kotlin.link/" rel="nofollow">A list of Kotlin resources</a></li>
</ul>
<hr>
<h2>Contributors</h2>
<pre class="notranslate"><code class="notranslate">- ["S Webber", "https://github.com/s-webber"]
</code></pre>